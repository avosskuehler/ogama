<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Emgu.CV</name>
    </assembly>
    <members>
        <member name="T:Emgu.CV.AdaptiveSkinDetector">
            <summary>
            Adaptive Skin Detector
            </summary>
        </member>
        <member name="M:Emgu.CV.AdaptiveSkinDetector.#ctor(System.Int32,Emgu.CV.AdaptiveSkinDetector.MorphingMethod)">
            <summary>
            Create an Adaptive Skin Detector
            </summary>
            <param name="samplingDivider">Use 1 for default</param>
            <param name="morphingMethod">The morphine method for the skin detector</param>
        </member>
        <member name="M:Emgu.CV.AdaptiveSkinDetector.Process(Emgu.CV.Image{Emgu.CV.Structure.Bgr,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Process the image to produce a hue mask
            </summary>
            <param name="image">The input image</param>
            <param name="hueMask">The resulting mask</param>
        </member>
        <member name="M:Emgu.CV.AdaptiveSkinDetector.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this detector
            </summary>
        </member>
        <member name="T:Emgu.CV.AdaptiveSkinDetector.MorphingMethod">
            <summary>
            Morphing method
            </summary>
        </member>
        <member name="F:Emgu.CV.AdaptiveSkinDetector.MorphingMethod.NONE">
            <summary>
            None
            </summary>
        </member>
        <member name="F:Emgu.CV.AdaptiveSkinDetector.MorphingMethod.ERODE">
            <summary>
            Erode
            </summary>
        </member>
        <member name="F:Emgu.CV.AdaptiveSkinDetector.MorphingMethod.ERODE_ERODE">
            <summary>
            Double Erode 
            </summary>
        </member>
        <member name="F:Emgu.CV.AdaptiveSkinDetector.MorphingMethod.ERODE_DILATE">
            <summary>
            Erode dilate
            </summary>
        </member>
        <member name="T:Emgu.CV.CameraCalibration">
            <summary>
            Camera calibration functions
            </summary>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.CalibrateCamera(Emgu.CV.Structure.MCvPoint3D32f[][],System.Drawing.PointF[][],System.Drawing.Size,Emgu.CV.IntrinsicCameraParameters,Emgu.CV.CvEnum.CALIB_TYPE,Emgu.CV.ExtrinsicCameraParameters[]@)">
            <summary>
            Estimates intrinsic camera parameters and extrinsic parameters for each of the views
            </summary>
            <param name="objectPoints">The 3D location of the object points. The first index is the index of image, second index is the index of the point</param>
            <param name="imagePoints">The 2D image location of the points. The first index is the index of the image, second index is the index of the point</param>
            <param name="imageSize">The size of the image, used only to initialize intrinsic camera matrix</param>
            <param name="intrinsicParam">The intrisinc parameters, might contains some initial values. The values will be modified by this function.</param>
            <param name="flags">Flags</param>
            <param name="extrinsicParams">The output array of extrinsic parameters.</param>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.StereoCalibrate(Emgu.CV.Structure.MCvPoint3D32f[][],System.Drawing.PointF[][],System.Drawing.PointF[][],Emgu.CV.IntrinsicCameraParameters,Emgu.CV.IntrinsicCameraParameters,System.Drawing.Size,Emgu.CV.CvEnum.CALIB_TYPE,Emgu.CV.Structure.MCvTermCriteria,Emgu.CV.ExtrinsicCameraParameters@,Emgu.CV.Matrix{System.Double}@,Emgu.CV.Matrix{System.Double}@)">
            <summary>
            Estimates transformation between the 2 cameras making a stereo pair. If we have a stereo camera, where the relative position and orientatation of the 2 cameras is fixed, and if we computed poses of an object relative to the fist camera and to the second camera, (R1, T1) and (R2, T2), respectively (that can be done with cvFindExtrinsicCameraParams2), obviously, those poses will relate to each other, i.e. given (R1, T1) it should be possible to compute (R2, T2) - we only need to know the position and orientation of the 2nd camera relative to the 1st camera. That's what the described function does. It computes (R, T) such that:
            R2=R*R1,
            T2=R*T1 + T
            </summary>
            <param name="objectPoints">The 3D location of the object points. The first index is the index of image, second index is the index of the point</param>
            <param name="imagePoints1">The 2D image location of the points for camera 1. The first index is the index of the image, second index is the index of the point</param>
            <param name="imagePoints2">The 2D image location of the points for camera 2. The first index is the index of the image, second index is the index of the point</param>
            <param name="intrinsicParam1">The intrisinc parameters for camera 1, might contains some initial values. The values will be modified by this function.</param>
            <param name="intrinsicParam2">The intrisinc parameters for camera 2, might contains some initial values. The values will be modified by this function.</param>
            <param name="imageSize">Size of the image, used only to initialize intrinsic camera matrix</param>
            <param name="flags">Different flags</param>
            <param name="extrinsicParams">The extrinsic parameters which contains:
            R - The rotation matrix between the 1st and the 2nd cameras' coordinate systems; 
            T - The translation vector between the cameras' coordinate systems. </param>
            <param name="essentialMatrix">essential matrix</param>
            <param name="termCrit"> Termination criteria for the iterative optimiziation algorithm </param>
            <param name="foundamentalMatrix">fundamental matrix</param>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.FindExtrinsicCameraParams2(Emgu.CV.Structure.MCvPoint3D32f[],System.Drawing.PointF[],Emgu.CV.IntrinsicCameraParameters)">
            <summary>
            Estimates extrinsic camera parameters using known intrinsic parameters and and extrinsic parameters for each view. The coordinates of 3D object points and their correspondent 2D projections must be specified. This function also minimizes back-projection error. 
            </summary>
            <param name="objectPoints">The array of object points</param>
            <param name="imagePoints">The array of corresponding image points</param>
            <param name="intrin">The intrinsic parameters</param>
            <returns>The extrinsic parameters</returns>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.ProjectPoints(Emgu.CV.Structure.MCvPoint3D32f[],Emgu.CV.ExtrinsicCameraParameters,Emgu.CV.IntrinsicCameraParameters,Emgu.CV.Matrix{System.Single}[])">
            <summary>
            Computes projections of 3D points to the image plane given intrinsic and extrinsic camera parameters. 
            Optionally, the function computes jacobians - matrices of partial derivatives of image points as functions of all the input parameters w.r.t. the particular parameters, intrinsic and/or extrinsic. 
            The jacobians are used during the global optimization in cvCalibrateCamera2 and cvFindExtrinsicCameraParams2. 
            The function itself is also used to compute back-projection error for with current intrinsic and extrinsic parameters. 
            </summary>
            <remarks>Note, that with intrinsic and/or extrinsic parameters set to special values, the function can be used to compute just extrinsic transformation or just intrinsic transformation (i.e. distortion of a sparse set of points) </remarks>
            <param name="objectPoints">The array of object points.</param>
            <param name="extrin">Extrinsic parameters</param>
            <param name="intrin">Intrinsic parameters</param>
            <param name="mats">Optional matrix supplied in the following order: dpdrot, dpdt, dpdf, dpdc, dpddist</param>
            <returns>The array of image points which is the projection of <paramref name="objectPoints"/></returns>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.FindHomography(Emgu.CV.Matrix{System.Single},Emgu.CV.Matrix{System.Single},Emgu.CV.CvEnum.HOMOGRAPHY_METHOD,System.Double)">
            <summary>
            Use the specific method to find perspective transformation H=||h_ij|| between the source and the destination planes 
            </summary>
            <param name="srcPoints">Point coordinates in the original plane, 2xN, Nx2, 3xN or Nx3 array (the latter two are for representation in homogenious coordinates), where N is the number of points</param>
            <param name="dstPoints">Point coordinates in the destination plane, 2xN, Nx2, 3xN or Nx3 array (the latter two are for representation in homogenious coordinates) </param>
            <param name="method">FindHomography method</param>
            <param name="ransacReprojThreshold">The maximum allowed reprojection error to treat a point pair as an inlier. The parameter is only used in RANSAC-based homography estimation. E.g. if dst_points coordinates are measured in pixels with pixel-accurate precision, it makes sense to set this parameter somewhere in the range ~1..3</param>
            <returns>The 3x3 homography matrix if found. Null if not found.</returns>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.FindHomography(System.Drawing.PointF[],System.Drawing.PointF[],Emgu.CV.CvEnum.HOMOGRAPHY_METHOD,System.Double)">
            <summary>
            Finds perspective transformation H=||h_ij|| between the source and the destination planes
            </summary>
            <param name="srcPoints">Point coordinates in the original plane</param>
            <param name="dstPoints">Point coordinates in the destination plane</param>
            <param name="method">FindHomography method</param>
            <param name="ransacReprojThreshold">
            The maximum allowed reprojection error to treat a point pair as an inlier. 
            The parameter is only used in RANSAC-based homography estimation. 
            E.g. if dst_points coordinates are measured in pixels with pixel-accurate precision, it makes sense to set this parameter somewhere in the range ~1..3
            </param>
            <returns>The 3x3 homography matrix if found. Null if not found.</returns>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.FindChessboardCorners(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},System.Drawing.Size,Emgu.CV.CvEnum.CALIB_CB_TYPE,System.Drawing.PointF[]@)">
            <summary>
            attempts to determine whether the input image is a view of the chessboard pattern and locate internal chessboard corners
            </summary>
            <param name="image">Source chessboard view</param>
            <param name="patternSize">The number of inner corners per chessboard row and column</param>
            <param name="corners">The corners detected</param>
            <param name="flags">Various operation flags</param>
            <returns>If the chess board pattern is found</returns>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.DrawChessboardCorners(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},System.Drawing.Size,System.Drawing.PointF[],System.Boolean)">
            <summary>
            Draws the individual chessboard corners detected (as red circles) in case if the board was not found (patternWasFound== false) or the colored corners connected with lines when the board was found (patternWasFound == true). 
            </summary>
            <param name="image">The destination image</param>
            <param name="patternSize">The number of inner corners per chessboard row and column</param>
            <param name="corners">The array of corners detected</param>
            <param name="patternWasFound">Result of FindChessboardCorners</param>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.GetAffineTransform(System.Drawing.PointF[],System.Drawing.PointF[])">
            <summary>
            Calculates the matrix of an affine transform such that:
            (x'_i,y'_i)^T=map_matrix (x_i,y_i,1)^T
            where dst(i)=(x'_i,y'_i), src(i)=(x_i,y_i), i=0..2.
            </summary>
            <param name="src">Coordinates of 3 triangle vertices in the source image. If the array contains more than 3 points, only the first 3 will be used</param>
            <param name="dest">Coordinates of the 3 corresponding triangle vertices in the destination image. If the array contains more than 3 points, only the first 3 will be used</param>
            <returns>The 2x3 rotation matrix that defines the Affine transform</returns>
        </member>
        <member name="M:Emgu.CV.CameraCalibration.GetPerspectiveTransform(System.Drawing.PointF[],System.Drawing.PointF[])">
            <summary>
            calculates matrix of perspective transform such that:
            (t_i x'_i,t_i y'_i,t_i)^T=map_matrix (x_i,y_i,1)^T
            where dst(i)=(x'_i,y'_i), src(i)=(x_i,y_i), i=0..3.
            </summary>
            <param name="src">Coordinates of 4 quadrangle vertices in the source image</param>
            <param name="dest">Coordinates of the 4 corresponding quadrangle vertices in the destination image</param>
            <returns>The 3x3 Homography matrix</returns>
        </member>
        <member name="T:Emgu.CV.ExtrinsicCameraParameters">
            <summary>
            Extrinsic camera parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.ExtrinsicCameraParameters.#ctor">
            <summary>
            Create the extrinsic camera parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.ExtrinsicCameraParameters.#ctor(Emgu.CV.RotationVector3D,Emgu.CV.Matrix{System.Double})">
            <summary>
            Create the extrinsic camera parameters using the specific rotation and translation matrix
            </summary>
            <param name="rotation">The rotation vector</param>
            <param name="translation">The translation vector</param>
        </member>
        <member name="M:Emgu.CV.ExtrinsicCameraParameters.Equals(Emgu.CV.ExtrinsicCameraParameters)">
            <summary>
            Return true if the two extrinsic camera parameters are equal
            </summary>
            <param name="other">The other extrinsic camera parameters to compare with</param>
            <returns>True if the two extrinsic camera parameters are equal</returns>
        </member>
        <member name="P:Emgu.CV.ExtrinsicCameraParameters.RotationVector">
            <summary>
            Get or Set the rodrigus rotation vector
            </summary>
        </member>
        <member name="P:Emgu.CV.ExtrinsicCameraParameters.TranslationVector">
            <summary>
            Get or Set the translation vector ( as 3 x 1 matrix)
            </summary>
        </member>
        <member name="P:Emgu.CV.ExtrinsicCameraParameters.ExtrinsicMatrix">
            <summary>
            Get the 3 x 4 extrinsic matrix: [[r11 r12 r13 t1] [r21 r22 r23 t2] [r31 r32 r33 t2]]
            </summary>
        </member>
        <member name="T:Emgu.CV.HomographyMatrix">
            <summary>
            A 3x3 homography matrix. This matrix defines an perspective transform
            </summary>
        </member>
        <member name="T:Emgu.CV.Matrix`1">
            <summary> 
            A Matrix is a wrapper to cvMat of OpenCV. 
            </summary>
            <typeparam name="TDepth">Depth of this matrix (either Byte, SByte, Single, double, UInt16, Int16 or Int32)</typeparam>
        </member>
        <member name="T:Emgu.CV.CvArray`1">
            <summary>
            Wrapped CvArr 
            </summary>
            <typeparam name="TDepth">The type of elements in this CvArray</typeparam>
        </member>
        <member name="F:Emgu.CV.CvArray`1._sizeOfElement">
            <summary>
            The size of the elements in the CvArray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvArray`1._dataHandle">
            <summary>
            The pinned GCHandle to _array;
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1.AllocateData(System.Int32,System.Int32,System.Int32)">
            <summary>
            Allocate data for the array
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of columns</param>
            <param name="numberOfChannels">The number of channels of this cvArray</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.DotProduct(Emgu.CV.CvArray{`0})">
            <summary>
            Calculates and returns the Euclidean dot product of two arrays.
            src1 dot src2 = sumI(src1(I)*src2(I))
            </summary>
            <remarks>In case of multiple channel arrays the results for all channels are accumulated. In particular, cvDotProduct(a,a), where a is a complex vector, will return ||a||^2. The function can process multi-dimensional arrays, row by row, layer by layer and so on.</remarks>
            <param name="src2">The other Array to apply dot product with</param>
            <returns>src1 dot src2</returns>
        </member>
        <member name="M:Emgu.CV.CvArray`1.Reduce``1(Emgu.CV.CvArray{``0},Emgu.CV.CvEnum.REDUCE_DIMENSION,Emgu.CV.CvEnum.REDUCE_TYPE)">
            <summary>
            Reduces matrix to a vector by treating the matrix rows/columns as a set of 1D vectors and performing the specified operation on the vectors until a single row/column is obtained. 
            </summary>
            <remarks>
            The function can be used to compute horizontal and vertical projections of an raster image. 
            In case of CV_REDUCE_SUM and CV_REDUCE_AVG the output may have a larger element bit-depth to preserve accuracy. 
            And multi-channel arrays are also supported in these two reduction modes
            </remarks>
            <param name="array1D">The destination single-row/single-column vector that accumulates somehow all the matrix rows/columns</param>
            <param name="dim">The dimension index along which the matrix is reduce.</param>
            <param name="type">The reduction operation type</param>
            <typeparam name="TOtherDepth">The type of depth of the reduced array</typeparam>
        </member>
        <member name="M:Emgu.CV.CvArray`1.CopyTo(Emgu.CV.CvArray{`0})">
            <summary>
             Copy the current array to <paramref name="dest"/>
             </summary>
             <param name="dest"> The destination Array</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetValue(Emgu.CV.Structure.MCvScalar)">
            <summary> 
            Set the element of the Array to <paramref name="val"/>
            </summary>
            <param name="val"> The value to be set for each element of the Array </param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetValue(System.Double)">
            <summary> 
            Set the element of the Array to <paramref name="val"/>
            </summary>
            <param name="val"> The value to be set for each element of the Array </param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetValue(Emgu.CV.Structure.MCvScalar,Emgu.CV.CvArray{System.Byte})">
            <summary>
            Set the element of the Array to <paramref name="val"/>, using the specific <paramref name="mask"/>
            </summary>
            <param name="val">The value to be set</param>
            <param name="mask">The mask for the operation</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetValue(System.Double,Emgu.CV.CvArray{System.Byte})">
            <summary>
            Set the element of the Array to <paramref name="val"/>, using the specific <paramref name="mask"/>
            </summary>
            <param name="val">The value to be set</param>
            <param name="mask">The mask for the operation</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetRandUniform(System.UInt64,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Inplace fills Array with uniformly distributed random numbers
            </summary>
            <param name="seed">Seed for the random number generator</param>
            <param name="floorValue">the inclusive lower boundary of random numbers range</param>
            <param name="ceilingValue">the exclusive upper boundary of random numbers range</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetRandUniform(Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Inplace fills Array with uniformly distributed random numbers
            </summary>
            <param name="floorValue">the inclusive lower boundary of random numbers range</param>
            <param name="ceilingValue">the exclusive upper boundary of random numbers range</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetRandNormal(System.UInt64,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Inplace fills Array with normally distributed random numbers
            </summary>
            <param name="seed">Seed for the random number generator</param>
            <param name="mean">the mean value of random numbers</param>
            <param name="std"> the standard deviation of random numbers</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetRandNormal(Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Inplace fills Array with normally distributed random numbers
            </summary>
            <param name="mean">the mean value of random numbers</param>
            <param name="std"> the standard deviation of random numbers</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetIdentity(Emgu.CV.Structure.MCvScalar)">
            <summary>
            Initializs scaled identity matrix
            </summary>
            <param name="value">The value on the diagonal</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetZero">
            <summary>
            Set the values to zero
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1.SetIdentity">
            <summary>
            Initialize the identity matrix
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Mul(System.Double)">
            <summary>
            Inplace multiply elements of the Array by <paramref name="scale"/>
            </summary>
            <param name="scale">The scale to be multiplyed</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Mul(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace elementwise multiply the current Array with <paramref name="src2"/>
            </summary>
            <param name="src2">The other array to be elementwise multiplied with</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.DisposeObject">
            <summary>
            Free the _dataHandle if it is set
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Min(System.Double)">
            <summary>
            Inplace compute the elementwise minimum value 
            </summary>
            <param name="value">The value to compare with</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Min(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace elementwise minimize the current Array with <paramref name="other"/>
            </summary>
            <param name="other">The other array to be elementwise minimized with this array</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Max(System.Double)">
            <summary>
            Inplace compute the elementwise maximum value with <paramref name="val"/>
            </summary>
            <param name="value">The value to be compare with</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Max(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace elementwise maximize the current Array with <paramref name="other"/>
            </summary>
            <param name="other">The other array to be elementwise maximized with this array</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._And(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace And operation with <paramref name="src2"/>
            </summary>
            <param name="src2">The other array to perform AND operation</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Or(Emgu.CV.CvArray{`0})">
            <summary>
            Inplace Or operation with <paramref name="src2"/>
            </summary>
            <param name="src2">The other array to perform OR operation</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1._Not">
            <summary> 
            Inplace compute the complement for all array elements
            </summary>
        </member>
        <member name="M:Emgu.CV.CvArray`1.Save(System.String)">
            <summary>
            Save the CvArray as image
            </summary>
            <param name="fileName">The name of the image to save</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.GetSchema">
            <summary>
            Get the xml schema
            </summary>
            <returns>the xml schema</returns>
        </member>
        <member name="M:Emgu.CV.CvArray`1.ReadXml(System.Xml.XmlReader)">
            <summary>
            Function to call when deserializing this object from XML
            </summary>
            <param name="reader">The xml reader</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Function to call when serializing this object to XML 
            </summary>
            <param name="writer">The xml writer</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serilization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.CvArray`1.DeserializeObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime deserailization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="P:Emgu.CV.CvArray`1.SerializationCompressionRatio">
            <summary>
            Get or set the Compression Ratio for serialization. A number between 0 - 9. 
            0 means no compression at all, while 9 means best compression
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Ptr">
            <summary> The pointer to the internal structure </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Size">
            <summary> 
             Get the size of the array
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Width">
            <summary> 
            Get the width (#Cols) of the cvArray.
            If ROI is set, the width of the ROI 
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Height">
            <summary> 
            Get the height (#Rows) of the cvArray.
            If ROI is set, the height of the ROI 
            </summary> 
        </member>
        <member name="P:Emgu.CV.CvArray`1.NumberOfChannels">
            <summary>
            Get the number of channels of the array
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Rows">
            <summary>
            The number of rows for this array
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Cols">
            <summary>
            The number of cols for this array
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Bytes">
            <summary>
            Get or Set an Array of bytes that represent the data in this array
            </summary>
            <remarks> Should only be used for serialization &amp; deserialization</remarks>
        </member>
        <member name="P:Emgu.CV.CvArray`1.ManagedArray">
            <summary>
            Get the underneath managed array
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Trace">
            <summary>
            Sum of diagonal elements of the matrix 
            </summary>
        </member>
        <member name="P:Emgu.CV.CvArray`1.Norm">
            <summary> 
            The norm of this Array 
            </summary>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor">
            <summary>
            The default constructor which allows Data to be set later on
            </summary>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Int32,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Create a Matrix (only header is allocated) using the Pinned/Unmanaged <paramref name="data"/>. The <paramref name="data"/> is not freed by the disposed function of this class 
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of cols</param>
            <param name="data">The Pinned/Unmanaged data, the data must not be release before the Matrix is Disposed</param>
            <param name="step">The step (row stride in bytes)</param>
            <remarks>The caller is responsible for allocating and freeing the block of memory specified by the data parameter, however, the memory should not be released until the related Matrix is released. </remarks>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Create a Matrix (only header is allocated) using the Pinned/Unmanaged <paramref name="data"/>. The <paramref name="data"/> is not freed by the disposed function of this class 
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of cols</param>
            <param name="channels">The number of channels</param>
            <param name="data">The Pinned/Unmanaged data, the data must not be release before the Matrix is Disposed</param>
            <param name="step">The step (row stride in bytes)</param>
            <remarks>The caller is responsible for allocating and freeing the block of memory specified by the data parameter, however, the memory should not be released until the related Matrix is released. </remarks>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Int32,System.Int32,System.IntPtr)">
            <summary>
            Create a Matrix (only header is allocated) using the Pinned/Unmanaged <paramref name="data"/>. The <paramref name="data"/> is not freed by the disposed function of this class 
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of cols</param>
            <param name="data">The Pinned/Unmanaged data, the data must not be release before the Matrix is Disposed</param>
            <remarks>The caller is responsible for allocating and freeing the block of memory specified by the data parameter, however, the memory should not be released until the related Matrix is released. </remarks>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a matrix of the specific size
            </summary>
            <param name="rows">The number of rows (<b>height</b>)</param>
            <param name="cols">The number of cols (<b>width</b>)</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Drawing.Size)">
            <summary>
            Create a matrix of the specific size
            </summary>
            <param name="size">The size of the matrix</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a matrix of the specific size and channels
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of cols</param>
            <param name="channels">The number of channels</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(`0[0:,0:])">
            <summary> 
            Create a matrix using the specific <paramref>data</paramref>
            </summary>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(`0[])">
            <summary>
            Create a matrix using the specific <paramref name="data"/>
            </summary>
            <param name="data">the data for this matrix</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.CopyBlank">
            <summary>
            Return a matrix of the same size with all elements equals 0
            </summary>
            <returns>A matrix of the same size with all elements equals 0</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Clone">
            <summary>
            Make a copy of this matrix
            </summary>
            <returns>A copy if this matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Reshape(System.Int32,System.Int32)">
            <summary>
            Get reshaped matrix which also share the same data with the current matrix
            </summary>
            <param name="newChannels">the new number of channles</param>
            <param name="newRows">The new number of rows</param>
            <returns>A reshaped matrix which also share the same data with the current matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Convert``1">
            <summary>
            Convert this matrix to different depth
            </summary>
            <typeparam name="TOtherDepth">The depth type to convert to</typeparam>
            <returns>Matrix of different depth</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Transpose">
            <summary> Returns the transpose of this matrix</summary>
            <returns>The transpose of this matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.AllocateData(System.Int32,System.Int32,System.Int32)">
            <summary>
            Allocate data for the array
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of columns</param>
            <param name="numberOfChannels">The number of channels for this matrix</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetSubRect(System.Drawing.Rectangle)">
            <summary>
            Get a submatrix corresponding to a specified rectangle
            </summary>
            <param name="rect">the rectangle area of the sub-matrix</param>
            <returns>A submatrix corresponding to a specified rectangle</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetRow(System.Int32)">
            <summary>
            Get the specific row of the matrix
            </summary>
            <param name="row">the index of the row to be reterived</param>
            <returns>the specific row of the matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetRows(System.Int32,System.Int32,System.Int32)">
            <summary>
            Return the matrix corresponding to a specified row span of the input array
            </summary>
            <param name="startRow">Zero-based index of the starting row (inclusive) of the span</param>
            <param name="endRow">Zero-based index of the ending row (exclusive) of the span</param>
            <param name="deltaRow">Index step in the row span. That is, the function extracts every delta_row-th row from start_row and up to (but not including) end_row</param>
            <returns>A matrix corresponding to a specified row span of the input array</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetCol(System.Int32)">
            <summary>
            Get the specific column of the matrix
            </summary>
            <param name="col">the index of the column to be reterived</param>
            <returns>the specific column of the matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetCols(System.Int32,System.Int32)">
            <summary>
            Get the Matrix, corresponding to a specified column span of the input array
            </summary>
            <param name="endCol">Zero-based index of the ending column (exclusive) of the span</param>
            <param name="startCol">Zero-based index of the selected column</param>
            <returns>the specific column span of the matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetDiag(System.Int32)">
            <summary>
            Return the specific diagonal elements of this matrix
            </summary>
            <param name="diag">Array diagonal. Zero corresponds to the main diagonal, -1 corresponds to the diagonal above the main etc., 1 corresponds to the diagonal below the main etc</param>
            <returns>The specific diagonal elements of this matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.GetDiag">
            <summary>
            Return the main diagonal element of this matrix
            </summary>
            <returns>The main diagonal element of this matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.RemoveRows(System.Int32,System.Int32)">
            <summary>
            Return the matrix without a specified row span of the input array
            </summary>
            <param name="startRow">Zero-based index of the starting row (inclusive) of the span</param>
            <param name="endRow">Zero-based index of the ending row (exclusive) of the span</param>
            <returns>The matrix without a specified row span of the input array</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.RemoveCols(System.Int32,System.Int32)">
            <summary>
            Return the matrix without a specified column span of the input array
            </summary>
            <param name="startCol">Zero-based index of the starting column (inclusive) of the span</param>
            <param name="endCol">Zero-based index of the ending column (exclusive) of the span</param>
            <returns>The matrix without a specified column span of the input array</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.ConcateVertical(Emgu.CV.Matrix{`0})">
            <summary>
            Concate the current matrix with another matrix vertically. If this matrix is n1 x m and <paramref name="otherMatrix"/> is n2 x m, the resulting matrix is (n1+n2) x m.
            </summary>
            <param name="otherMatrix">The other matrix to concate</param>
            <returns>A new matrix that is the vertical concatening of this matrix and <paramref name="otheMatrix"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.ConcateHorizontal(Emgu.CV.Matrix{`0})">
            <summary>
            Concate the current matrix with another matrix horizontally. If this matrix is n x m1 and <paramref name="otherMatrix"/> is n x m2, the resulting matrix is n x (m1 + m2).
            </summary>
            <param name="otherMatrix">The other matrix to concate</param>
            <returns>A matrix that is the horizontal concatening of this matrix and <paramref name="otheMatrix"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.MinMax(System.Double@,System.Double@,System.Drawing.Point@,System.Drawing.Point@)">
            <summary>
            Returns the min / max locations and values for the matrix
            </summary>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Add(Emgu.CV.Matrix{`0})">
            <summary> Elementwise add another matrix with the current matrix </summary>
            <param name="mat2">The matrix to be added to the current matrix</param>
            <returns> The result of elementwise adding mat2 to the current matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Add(`0)">
            <summary> Elementwise add a color <paramref name="val"/> to the current matrix</summary>
            <param name="val">The value to be added to the current matrix</param>
            <returns> The result of elementwise adding <paramref name="val"/> from the current matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Sub(Emgu.CV.Matrix{`0})">
            <summary> Elementwise substract another matrix from the current matrix </summary>
            <param name="mat2"> The matrix to be substracted to the current matrix</param>
            <returns> The result of elementwise substracting mat2 from the current matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Sub(`0)">
            <summary> Elementwise substract a color <paramref name="val"/> to the current matrix</summary>
            <param name="val"> The value to be substracted from the current matrix</param>
            <returns> The result of elementwise substracting <paramref name="val"/> from the current matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.SubR(`0)">
            <summary>
            result = val - this
            </summary>
            <param name="val">The value which subtract this matrix</param>
            <returns>val - this</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Mul(System.Double)">
            <summary> Multiply the current matrix with <paramref name="scale"/></summary>
            <param name="scale">The scale to be multiplied</param>
            <returns> The scaled matrix </returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Mul(Emgu.CV.Matrix{`0})">
            <summary> Multiply the current matrix with <paramref name="mat2"/></summary>
            <param name="mat2">The matrix to be multiplied</param>
            <returns> Result matrix of the multiplication </returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Addition(Emgu.CV.Matrix{`0},Emgu.CV.Matrix{`0})">
            <summary>
            Elementwise add <paramref name="mat1"/> with <paramref name="mat2"/>
            </summary>
            <param name="mat1">The Matrix to be added</param>
            <param name="mat2">The Matrix to be added</param>
            <returns>The elementwise sum of the two matrices</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Addition(Emgu.CV.Matrix{`0},System.Double)">
            <summary>
            Elementwise add <paramref name="mat1"/> with <paramref name="val"/>
            </summary>
            <param name="mat1">The Matrix to be added</param>
            <param name="val">The value to be added</param>
            <returns>The matrix plus the value</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Addition(System.Double,Emgu.CV.Matrix{`0})">
            <summary>
            <paramref name="val"/> + <paramref name="mat1"/>
            </summary>
            <param name="mat1">The Matrix to be added</param>
            <param name="val">The value to be added</param>
            <returns>The matrix plus the value</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Subtraction(System.Double,Emgu.CV.Matrix{`0})">
            <summary>
            <paramref name="val"/> - <paramref name="mat1"/> 
            </summary>
            <param name="mat1">The Matrix to be subtracted</param>
            <param name="val">The value to be subtracted</param>
            <returns><paramref name="val"/> - <paramref name="mat1"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Subtraction(Emgu.CV.Matrix{`0},Emgu.CV.Matrix{`0})">
            <summary>
            <paramref name="mat1"/> - <paramref name="mat2"/> 
            </summary>
            <param name="mat1">The Matrix to be subtracted</param>
            <param name="mat2">The matrix to subtract</param>
            <returns><paramref name="mat1"/> - <paramref name="mat2"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Subtraction(Emgu.CV.Matrix{`0},System.Double)">
            <summary>
            <paramref name="mat1"/> - <paramref name="val"/> 
            </summary>
            <param name="mat1">The Matrix to be subtracted</param>
            <param name="val">The value to be subtracted</param>
            <returns><paramref name="mat1"/> - <paramref name="val"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Multiply(Emgu.CV.Matrix{`0},System.Double)">
            <summary>
            <paramref name="mat1"/> * <paramref name="val"/> 
            </summary>
            <param name="mat1">The Matrix to be multiplied</param>
            <param name="val">The value to be multiplied</param>
            <returns><paramref name="mat1"/> * <paramref name="val"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Multiply(System.Double,Emgu.CV.Matrix{`0})">
            <summary>
             <paramref name="val"/> * <paramref name="mat1"/> 
            </summary>
            <param name="mat1">The matrix to be multiplied</param>
            <param name="val">The value to be multiplied</param>
            <returns> <paramref name="val"/> * <paramref name="mat1"/> </returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Division(Emgu.CV.Matrix{`0},System.Double)">
            <summary>
            <paramref name="mat1"/> / <paramref name="val"/> 
            </summary>
            <param name="mat1">The Matrix to be divided</param>
            <param name="val">The value to be divided</param>
            <returns><paramref name="mat1"/> / <paramref name="val"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.op_Multiply(Emgu.CV.Matrix{`0},Emgu.CV.Matrix{`0})">
            <summary>
            <paramref name="mat1"/> * <paramref name="mat2"/> 
            </summary>
            <param name="mat1">The Matrix to be multiplied</param>
            <param name="mat2">The Matrix to be multiplied</param>
            <returns><paramref name="mat1"/> * <paramref name="mat2"/></returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Matrix`1.DisposeObject">
            <summary>
            Release the matrix and all the memory associate with it
            </summary>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Cmp(Emgu.CV.Matrix{`0},Emgu.CV.CvEnum.CMP_TYPE)">
            <summary>
            This function compare the current matrix with <paramref name="mat2"/> and returns the comparison mask
            </summary>
            <param name="mat2">The other matrix to compare with</param>
            <param name="type">Comparison type</param>
            <returns>The comparison mask</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Split">
            <summary>
            Get all channels for the multi channel matrix
            </summary>
            <returns>Each individual channel of this matrix</returns>
        </member>
        <member name="M:Emgu.CV.Matrix`1.Equals(Emgu.CV.Matrix{`0})">
            <summary>
            Return true if every element of this matrix equals elements in <paramref name="mat2"/>
            </summary>
            <param name="mat2">The other matrix to compare with</param>
            <returns>true if every element of this matrix equals elements in <paramref name="mat2"/></returns>
        </member>
        <member name="P:Emgu.CV.Matrix`1.ManagedArray">
            <summary>
            Get the underneath managed array
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Data">
            <summary>
            Get or Set the data for this matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.NumberOfChannels">
            <summary>
            Get the number of channels for this matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.MCvMat">
            <summary>
            The MCvMat structure format  
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Det">
            <summary>
            The function cvDet returns determinant of the square matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Sum">
            <summary>
            Return the sum of the elements in this matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Matrix`1.Item(System.Int32,System.Int32)">
            <summary>
            Get or Set the value in the specific <paramref name="row"/> and <paramref name="col"/>
            </summary>
            <param name="row">the row of the element</param>
            <param name="col">the col of the element</param>
            <returns>The element on the specific <paramref name="row"/> and <paramref name="col"/></returns>
        </member>
        <member name="M:Emgu.CV.HomographyMatrix.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize homography matrix
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.HomographyMatrix.#ctor">
            <summary>
            Create an empty homography matrix
            </summary>
        </member>
        <member name="M:Emgu.CV.HomographyMatrix.IsValid(System.Double)">
            <summary>
            Check if the homography matrix is valid.
            </summary>
            <param name="thresholdForDeterminant">A number &gt; 1. A good number will be 10, if if the deteminate of the homography matrix is in the range of [1/threshold, threshold], true is returned</param>
            <returns>True, if the deteminate of the homography matrix is in the range of [1/threshold, threshold]</returns>
        </member>
        <member name="M:Emgu.CV.HomographyMatrix.ProjectPoints(System.Drawing.PointF[])">
            <summary>
            Get the homography projection of the points. The projected value will be saved to the input point array
            </summary>
            <param name="points">The points to apply homography transform</param>
        </member>
        <member name="T:Emgu.CV.IntrinsicCameraParameters">
            <summary>
            Intrinsic camera parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.IntrinsicCameraParameters.#ctor">
            <summary>
            Create the intrinsic camera parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.IntrinsicCameraParameters.InitUndistortMap(System.Int32,System.Int32,Emgu.CV.Matrix{System.Single}@,Emgu.CV.Matrix{System.Single}@)">
            <summary>
            Pre-computes the undistortion map - coordinates of the corresponding pixel in the distorted image for every pixel in the corrected image. Then, the map (together with input and output images) can be passed to cvRemap function.
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
            <param name="mapx">The output array of x-coordinates of the map</param>
            <param name="mapy">The output array of y-coordinates of the map</param>
        </member>
        <member name="M:Emgu.CV.IntrinsicCameraParameters.GetIntrinsicMatrixValues(System.Int32,System.Int32,System.Double,System.Double,System.Double@,System.Double@,System.Double@,Emgu.CV.Structure.MCvPoint2D64f@,System.Double@)">
            <summary>
            computes various useful camera (sensor/lens) characteristics using the computed camera calibration matrix, image frame resolution in pixels and the physical aperture size
            </summary>
            <param name="imgWidth">Image width in pixels</param>
            <param name="imgHeight">Image height in pixels</param>
            <param name="apertureWidth">Aperture width in realworld units (optional input parameter). Set it to 0 if not used</param>
            <param name="apertureHeight">Aperture width in realworld units (optional input parameter). Set it to 0 if not used</param>
            <param name="fovx">Field of view angle in x direction in degrees</param>
            <param name="fovy">Field of view angle in y direction in degrees </param>
            <param name="focalLength">Focal length in realworld units </param>
            <param name="principalPoint">The principal point in realworld units </param>
            <param name="pixelAspectRatio">The pixel aspect ratio ~ fy/f</param>
        </member>
        <member name="M:Emgu.CV.IntrinsicCameraParameters.Undistort(System.Drawing.PointF[],Emgu.CV.Matrix{System.Double},Emgu.CV.Matrix{System.Double})">
            <summary>
            Similar to cvInitUndistortRectifyMap and is opposite to it at the same time.
            The functions are similar in that they both are used to correct lens distortion and to perform the optional perspective (rectification) transformation.
            They are opposite because the function cvInitUndistortRectifyMap does actually perform the reverse transformation in order to initialize the maps properly, while this function does the forward transformation.
            </summary>
            <param name="src">The observed point coordinates</param>
            <param name="R">Optional rectification transformation in object space (3x3 matrix). R1 or R2, computed by cvStereoRectify can be passed here. If null, the identity matrix is used.</param>
            <param name="P">Optional new camera matrix (3x3) or the new projection matrix (3x4). P1 or P2, computed by cvStereoRectify can be passed here. If null, the identity matrix is used.</param>
        </member>
        <member name="M:Emgu.CV.IntrinsicCameraParameters.Undistort``2(Emgu.CV.Image{``0,``1})">
            <summary>
            Transforms the image to compensate radial and tangential lens distortion. 
            The camera matrix and distortion parameters can be determined using cvCalibrateCamera2. For every pixel in the output image the function computes coordinates of the corresponding location in the input image using the formulae in the section beginning. Then, the pixel value is computed using bilinear interpolation. If the resolution of images is different from what was used at the calibration stage, fx, fy, cx and cy need to be adjusted appropriately, while the distortion coefficients remain the same
            </summary>
            <typeparam name="TColor">The color type of the image</typeparam>
            <typeparam name="TDepth">The depth of the image</typeparam>
            <param name="src">The distorted image</param>
            <returns>The corrected image</returns>
        </member>
        <member name="M:Emgu.CV.IntrinsicCameraParameters.Equals(Emgu.CV.IntrinsicCameraParameters)">
            <summary>
            Return true if the two intrinsic camera parameters are equal
            </summary>
            <param name="other">The other intrinsic camera parameters to compare with</param>
            <returns>True if the two intrinsic camera parameters are equal</returns>
        </member>
        <member name="P:Emgu.CV.IntrinsicCameraParameters.DistortionCoeffs">
            <summary>
            Get or Set the DistortionCoeffs ( as a 5x1 (default) or 4x1 matrix ). 
            The ordering of the distortion coefficients is the following:
            (k1, k2, p1, p2[, k3]).
            That is, the first 2 radial distortion coefficients are followed by 2 tangential distortion coefficients and then, optionally, by the third radial distortion coefficients. Such ordering is used to keep backward compatibility with previous versions of OpenCV
            </summary>
        </member>
        <member name="P:Emgu.CV.IntrinsicCameraParameters.IntrinsicMatrix">
            <summary>
            Get or Set the intrinsic matrix (3x3)
            </summary>
        </member>
        <member name="T:Emgu.CV.Quaternions">
            <summary>
            A unit quaternions that defines rotation in 3D
            </summary>
        </member>
        <member name="M:Emgu.CV.Quaternions.SetEuler(System.Double,System.Double,System.Double)">
            <summary>
            Set the value of the quaternions using euler angle
            </summary>
            <param name="x">Rotation around x-axis (roll) in radian</param>
            <param name="y">Rotation around y-axis (pitch) in radian</param>
            <param name="z">rotation around z-axis (yaw) in radian</param>
        </member>
        <member name="M:Emgu.CV.Quaternions.GetEuler(System.Double@,System.Double@,System.Double@)">
            <summary>
            Get the equaivalent euler angle
            </summary>
            <param name="x">Rotation around x-axis (roll) in radian</param>
            <param name="y">Rotation around y-axis (pitch) in radian</param>
            <param name="z">rotation around z-axis (yaw) in radian</param>
        </member>
        <member name="M:Emgu.CV.Quaternions.GetRotationMatrix(Emgu.CV.Matrix{System.Double})">
            <summary>
            Fill the (3x3) rotation matrix with the value such that it represent the quaternions
            </summary>
            <param name="rotation">The (3x3) rotation matrix which values will be set to represent this quaternions</param>
        </member>
        <member name="M:Emgu.CV.Quaternions.RotatePoints(Emgu.CV.Matrix{System.Double},Emgu.CV.Matrix{System.Double})">
            <summary>
            Rotate the points in <paramref name="pointsSrc"/> and save the result in <paramref name="pointsDst"/>. Inplace operation is supported (<paramref name="pointsSrc"/> == <paramref name="pointsDst"/>).
            </summary>
            <param name="pointsSrc">The points to be rotated</param>
            <param name="pointsDst">The result of the rotation, should be the same size as <paramref name="pointsSrc"/>, can be <paramref name="pointSrc"/> as well for inplace rotation</param>
        </member>
        <member name="M:Emgu.CV.Quaternions.RotatePoint(Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Rotate the specific point and return the result
            </summary>
            <param name="point">The point to be rotated</param>
            <returns>The rotated point</returns>
        </member>
        <member name="M:Emgu.CV.Quaternions.Multiply(Emgu.CV.Quaternions)">
            <summary>
            Multiply the current Quaternions with <paramref name="quaternionsOther"/> 
            </summary>
            <param name="quaternionsOther">The other rotation</param>
            <return>A composition of the two rotations</return>
        </member>
        <member name="M:Emgu.CV.Quaternions.op_Multiply(Emgu.CV.Quaternions,Emgu.CV.Quaternions)">
            <summary>
            Computes the multiplication of two quaternions
            </summary>
            <param name="q1">The quaternions to be multiplied</param>
            <param name="q2">The quaternions to be multiplied</param>
            <returns>The multiplication of two quaternions</returns>
        </member>
        <member name="M:Emgu.CV.Quaternions.Equals(Emgu.CV.Quaternions)">
            <summary>
            Check if this quaternions equals to <paramref name="other"/>
            </summary>
            <param name="other">The quaternions to be compared</param>
            <returns>True if two quaternions equals, false otherwise</returns>
        </member>
        <member name="P:Emgu.CV.Quaternions.W">
            <summary>
            The W component of the quaternion.
            </summary>
        </member>
        <member name="P:Emgu.CV.Quaternions.X">
            <summary>
            The X component of the quaternion.
            </summary>
        </member>
        <member name="P:Emgu.CV.Quaternions.Y">
            <summary>
            The Y component of the quaternion.
            </summary>
        </member>
        <member name="P:Emgu.CV.Quaternions.Z">
            <summary>
            The Z component of the quaternion.
            </summary>
        </member>
        <member name="P:Emgu.CV.Quaternions.AxisAngle">
            <summary>
            Get or Set the equaivalent axis angle representation. (x,y,z) is the rotatation axis and |(x,y,z)| is the rotation angle in radians
            </summary>
        </member>
        <member name="P:Emgu.CV.Quaternions.RotationAxis">
            <summary>
            Get or Set the unit rotation axis of the quaternion
            </summary>
        </member>
        <member name="P:Emgu.CV.Quaternions.RotationAngle">
            <summary>
            Get or Set the rotation angle in radian
            </summary>
        </member>
        <member name="T:Emgu.CV.RotationMatrix2D`1">
             <summary>
             A (2x3) 2D rotation matrix. This Matrix defines an Affine Transform
             </summary>
            <typeparam name="T">The depth of the rotation matrix, should be float / double</typeparam>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize 2D rotation matrix
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D`1.#ctor">
            <summary>
            Create an empty (2x3) 2D rotation matrix
            </summary>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D`1.#ctor(System.Drawing.PointF,System.Double,System.Double)">
            <summary>
            Create a (2x3) 2D rotation matrix
            </summary>
            <param name="center">Center of the rotation in the source image</param>
            <param name="angle">The rotation angle in degrees. Positive values mean couter-clockwise rotation (the coordiate origin is assumed at top-left corner). </param>
            <param name="scale">Isotropic scale factor.</param>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D`1.SetRotation(System.Drawing.PointF,System.Double,System.Double)">
            <summary>
            Set the values of the rotation matrix
            </summary>
            <param name="center">Center of the rotation in the source image</param>
            <param name="angle">The rotation angle in degrees. Positive values mean couter-clockwise rotation (the coordiate origin is assumed at top-left corner). </param>
            <param name="scale">Isotropic scale factor.</param>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D`1.RotatePoints(Emgu.CV.Structure.MCvPoint2D64f[])">
            <summary>
            Rotate the <paramref name="points"/>, the value of the input <paramref name="points"/> will be changed.
            </summary>
            <param name="points">The points to be rotated, its value will be modified</param>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D`1.RotatePoints(System.Drawing.PointF[])">
            <summary>
            Rotate the <paramref name="points"/>, the value of the input <paramref name="points"/> will be changed.
            </summary>
            <param name="points">The points to be rotated, its value will be modified</param>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D`1.RotateLines(Emgu.CV.Structure.LineSegment2DF[])">
            <summary>
            Rotate the <paramref name="lineSegments"/>, the value of the input <paramref name="lineSegments"/> will be changed.
            </summary>
            <param name="lineSegments">The line segments to be rotated</param>
        </member>
        <member name="M:Emgu.CV.RotationMatrix2D`1.RotatePoints``1(Emgu.CV.Matrix{``0})">
            <summary>
            Rotate the single channel Nx2 matrix where N is the number of 2D points. The value of the matrix is changed after rotation.
            </summary>
            <typeparam name="TDepth">The depth of the points, must be fouble or float</typeparam>
            <param name="points">The N 2D-points to be rotated</param>
        </member>
        <member name="T:Emgu.CV.RotationVector3D">
            <summary>
            A (3x1) Rodrigues rotation vector. Rotation vector is a compact representation of rotation matrix. Direction of the rotation vector is the rotation axis and the length of the vector is the rotation angle around the axis. 
            </summary>
        </member>
        <member name="M:Emgu.CV.RotationVector3D.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize 3D rotation vector
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.RotationVector3D.#ctor">
            <summary>
            Create a 3D rotation vector (3x1 Matrix).
            </summary>
        </member>
        <member name="M:Emgu.CV.RotationVector3D.#ctor(System.Double[])">
            <summary>
            Create a rotation vector using the specific values
            </summary>
            <param name="value">The values of the (3 x 1) Rodrigues rotation vector</param>
        </member>
        <member name="P:Emgu.CV.RotationVector3D.RotationMatrix">
            <summary>
            Get or Set the (3x3) rotation matrix represented by this rotation vector.
            </summary>
        </member>
        <member name="T:Emgu.CV.Capture">
            <summary> 
            Capture images from either camera or video file. 
            </summary>
        </member>
        <member name="T:Emgu.CV.IDuplexCapture">
            <summary>
            The interface to request a duplex image capture
            </summary>
        </member>
        <member name="M:Emgu.CV.IDuplexCapture.DuplexQueryFrame">
            <summary>
            Request a frame from server
            </summary>
        </member>
        <member name="M:Emgu.CV.IDuplexCapture.DuplexQuerySmallFrame">
            <summary>
            Request a frame from server which is half width and half height
            </summary>
        </member>
        <member name="T:Emgu.CV.ICapture">
            <summary> The interface that is used for WCF to provide a image capture service</summary>
        </member>
        <member name="M:Emgu.CV.ICapture.QueryFrame">
            <summary> Capture a Bgr image frame </summary>
            <returns> A Bgr image frame</returns>
        </member>
        <member name="M:Emgu.CV.ICapture.QuerySmallFrame">
            <summary> Capture a Bgr image frame that is half width and half heigh</summary>
            <returns> A Bgr image frame that is half width and half height</returns>
        </member>
        <member name="F:Emgu.CV.Capture._flipType">
            <summary>
            the type of flipping
            </summary>
        </member>
        <member name="M:Emgu.CV.Capture.#ctor">
            <summary> Create a capture using the default camera </summary>
        </member>
        <member name="M:Emgu.CV.Capture.#ctor(System.Int32)">
            <summary> Create a capture using the specific camera</summary>
            <param name="camIndex"> The index of the camera to create capture from, starting from 0</param>
        </member>
        <member name="M:Emgu.CV.Capture.#ctor(System.String)">
            <summary>
            Create a capture from file or a video stream
            </summary>
            <param name="fileName">The name of a file, or an url pointed to a stream.</param>
        </member>
        <member name="M:Emgu.CV.Capture.DisposeObject">
            <summary>
            Release the resource for this capture
            </summary>
        </member>
        <member name="M:Emgu.CV.Capture.GetCaptureProperty(Emgu.CV.CvEnum.CAP_PROP)">
            <summary>
            Obtain the capture property
            </summary>
            <param name="index">The index for the property</param>
            <returns>The value of the specific property</returns>
        </member>
        <member name="M:Emgu.CV.Capture.SetCaptureProperty(Emgu.CV.CvEnum.CAP_PROP,System.Double)">
            <summary>
            Sets the specified property of video capturing
            </summary>
            <param name="property">Property identifier</param>
            <param name="value">Value of the property</param>
        </member>
        <member name="M:Emgu.CV.Capture.QueryGrayFrame">
            <summary> 
            Capture a Gray image frame
            </summary>
            <returns> A Gray image frame</returns>
        </member>
        <member name="M:Emgu.CV.Capture.QueryFrame">
            <summary> 
            Capture a Bgr image frame
            </summary>
            <returns> A Bgr image frame</returns>
        </member>
        <member name="M:Emgu.CV.Capture.QuerySmallFrame">
            <summary> 
             Capture a Bgr image frame that is half width and half height. 
             Mainly used by WCF when sending image to remote locations in a band width conservertive senario
            </summary>
            <remarks>Internally, this is a cvQueryFrame operation follow by a cvPyrDown</remarks>
            <returns> A Bgr image frame that is half width and half height</returns>
        </member>
        <member name="M:Emgu.CV.Capture.DuplexQueryFrame">
            <summary>
            Query a frame duplexly over WCF
            </summary>
        </member>
        <member name="M:Emgu.CV.Capture.DuplexQuerySmallFrame">
            <summary>
            Query a small frame duplexly over WCF
            </summary>
        </member>
        <member name="P:Emgu.CV.Capture.FlipType">
            <summary>
            Get and set the flip type
            </summary>
        </member>
        <member name="P:Emgu.CV.Capture.FlipHorizontal">
            <summary>
            Get or Set if the captured image should be flipped horizontally
            </summary>
        </member>
        <member name="P:Emgu.CV.Capture.FlipVertical">
            <summary>
            Get or Set if the captured image should be flipped vertically
            </summary>
        </member>
        <member name="P:Emgu.CV.Capture.Width">
            <summary> The width of this capture</summary>
        </member>
        <member name="P:Emgu.CV.Capture.Height">
            <summary> The height of this capture </summary>
        </member>
        <member name="T:Emgu.CV.IDuplexCaptureCallback">
            <summary>
            The interface for DuplexCaptureCallback
            </summary>
        </member>
        <member name="M:Emgu.CV.IDuplexCaptureCallback.ReceiveFrame(Emgu.CV.Image{Emgu.CV.Structure.Bgr,System.Byte})">
            <summary>
            Function to call when an image is received
            </summary>
            <param name="img">The image received</param>
        </member>
        <member name="T:Emgu.CV.Structure.Bgr">
            <summary> 
            Defines a Bgr (Blue Green Red) color
            </summary>
        </member>
        <member name="T:Emgu.CV.IColor">
            <summary>
             A color type
            </summary>
        </member>
        <member name="P:Emgu.CV.IColor.MCvScalar">
            <summary>
            The equivalent MCvScalar value
            </summary>
        </member>
        <member name="P:Emgu.CV.IColor.Dimension">
            <summary>
            Get the dimension of the color type
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Bgr._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a BGR color using the specific values</summary>
            <param name="blue"> The blue value for this color </param>
            <param name="green"> The green value for this color </param>
            <param name="red"> The red value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr.#ctor(System.Drawing.Color)">
            <summary>
            Create a Bgr color using the System.Drawing.Color
            </summary>
            <param name="winColor">System.Drawing.Color</param>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr.Equals(Emgu.CV.Structure.Bgr)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Bgr.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr.Blue">
            <summary> Get or set the intensity of the blue color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr.Green">
            <summary> Get or set the intensity of the green color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr.Red">
            <summary> Get or set the intensity of the red color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgr.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Bgra">
            <summary> 
            Defines a Bgra (Blue Green Red Alpha) color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Bgra._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Bgra.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary> Create a BGRA color using the specific values</summary>
            <param name="blue"> The blue value for this color </param>
            <param name="green"> The green value for this color </param>
            <param name="red"> The red value for this color </param>
            <param name="alpha"> The alpha value for this color</param>
        </member>
        <member name="M:Emgu.CV.Structure.Bgra.Equals(Emgu.CV.Structure.Bgra)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Bgra.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Bgra.Blue">
            <summary> Get or set the intensity of the blue color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgra.Green">
            <summary> Get or set the intensity of the green color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgra.Red">
            <summary> Get or set the intensity of the red color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgra.Alpha">
            <summary> Get or set the intensity of the alpha color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgra.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Bgra.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.ColorInfoAttribute">
            <summary>
            Attribute used to specify color information
            </summary>
        </member>
        <member name="F:Emgu.CV.ColorInfoAttribute._conversionCodename">
            <summary>
            The code which is used for color conversion
            </summary>
        </member>
        <member name="M:Emgu.CV.ColorInfoAttribute.#ctor">
            <summary>
            The code which is used for color conversion
            </summary>
        </member>
        <member name="P:Emgu.CV.ColorInfoAttribute.ConversionCodename">
            <summary>
            The code which is used for color conversion
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Gray">
            <summary> Defines a Gray color </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Gray._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Gray.#ctor(System.Double)">
            <summary> Create a Gray color with the given intensity</summary>
            <param name="intensity"> The intensity for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Gray.GetHashCode">
            <summary>
            Returns the hash code for this color
            </summary>
            <returns>the hash code</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Gray.Equals(Emgu.CV.Structure.Gray)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Gray.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Gray.Intensity">
            <summary> The intensity of the gray color </summary>
            <value> The intensity of the gray color</value>
        </member>
        <member name="P:Emgu.CV.Structure.Gray.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Gray.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Hls">
            <summary> 
            Defines a Hls (Hue Lightness Satuation) color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Hls._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Hls.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a Hls color using the specific values</summary>
            <param name="hue"> The hue value for this color ( 0 &lt; hue &lt; 180 )  </param>
            <param name="satuation"> The satuation for this color </param>
            <param name="lightness"> The lightness for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Hls.Equals(Emgu.CV.Structure.Hls)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Hls.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Hls.Hue">
            <summary> Get or set the intensity of the hue color channel ( 0 &lt; hue &lt; 180 ) </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hls.Lightness">
            <summary> Get or set the intensity of the lightness color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hls.Satuation">
            <summary> Get or set the intensity of the satuation color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hls.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hls.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Hsv">
            <summary> 
            Defines a HSV (Hue Satuation Value) color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Hsv._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Hsv.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a HSV color using the specific values</summary>
            <param name="hue"> The hue value for this color ( 0 &lt; hue &lt; 180 )  </param>
            <param name="satuation"> The satuation value for this color </param>
            <param name="value"> The value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Hsv.Equals(Emgu.CV.Structure.Hsv)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Hsv.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Hsv.Hue">
            <summary> Get or set the intensity of the hue color channel ( 0 &lt; hue &lt; 180 ) </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hsv.Satuation">
            <summary> Get or set the intensity of the satuation color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hsv.Value">
            <summary> Get or set the intensity of the value color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hsv.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Hsv.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Lab">
            <summary> 
            Defines a CIE Lab color 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Lab._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Lab.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a CIE Lab color using the specific values</summary>
            <param name="z"> The z value for this color </param>
            <param name="y"> The y value for this color </param>
            <param name="x"> The x value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Lab.Equals(Emgu.CV.Structure.Lab)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Lab.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Lab.X">
            <summary> Get or set the intensity of the x color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Lab.Y">
            <summary> Get or set the intensity of the y color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Lab.Z">
            <summary> Get or set the intensity of the z color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Lab.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Lab.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Luv">
            <summary> 
            Defines a CIE Luv color 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Luv._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Luv.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a CIE Lab color using the specific values</summary>
            <param name="z"> The z value for this color </param>
            <param name="y"> The y value for this color </param>
            <param name="x"> The x value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Luv.Equals(Emgu.CV.Structure.Luv)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Luv.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Luv.X">
            <summary> The intensity of the x color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Luv.Y">
            <summary> The intensity of the y color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Luv.Z">
            <summary> The intensity of the z color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Luv.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Luv.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Xyz">
            <summary> 
            Defines a Xyz color (CIE XYZ.Rec 709 with D65 white point)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Xyz._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Xyz.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a Xyz color using the specific values</summary>
            <param name="z"> The z value for this color </param>
            <param name="y"> The y value for this color </param>
            <param name="x"> The x value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Xyz.Equals(Emgu.CV.Structure.Xyz)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Xyz.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Xyz.X">
            <summary> Get or set the intensity of the z color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Xyz.Y">
            <summary> Get or set the intensity of the y color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Xyz.Z">
            <summary> Get or set the intensity of the x color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Xyz.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Xyz.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Ycc">
            <summary> 
            Defines a Ycc color (YCrCb JPEG)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Ycc._scalar">
            <summary>
            The MCvScalar representation of the color intensity
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Ycc.#ctor(System.Double,System.Double,System.Double)">
            <summary> Create a Ycc color using the specific values</summary>
            <param name="y"> The Y value for this color </param>
            <param name="cr"> The Cr value for this color </param>
            <param name="cb"> The Cb value for this color </param>
        </member>
        <member name="M:Emgu.CV.Structure.Ycc.Equals(Emgu.CV.Structure.Ycc)">
            <summary>
            Return true if the two color equals
            </summary>
            <param name="other">The other color to compare with</param>
            <returns>true if the two color equals</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Ycc.ToString">
            <summary>
            Represent this color as a String
            </summary>
            <returns>The string representation of this color</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Ycc.Y">
            <summary> Get or set the intensity of the Y color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Ycc.Cr">
            <summary> Get or set the intensity of the Cr color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Ycc.Cb">
            <summary> Get or set the intensity of the Cb color channel </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Ycc.Dimension">
            <summary>
            Get the dimension of this color
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Ycc.MCvScalar">
            <summary>
            Get or Set the equivalent MCvScalar value
            </summary>
        </member>
        <member name="T:Emgu.CV.Contour`1">
            <summary>
            Wrapped class for Contour
            </summary>
            <typeparam name="T">The type of elements in the Contour, either PointF or Point.</typeparam>
        </member>
        <member name="T:Emgu.CV.Seq`1">
            <summary>
             Wrapper to cvSeq of OpenCV. 
            </summary>
            <typeparam name="T">The type of elements in this sequence, must be a structure</typeparam>
        </member>
        <member name="F:Emgu.CV.Seq`1._ptr">
            <summary>
            The pointer to this sequence
            </summary>
        </member>
        <member name="F:Emgu.CV.Seq`1._stor">
            <summary>
            The pointer to the storage used by this sequence
            </summary>
        </member>
        <member name="F:Emgu.CV.Seq`1._sizeOfElement">
            <summary>
            The size of the elements in theis sequence
            </summary>
        </member>
        <member name="M:Emgu.CV.Seq`1.#ctor(System.Int32,Emgu.CV.MemStorage)">
            <summary>
            Create a sequence using the specific <paramref name="seqFlag"/> and <paramref name="storage"/>
            </summary>
            <param name="seqFlag">Flags of the created sequence. If the sequence is not passed to any function working with a specific type of sequences, the sequence value may be set to 0, otherwise the appropriate type must be selected from the list of predefined sequence types</param>
            <param name="storage">the storage</param>
        </member>
        <member name="M:Emgu.CV.Seq`1.#ctor(Emgu.CV.CvEnum.SEQ_ELTYPE,Emgu.CV.CvEnum.SEQ_KIND,Emgu.CV.CvEnum.SEQ_FLAG,Emgu.CV.MemStorage)">
            <summary>
            Create a contour of the specific kind, type and flag
            </summary>
            <param name="kind">The kind of the sequence</param>
            <param name="eltype">The type of the sequence</param>
            <param name="flag">The flag of the sequence</param>
            <param name="stor">The storage</param>
        </member>
        <member name="M:Emgu.CV.Seq`1.#ctor(Emgu.CV.MemStorage)">
            <summary>
            Create a sequence using the specific <paramref name="storage"/>
            </summary>
            <param name="storage">the storage</param>
        </member>
        <member name="M:Emgu.CV.Seq`1.FixElementType(System.Int32)">
            <summary>
            Fix the input element type and return the correct one
            </summary>
            <param name="seqType">The input sequence type</param>
            <returns>The best element type that match this sequence</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.#ctor(System.IntPtr,Emgu.CV.MemStorage)">
            <summary>
            Create a sequence from the unmanaged pointer and the storage used by the pointer
            </summary>
            <param name="seq">The unmanaged sequence</param>
            <param name="storage">The memory storage this sequence utilize</param>
        </member>
        <member name="M:Emgu.CV.Seq`1.Push(`0)">
            <summary>
            Push the data to the sequence
            </summary>
            <param name="data">The data to be pushed into the sequence</param>
        </member>
        <member name="M:Emgu.CV.Seq`1.PushFront(`0)">
            <summary>
            Push the data to the sequence
            </summary>
            <param name="data">The data to be pushed into the sequence</param>
        </member>
        <member name="M:Emgu.CV.Seq`1.PushMulti(`0[],Emgu.CV.CvEnum.BACK_OR_FRONT)">
            <summary>
            Push multiple elements to the sequence
            </summary>
            <param name="data">The data to push to the sequence</param>
            <param name="backOrFront">Specify if pushing to the back or front</param>
        </member>
        <member name="M:Emgu.CV.Seq`1.Pop">
            <summary>
            Pop an element from the back of the sequence 
            </summary>
            <returns>An element from the back of the sequence</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.PopFront">
            <summary>
            Pop an element from the front of the sequence 
            </summary>
            <returns>An element from the front of the sequence</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.PopMulti(System.Int32,Emgu.CV.CvEnum.BACK_OR_FRONT)">
            <summary>
            Pop multiple elements from the sequence
            </summary>
            <param name="count">The number of elements to be poped</param>
            <param name="backOrFront">The location the pop operation is started</param>
            <returns>The elements poped from the sequence</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.RemoveAt(System.Int32)">
            <summary>
            Removes element from sequence middle
            </summary>
            <param name="index">Index of removed element</param>
        </member>
        <member name="M:Emgu.CV.Seq`1.Insert(System.Int32,`0)">
            <summary>
            Inserts element in sequence middle
            </summary>
            <param name="index">Index before which the element is inserted. Inserting before 0 (the minimal allowed value of the parameter) is equal to cvSeqPushFront and inserting before seq->total (the maximal allowed value of the parameter) is equal to cvSeqPush</param>
            <param name="data">Inserted element</param>
        </member>
        <member name="M:Emgu.CV.Seq`1.GetMinAreaRect">
            <summary>
            Get the minimum area rectangle for this point sequence
            </summary>
            <returns>The minimum area rectangle</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.GetMinAreaRect(Emgu.CV.MemStorage)">
            <summary>
            Get the minimum area rectangle for this point sequence
            </summary>
            <param name="stor">The temporary storage to use</param>
            <returns>The minimum area rectangle</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.GetConvexHull(Emgu.CV.CvEnum.ORIENTATION,Emgu.CV.MemStorage)">
            <summary>
            Get the convex hull of this point sequence
            </summary>
            <param name="orientation">The orientation of the convex hull</param>
            <param name="stor">The storage for the resulting sequence</param>
            <returns>The result convex hull</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.GetConvexHull(Emgu.CV.CvEnum.ORIENTATION)">
            <summary>
            Get the convex hull of this point sequence, the resulting convex hull use the same storage as the current sequence
            </summary>
            <param name="orientation">The orientation of the convex hull</param>
            <returns>The result convex hull</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.ToArray">
            <summary>
            Convert this sequence to array
            </summary>
            <returns>the array representation of this sequence</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.GetEnumerator">
            <summary>
            return an enumerator of the elements in the sequence
            </summary>
            <returns>an enumerator of the elements in the sequence</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            return an enumerator of the elements in the sequence
            </summary>
            <returns>an enumerator of the elements in the sequence</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.Slice(Emgu.CV.Structure.MCvSlice,Emgu.CV.MemStorage,System.Boolean)">
            <summary>
            Creates a sequence that represents the specified slice of the input sequence. The new sequence either shares the elements with the original sequence or has own copy of the elements. So if one needs to process a part of sequence but the processing function does not have a slice parameter, the required sub-sequence may be extracted using this function
            </summary>
            <param name="slice">The part of the sequence to extract</param>
            <param name="storage">The destination storage to keep the new sequence header and the copied data if any. If it is NULL, the function uses the storage containing the input sequence.</param>
            <param name="copy_data">The flag that indicates whether to copy the elements of the extracted slice </param>
            <returns>A sequence that represents the specified slice of the input sequence</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.ApproxPoly(System.Double,Emgu.CV.MemStorage)">
            <summary>
            Approximates one curves and returns the approximation result
            </summary>
            <param name="accuracy">The desired approximation accuracy</param>
            <param name="storage"> The storage used by the resulting sequence. If null, the storage of this sequence is used.</param>
            <returns>The approximated contour</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.ApproxPoly(System.Double,System.Int32,Emgu.CV.MemStorage)">
            <summary>
            Approximates one or more curves and returns the approximation result[s]. In case of multiple curves approximation the resultant tree will have the same structure as the input one (1:1 correspondence)
            </summary>
            <param name="accuracy">The desired approximation accuracy</param>
            <param name="storage"> The storage used by the resulting sequence. If null, the storage of this sequence is used.</param>
            <param name="maxLevel">
            Maximal level for sequence approximation. 
            If 0, only sequence is arrpoximated. 
            If 1, the sequence and all sequence after it on the same level are approximated. 
            If 2, all sequence after and all sequence one level below the contours are approximated, etc. If the value is negative, the function does not approximate the sequence following after contour but draws child sequences of sequence up to abs(maxLevel)-1 level
            </param>
            <returns>The approximated contour</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.ApproxPoly(System.Double)">
            <summary>
            Approximates one curve and returns the approximation result, the result use the same storage as the current sequence
            </summary>
            <param name="accuracy">The desired approximation accuracy</param>
            <returns>The approximated contour</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.Clear">
            <summary>
            Removes all elements from the sequence. The function does not return the memory to the storage, but this memory is reused later when new elements are added to the sequence. This function time complexity is O(1). 
            </summary>
        </member>
        <member name="M:Emgu.CV.Seq`1.InContour(System.Drawing.PointF)">
            <summary>
            Determines whether the point is inside contour, outside, or lies on an edge (or coinsides with a vertex)
            </summary>
            <param name="point">The point to be tested</param>
            <returns>positive if inside; negative if out side; 0 if on the contour</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.Distance(System.Drawing.PointF)">
            <summary>
            Determines the distance from the point to the contour
            </summary>
            <param name="point">The point to measured distance</param>
            <returns>positive distance if inside; negative distance if outside; 0 if on the contour</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.GetMoments">
            <summary>
            Get the moments for this point sequence
            </summary>
            <returns>the moments for this point sequence</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.MatchShapes(Emgu.CV.Seq{`0},Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE)">
            <summary>
            Compare the shape of the current contour with <paramref name="objectToMatch"/> 
            </summary>
            <param name="objectToMatch">The object to match</param>
            <param name="method">contour matching method</param>
            <returns>The degree of the similarity</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.GetConvexityDefacts(Emgu.CV.MemStorage,Emgu.CV.CvEnum.ORIENTATION)">
            <summary>
            Finds all convexity defects of the input contour and returns a sequence of the CvConvexityDefect structures. 
            </summary>
            <param name="storage">Container for output sequence of convexity defects. If it is NULL, contour or hull (in that order) storage is used.</param>
            <param name="orientation">Orientation where the convexity Defacts is returned.</param>
            <returns>The sequence of the CvConvexityDefect structures.</returns>
        </member>
        <member name="M:Emgu.CV.Seq`1.op_Implicit(Emgu.CV.Seq{`0})~System.IntPtr">
            <summary>
            Implicit operator for IntPtr
            </summary>
            <param name="sequence">The sequence</param>
            <returns>The unmanaged pointer for this object</returns>
        </member>
        <member name="P:Emgu.CV.Seq`1.Ptr">
            <summary>
            Get the pointer of this sequence
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.ElementType">
            <summary>
            Get or Set the element Type
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.Storage">
            <summary>
            A Pointer to the storage used by this Seq
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.MCvSeq">
            <summary>
            Get the MCvSeq structure
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.Item(System.Int32)">
            <summary>
            Obtain the <paramref name="index"/> element in this sequence
            </summary>
            <param name="index">the index of the element</param>
            <returns>the <paramref name="index"/> element in this sequence</returns>
        </member>
        <member name="P:Emgu.CV.Seq`1.HNext">
            <summary>
            Same as h_next pointer in CvSeq
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.HPrev">
            <summary>
            Same as h_prev pointer in CvSeq
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.VNext">
            <summary>
            Same as v_next pointer in CvSeq
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.VPrev">
            <summary>
            Same as v_prev pointer in CvSeq
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.Total">
            <summary> Get the number of eelments in the sequence</summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.Area">
            <summary> 
             Get the area of the contour 
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.Convex">
            <summary> 
             Indicate if the coutour is a convex one 
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.Perimeter">
            <summary> 
             The perimeter of the sequence 
            </summary>
        </member>
        <member name="P:Emgu.CV.Seq`1.BoundingRectangle">
            <summary> Get the smallest bouding rectangle </summary>
        </member>
        <member name="M:Emgu.CV.Contour`1.#ctor(System.IntPtr,Emgu.CV.MemStorage)">
            <summary>
            Craete a contour from the specific IntPtr and storage
            </summary>
            <param name="ptr">The unmanged Pointer to the sequence</param>
            <param name="storage">The storage used by this contour</param>
        </member>
        <member name="M:Emgu.CV.Contour`1.#ctor(System.Int32,Emgu.CV.MemStorage)">
            <summary>
            Create a contour using the specific <paramref name="seqFlag"/> and <paramref name="storage"/>
            </summary>
            <param name="seqFlag">Flags of the created contour. If the contour is not passed to any function working with a specific type of sequences, the sequence value may be set to 0, otherwise the appropriate type must be selected from the list of predefined contour types</param>
            <param name="storage">The storage</param>
        </member>
        <member name="M:Emgu.CV.Contour`1.#ctor(Emgu.CV.CvEnum.SEQ_ELTYPE,Emgu.CV.CvEnum.SEQ_KIND,Emgu.CV.CvEnum.SEQ_FLAG,Emgu.CV.MemStorage)">
            <summary>
            Create a contour of the specific kind, type and flag
            </summary>
            <param name="kind">The kind of the sequence</param>
            <param name="eltype">The type of the sequence</param>
            <param name="flag">The flag of the sequence</param>
            <param name="stor">The storage</param>
        </member>
        <member name="M:Emgu.CV.Contour`1.#ctor(Emgu.CV.MemStorage)">
            <summary>
            Create a contour using the specific <paramref name="storage"/>
            </summary>
            <param name="storage">The storage to be used</param>
        </member>
        <member name="M:Emgu.CV.Contour`1.InContour(System.Drawing.PointF)">
            <summary>
            Determines whether the point is inside contour, outside, or lies on an edge (or coinsides with a vertex)
            </summary>
            <param name="point">The point to be tested</param>
            <returns>positive if inside; negative if out side; 0 if on the contour</returns>
            <remarks>requires MCvContour.rect to be pre-computed</remarks>
        </member>
        <member name="M:Emgu.CV.Contour`1.ApproxPoly(System.Double,Emgu.CV.MemStorage)">
            <summary>
            Approximates one curves and returns the approximation result. 
            </summary>
            <param name="accuracy">The desired approximation accuracy</param>
            <param name="storage"> The storage the resulting sequence use</param>
            <returns>The approximated contour</returns>
        </member>
        <member name="M:Emgu.CV.Contour`1.ApproxPoly(System.Double,System.Int32,Emgu.CV.MemStorage)">
            <summary>
            Approximates one or more curves and returns the approximation result[s]. In case of multiple curves approximation the resultant tree will have the same structure as the input one (1:1 correspondence)
            </summary>
            <param name="accuracy">The desired approximation accuracy</param>
            <param name="storage"> The storage the resulting sequence use</param>
            <param name="maxLevel">
            Maximal level for contour approximation. 
            If 0, only contour is arrpoximated. 
            If 1, the contour and all contours after it on the same level are approximated. 
            If 2, all contours after and all contours one level below the contours are approximated, etc. If the value is negative, the function does not draw the contours following after contour but draws child contours of contour up to abs(maxLevel)-1 level
            </param>
            <returns>The approximated contour</returns>
        </member>
        <member name="M:Emgu.CV.Contour`1.ApproxPoly(System.Double)">
            <summary>
            Approximates one or more curves and returns the approximation result[s]. In case of multiple curves approximation the resultant tree will have the same structure as the input one (1:1 correspondence)
            </summary>
            <param name="accuracy">The desired approximation accuracy</param>
            <returns>The approximated contour</returns>
        </member>
        <member name="P:Emgu.CV.Contour`1.BoundingRectangle">
            <summary> Get the smallest bouding rectangle </summary>
            <remarks>Requires MCvContour.rect to be pre-computed</remarks>
        </member>
        <member name="P:Emgu.CV.Contour`1.MCvContour">
            <summary>
            Return the MCvContour structure
            </summary>
        </member>
        <member name="P:Emgu.CV.Contour`1.HNext">
            <summary>
            Same as h_next pointer in CvSeq
            </summary>
        </member>
        <member name="P:Emgu.CV.Contour`1.HPrev">
            <summary>
            Same as h_prev pointer in CvSeq
            </summary>
        </member>
        <member name="P:Emgu.CV.Contour`1.VNext">
            <summary>
            Same as v_next pointer in CvSeq
            </summary>
        </member>
        <member name="P:Emgu.CV.Contour`1.VPrev">
            <summary>
            Same as v_prev pointer in CvSeq
            </summary>
        </member>
        <member name="T:Emgu.CV.ConvolutionKernelF">
            <summary>
            A convolution kernel 
            </summary>
        </member>
        <member name="F:Emgu.CV.ConvolutionKernelF._center">
            <summary>
            The center of the convolution kernel
            </summary>
        </member>
        <member name="M:Emgu.CV.ConvolutionKernelF.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a convolution kernel with the specific number of <paramref name="rows"/> and <paramref name="cols"/>
            </summary>
            <param name="rows">The number of raws for the convolution kernel</param>
            <param name="cols">The number of columns for the convolution kernel</param>
        </member>
        <member name="M:Emgu.CV.ConvolutionKernelF.#ctor(Emgu.CV.Matrix{System.Single},System.Drawing.Point)">
            <summary>
            Create a convolution kernel using the specific matrix and center
            </summary>
            <param name="kernel">the values for the convolution kernel</param>
            <param name="center">the center of the kernel</param>
        </member>
        <member name="M:Emgu.CV.ConvolutionKernelF.#ctor(System.Single[0:,0:])">
            <summary>
            Create a convolution kernel using the specific floating point matrix
            </summary>
            <param name="kernel">the values for the convolution kernel</param>
        </member>
        <member name="M:Emgu.CV.ConvolutionKernelF.#ctor(System.Single[0:,0:],System.Drawing.Point)">
            <summary>
            Create a convolution kernel using the specific floating point matrix and center
            </summary>
            <param name="kernel">the values for the convolution kernel</param>
            <param name="center">the center for the convolution kernel</param>
        </member>
        <member name="M:Emgu.CV.ConvolutionKernelF.Flip(Emgu.CV.CvEnum.FLIP)">
            <summary> Get a filpped copy of the convolution kernel</summary>
            <param name="flipType">The type of the flipping</param>
            <returns> The flipped copy of <i>this</i> image </returns>
        </member>
        <member name="M:Emgu.CV.ConvolutionKernelF.Transpose">
            <summary>
            Obtain the transpose of the convolution kernel
            </summary>
            <returns>A transposed convolution kernel</returns>
        </member>
        <member name="P:Emgu.CV.ConvolutionKernelF.Center">
            <summary>
            The center of the convolution kernel
            </summary>
        </member>
        <member name="T:Emgu.CV.CvException">
            <summary>
            The default exception to be thrown when error encounter in Open CV 
            </summary>
        </member>
        <member name="M:Emgu.CV.CvException.#ctor(System.Int32,System.String,System.String,System.String,System.Int32)">
            <summary>
            The default exception to be thrown when error is encountered in Open CV 
            </summary>
            <param name="status">The numeric code for error status</param>
            <param name="funcName">The source file name where error is encountered</param>
            <param name="errMsg">A description of the error</param>
            <param name="fileName">The source file name where error is encountered</param>
            <param name="line">The line number in the souce where error is encountered</param>
        </member>
        <member name="P:Emgu.CV.CvException.Status">
            <summary>
            The numeric code for error status
            </summary>
        </member>
        <member name="P:Emgu.CV.CvException.ErrorStr">
            <summary>
            The corresponding error string for the Status code
            </summary>
        </member>
        <member name="P:Emgu.CV.CvException.FunctionName">
            <summary>
            The name of the function the error is encountered
            </summary>
        </member>
        <member name="P:Emgu.CV.CvException.ErrorMessage">
            <summary>
            A description of the error
            </summary>
        </member>
        <member name="P:Emgu.CV.CvException.FileName">
            <summary>
            The source file name where error is encountered
            </summary>
        </member>
        <member name="P:Emgu.CV.CvException.Line">
            <summary>
            The line number in the souce where error is encountered
            </summary>
        </member>
        <member name="T:Emgu.CV.DenseHistogram">
            <summary> 
             A Uniform Multi-dimensional Dense Histogram 
            </summary>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.#ctor(System.Int32,Emgu.CV.Structure.RangeF)">
            <summary>
            Creates a uniform 1-D histogram of the specified size
            </summary>
            <param name="binSize">The number of bins in this 1-D histogram. </param>
            <param name="range">The upper and lower boundary of the bin</param>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.#ctor(System.Int32[],Emgu.CV.Structure.RangeF[])">
            <summary>
            Creates a uniform multi-dimension histogram of the specified size
            </summary>
            <param name="binSizes">The length of this array is the dimension of the histogram. The values of the array contains the number of bins in each dimension. The total number of bins eaquals the multiplication of all numbers in the array</param>
            <param name="ranges">the upper and lower boundaries of the bins</param>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.Clear">
            <summary> 
             Clear this histogram
            </summary>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.Calculate``1(Emgu.CV.Image{Emgu.CV.Structure.Gray,``0}[],System.Boolean,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Project the images to the histogram bins 
            </summary>
            <typeparam name="TDepth">The type of depth of the image</typeparam>
            <param name="imgs">images to project</param>
            <param name="accumulate">If it is true, the histogram is not cleared in the beginning. This feature allows user to compute a single histogram from several images, or to update the histogram online. </param>
            <param name="mask">Can be null if not needed. The operation mask, determines what pixels of the source images are counted</param>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.Calculate``1(Emgu.CV.Matrix{``0}[],System.Boolean,Emgu.CV.Matrix{System.Byte})">
            <summary>
            Project the matrices to the histogram bins 
            </summary>
            <typeparam name="TDepth">The type of depth of the image</typeparam>
            <param name="matrices">Matrices to project</param>
            <param name="accumulate">If it is true, the histogram is not cleared in the beginning. This feature allows user to compute a single histogram from several images, or to update the histogram online. </param>
            <param name="mask">Can be null if not needed. The operation mask, determines what pixels of the source images are counted</param>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.Calculate(Emgu.CV.IImage[],System.Boolean,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Project the images to the histogram bins 
            </summary>
            <param name="imgs">images to project</param>
            <param name="accumulate">If it is true, the histogram is not cleared in the beginning. This feature allows user to compute a single histogram from several images, or to update the histogram online. </param>
            <param name="mask">Can be null if not needed. The operation mask, determines what pixels of the source images are counted</param>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.MinMax(System.Single@,System.Single@,System.Int32[]@,System.Int32[]@)">
            <summary>
            Finds the minimum and maximum histogram bins and their positions
            </summary>
            <remarks>
            Among several extremums with the same value the ones with minimum index (in lexicographical order). 
            In case of several maximums or minimums the earliest in lexicographical order extrema locations are returned.
            </remarks>
            <param name="minValue">Pointer to the minimum value of the histogram </param>
            <param name="maxValue">Pointer to the maximum value of the histogram </param>
            <param name="minLocation">Pointer to the array of coordinates for minimum </param>
            <param name="maxLocation">Pointer to the array of coordinates for maximum </param>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.BackProject``1(Emgu.CV.Image{Emgu.CV.Structure.Gray,``0}[])">
            <summary> 
             Backproject the histogram into a gray scale image
            </summary>
            <param name="srcs">Source images, all are of the same size and type</param>
            <returns>Destination back projection image of the same type as the source images</returns>
            <typeparam name="TDepth">The type of depth of the image</typeparam>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.BackProjectPatch``1(Emgu.CV.Image{Emgu.CV.Structure.Gray,``0}[],System.Drawing.Size,Emgu.CV.CvEnum.HISTOGRAM_COMP_METHOD,System.Double)">
            <summary> 
            Compares histogram over each possible rectangular patch of the specified size in the input images, and stores the results to the output map dst.
            </summary>
            <param name="srcs">Source images, all are of the same size and type</param>
            <param name="factor">Normalization factor for histograms, will affect normalization scale of destination image, pass 1 if unsure. </param>
            <param name="patchSize">Size of patch slid though the source images.</param>
            <param name="method">Comparison method, passed to cvCompareHist.</param>
            <typeparam name="TDepth">The type of depth of the image</typeparam>
            <returns>Destination back projection image of the same type as the source images</returns>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.BackProject``1(Emgu.CV.Matrix{``0}[])">
            <summary> 
             Backproject the histogram into a matrix
            </summary>
            <param name="srcs">Source matrices, all are of the same size and type</param>
            <returns>Destination back projection matrix of the sametype as the source matrices</returns>
            <typeparam name="TDepth">The type of depth of the matrix</typeparam>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.Threshold(System.Double)">
            <summary>
            Clears histogram bins that are below the specified threshold.
            </summary>
            <param name="thresh">The threshold used to clear the bins</param>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.Normalize(System.Double)">
            <summary>
             normalizes the histogram bins by scaling them, such that the sum of the bins becomes equal to factor
            </summary>
            <param name="factor">the sum of the bins after normalization</param>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.Copy(Emgu.CV.DenseHistogram)">
            <summary>
            Copy this histogram to <paramref name="destination"/> 
            </summary>
            <param name="destination">The histogram to copy to</param>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.DisposeObject">
            <summary>
            Release the histogram and all memory associate with it
            </summary>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.ReleaseManagedResources">
            <summary>
            Release the managed resources associated with this dense histogram
            </summary>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serilization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.DenseHistogram.Equals(Emgu.CV.DenseHistogram)">
            <summary>
            Return true if the two DenseHistogram equals
            </summary>
            <param name="other">The other DenseHistogram to compare with</param>
            <returns>True if the two DenseHistogram equals</returns>
        </member>
        <member name="P:Emgu.CV.DenseHistogram.Item(System.Int32)">
            <summary>
            Get the specific bin value from the 1D Histogram
            </summary>
            <param name="index0">The 0th index of the bin</param>
            <returns>The value in the histogram bin</returns>
        </member>
        <member name="P:Emgu.CV.DenseHistogram.Item(System.Int32,System.Int32)">
            <summary>
            Get the specific bin value from the 2D Histogram
            </summary>
            <param name="index0">The 0th index of the bin</param>
            <param name="index1">The 1st index of the bin</param>
            <returns>The value in the histogram bin</returns>
        </member>
        <member name="P:Emgu.CV.DenseHistogram.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            Get the specific bin value from the 2D Histogram
            </summary>
            <param name="index0">The 0th index of the bin</param>
            <param name="index1">The 1st index of the bin</param>
            <param name="index2">The 2nd index of the bin</param>
            <returns>The value in the histogram bin</returns>
        </member>
        <member name="P:Emgu.CV.DenseHistogram.MCvHistogram">
            <summary>
            Get the equivalent MCvHistogram structure 
            </summary>
        </member>
        <member name="P:Emgu.CV.DenseHistogram.Dimension">
            <summary>
            Get the number of dimensions for the histogram
            </summary>
        </member>
        <member name="P:Emgu.CV.DenseHistogram.BinDimension">
            <summary>
            Get the size of the bin dimensions
            </summary>
        </member>
        <member name="P:Emgu.CV.DenseHistogram.MatND">
            <summary>
            Get the MatND representation of this dense histogram. Do not dispose this MatND
            </summary>
        </member>
        <member name="P:Emgu.CV.DenseHistogram.Ranges">
            <summary>
            Get the ranges of this histogram
            </summary>
        </member>
        <member name="T:Emgu.CV.EigenObjectRecognizer">
            <summary>
            An object recognizer using PCA (Principle Components Analysis)
            </summary>
        </member>
        <member name="M:Emgu.CV.EigenObjectRecognizer.#ctor(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte}[],Emgu.CV.Structure.MCvTermCriteria@)">
            <summary>
            Create an object recognizer using the specific tranning data and parameters, it will always return the most similar object
            </summary>
            <param name="images">The images used for training, each of them should be the same size. It's recommended the images are histogram normalized</param>
            <param name="termCrit">The criteria for recognizer training</param>
        </member>
        <member name="M:Emgu.CV.EigenObjectRecognizer.#ctor(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte}[],System.String[],Emgu.CV.Structure.MCvTermCriteria@)">
            <summary>
            Create an object recognizer using the specific tranning data and parameters, it will always return the most similar object
            </summary>
            <param name="images">The images used for training, each of them should be the same size. It's recommended the images are histogram normalized</param>
            <param name="labels">The labels corresponding to the images</param>
            <param name="termCrit">The criteria for recognizer training</param>
        </member>
        <member name="M:Emgu.CV.EigenObjectRecognizer.#ctor(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte}[],System.String[],System.Double,Emgu.CV.Structure.MCvTermCriteria@)">
            <summary>
            Create an object recognizer using the specific tranning data and parameters
            </summary>
            <param name="images">The images used for training, each of them should be the same size. It's recommended the images are histogram normalized</param>
            <param name="labels">The labels corresponding to the images</param>
            <param name="eigenDistanceThreshold">
            The eigen distance threshold, (0, ~1000].
            The smaller the number, the more likely an examined image will be treated as unrecognized object. 
            If the threshold is &lt; 0, the recognizer will always treated the examined image as one of the known object. 
            </param>
            <param name="termCrit">The criteria for recognizer training</param>
        </member>
        <member name="M:Emgu.CV.EigenObjectRecognizer.CalcEigenObjects(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte}[],Emgu.CV.Structure.MCvTermCriteria@,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Single}[]@,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Single}@)">
            <summary>
            Caculate the eigen images for the specific traning image
            </summary>
            <param name="trainingImages">The images used for training </param>
            <param name="termCrit">The criteria for tranning</param>
            <param name="eigenImages">The resulting eigen images</param>
            <param name="avg">The resulting average image</param>
        </member>
        <member name="M:Emgu.CV.EigenObjectRecognizer.EigenDecomposite(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Single}[],Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Single})">
            <summary>
            Decompose the image as eigen values, using the specific eigen vectors
            </summary>
            <param name="src">The image to be decomposed</param>
            <param name="eigenImages">The eigen images</param>
            <param name="avg">The average images</param>
            <returns>Eigen values of the decomposed image</returns>
        </member>
        <member name="M:Emgu.CV.EigenObjectRecognizer.EigenProjection(System.Single[])">
            <summary>
            Given the eigen value, reconstruct the projected image
            </summary>
            <param name="eigenValue">The eigen values</param>
            <returns>The projected image</returns>
        </member>
        <member name="M:Emgu.CV.EigenObjectRecognizer.GetEigenDistances(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Get the Euclidean eigen-distance between <paramref name="image"/> and every other image in the database
            </summary>
            <param name="image">The image to be compared from the training images</param>
            <returns>An array of eigen distance from every image in the training images</returns>
        </member>
        <member name="M:Emgu.CV.EigenObjectRecognizer.FindMostSimilarObject(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},System.Int32@,System.Single@,System.String@)">
            <summary>
            Given the <paramref name="image"/> to be examined, find in the database the most similar object, return the index and the eigen distance
            </summary>
            <param name="image">The image to be searched from the database</param>
            <param name="index">The index of the most similar object</param>
            <param name="eigenDistance">The eigen distance of the most similar object</param>
            <param name="label">The label of the specific image</param>
        </member>
        <member name="M:Emgu.CV.EigenObjectRecognizer.Recognize(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Try to recognize the image and return its label
            </summary>
            <param name="image">The image to be recognized</param>
            <returns>
            String.Empty, if not recognized;
            Label of the corresponding image, otherwise
            </returns>
        </member>
        <member name="P:Emgu.CV.EigenObjectRecognizer.EigenImages">
            <summary>
            Get the eigen vectors that form the eigen space
            </summary>
            <remarks>The set method is primary used for deserialization, do not attemps to set it unless you know what you are doing</remarks>
        </member>
        <member name="P:Emgu.CV.EigenObjectRecognizer.Labels">
            <summary>
            Get or set the labels for the corresponding training image
            </summary>
        </member>
        <member name="P:Emgu.CV.EigenObjectRecognizer.EigenDistanceThreshold">
            <summary>
            Get or set the eigen distance threshold.
            The smaller the number, the more likely an examined image will be treated as unrecognized object. 
            Set it to a huge number (e.g. 5000) and the recognizer will always treated the examined image as one of the known object. 
            </summary>
        </member>
        <member name="P:Emgu.CV.EigenObjectRecognizer.AverageImage">
            <summary>
            Get the average Image. 
            </summary>
            <remarks>The set method is primary used for deserialization, do not attemps to set it unless you know what you are doing</remarks>
        </member>
        <member name="P:Emgu.CV.EigenObjectRecognizer.EigenValues">
            <summary>
            Get the eigen values of each of the training image
            </summary>
            <remarks>The set method is primary used for deserialization, do not attemps to set it unless you know what you are doing</remarks>
        </member>
        <member name="T:Emgu.CV.FeatureTree">
            <summary>
            A wrapper for CvFeatureTree
            </summary>
        </member>
        <member name="M:Emgu.CV.FeatureTree.#ctor(System.Single[][])">
            <summary>
            Create a k-d tree from the specific feature descriptors
            </summary>
            <param name="descriptors">The array of feature descriptors</param>
        </member>
        <member name="M:Emgu.CV.FeatureTree.#ctor(Emgu.CV.Matrix{System.Single})">
            <summary>
            Create a k-d tree from the specific feature descriptors
            </summary>
            <param name="descriptorMatrix">The array of feature descriptors</param>
        </member>
        <member name="M:Emgu.CV.FeatureTree.#ctor(System.Single[][],System.Int32,System.Double,System.Double)">
            <summary>
            Create a spill tree from the specific feature descriptors
            </summary>
            <param name="descriptors">The array of feature descriptors</param>
            <param name="naive">A good value is 50</param>
            <param name="rho">A good value is .7</param>
            <param name="tau">A good value is .1</param>
        </member>
        <member name="M:Emgu.CV.FeatureTree.#ctor(Emgu.CV.Matrix{System.Single},System.Int32,System.Double,System.Double)">
            <summary>
            Create a spill tree from the specific feature descriptors
            </summary>
            <param name="descriptors">The array of feature descriptors</param>
            <param name="naive">A good value is 50</param>
            <param name="rho">A good value is .7</param>
            <param name="tau">A good value is .1</param>
        </member>
        <member name="M:Emgu.CV.FeatureTree.FindFeatures(System.Single[][],Emgu.CV.Matrix{System.Int32}@,Emgu.CV.Matrix{System.Double}@,System.Int32,System.Int32)">
            <summary>
            Finds (with high probability) the k nearest neighbors in tr for each of the given (row-)vectors in desc, using best-bin-first searching ([Beis97]). The complexity of the entire operation is at most O(m*emax*log2(n)), where n is the number of vectors in the tree
            </summary>
            <param name="descriptors">The m feature descriptors to be searched from the feature tree</param>
            <param name="results">
            The results of the best <paramref name="k"/> matched from the feature tree. A m x <paramref name="k"/> matrix. Contains -1 in some columns if fewer than k neighbors found. 
            For each row the k neareast neighbors are not sorted. To findout the closet neighbour, look at the output matrix <paramref name="dist"/>.
            </param>
            <param name="dist">
            A m x <paramref name="k"/> matrix of the distances to k nearest neighbors
            </param>
            <param name="k">The number of neighbors to find</param>
            <param name="emax">For k-d tree only: the maximum number of leaves to visit. Use 20 if not sure</param>
        </member>
        <member name="M:Emgu.CV.FeatureTree.FindFeatures(System.Single[][],Emgu.CV.Matrix{System.Int32},Emgu.CV.Matrix{System.Double},System.Int32,System.Int32)">
            <summary>
            Finds (with high probability) the k nearest neighbors in tree for each of the given (row-)vectors in desc, using best-bin-first searching ([Beis97]). The complexity of the entire operation is at most O(m*emax*log2(n)), where n is the number of vectors in the tree
            </summary>
            <param name="descriptors">The m feature descriptors to be searched from the feature tree</param>
            <param name="results">
            The results of the best <paramref name="k"/> matched from the feature tree. A m x <paramref name="k"/> matrix. Contains -1 in some columns if fewer than k neighbors found. 
            For each row the k neareast neighbors are not sorted. To findout the closet neighbour, look at the output matrix <paramref name="dist"/>.
            </param>
            <param name="dist">
            A m x <paramref name="k"/> matrix of the distances to k nearest neighbors
            </param>
            <param name="k">The number of neighbors to find</param>
            <param name="emax">For k-d tree only: the maximum number of leaves to visit. Use 20 if not sure</param>
        </member>
        <member name="M:Emgu.CV.FeatureTree.DisposeObject">
            <summary>
            Release the unmanaged structure and all the memories associate with it.
            </summary>
        </member>
        <member name="M:Emgu.CV.FeatureTree.ReleaseManagedResources">
            <summary>
            Release the managed resource
            </summary>
        </member>
        <member name="P:Emgu.CV.FeatureTree.DescriptorMatrix">
            <summary>
            Get the descriptor matrix used by this feature tree
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.CenterInitType">
            <summary>
            The Kmeans center initiation types
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.CenterInitType.RANDOM">
            <summary>
            Random
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.CenterInitType.GONZALES">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Flann.CenterInitType.KMEANSPP">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.Flann.Index">
            <summary>
            Flann index
            </summary>
        </member>
        <member name="M:Emgu.CV.Flann.Index.#ctor(Emgu.CV.Matrix{System.Single},System.Int32)">
            <summary>
            Create a flann index using multiple KDTrees
            </summary>
            <param name="numberOfKDTrees">The number of KDTrees to be used</param>
            <param name="values">A row by row matrix of descriptors</param>
        </member>
        <member name="M:Emgu.CV.Flann.Index.#ctor(Emgu.CV.Matrix{System.Single},System.Int32,System.Int32,System.Int32,Emgu.CV.Flann.CenterInitType,System.Single)">
            <summary>
            Create a flann index using a composition of KDTreee and KMeans tree
            </summary>
            <param name="numberOfKDTrees">The number of KDTrees to be used</param>
            <param name="values">A row by row matrix of descriptors</param>
            <param name="branching">Branching factor (for kmeans tree), use 32 for default</param>
            <param name="iterations">Max iterations to perform in one kmeans clustering (kmeans tree), use 11 for deafault</param>
            <param name="centersInitType">Algorithm used for picking the initial cluster centers for kmeans tree, use RANDOM for default</param>
            <param name="cbIndex">Cluster boundary index. Used when searching the kmeans tree. Use 0.2 for default</param>
        </member>
        <member name="M:Emgu.CV.Flann.Index.#ctor(Emgu.CV.Matrix{System.Single},System.Int32,System.Int32,Emgu.CV.Flann.CenterInitType,System.Single)">
            <summary>
            Create a flann index using Kmeans
            </summary>
            <param name="values">A row by row matrix of descriptors</param>
            <param name="branching">Branching factor (for kmeans tree), use 32 for default</param>
            <param name="iterations">Max iterations to perform in one kmeans clustering (kmeans tree), use 11 for deafault</param>
            <param name="centersInitType">Algorithm used for picking the initial cluster centers for kmeans tree, use RANDOM for default</param>
            <param name="cbIndex">Cluster boundary index. Used when searching the kmeans tree. Use 0.2 for default</param>
        </member>
        <member name="M:Emgu.CV.Flann.Index.#ctor(Emgu.CV.Matrix{System.Single})">
            <summary>
            Create a linear flann index
            </summary>
            <param name="values">A row by row matrix of descriptors</param>
        </member>
        <member name="M:Emgu.CV.Flann.Index.#ctor(Emgu.CV.Matrix{System.Single},System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Create an auto-tuned flann index
            </summary>
            <param name="values">A row by row matrix of descriptors</param>
            <param name="targetPrecision">Precision desired, use 0.9 if not sure</param>
            <param name="buildWeight">build tree time weighting factor, use 0.01 if not sure</param>
            <param name="memoryWeight">index memory weighting factor, use 0 if not sure</param>
            <param name="sampleFraction">what fraction of the dataset to use for autotuning, use 0.1 if not sure</param>
        </member>
        <member name="M:Emgu.CV.Flann.Index.KnnSearch(Emgu.CV.Matrix{System.Single},Emgu.CV.Matrix{System.Int32},Emgu.CV.Matrix{System.Single},System.Int32,System.Int32)">
            <summary>
            Perform k-nearest-neighbours (KNN) search
            </summary>
            <param name="queries">A row by row matrix of descriptors to be query for nearest neighbours</param>
            <param name="indices">The result of the indices of the k-nearest neighbours</param>
            <param name="distances">The distance of between the neighbours</param>
            <param name="knn">Number of nearest neighbors to search for</param>
            <param name="checks">The number of times the tree(s) in the index should be recursively traversed. A
            higher value for this parameter would give better search precision, but also take more
            time. If automatic configuration was used when the index was created, the number of
            checks required to achieve the specified precision was also computed, in which case
            this parameter is ignored </param>
        </member>
        <member name="M:Emgu.CV.Flann.Index.RadiusSearch(Emgu.CV.Matrix{System.Single},Emgu.CV.Matrix{System.Int32},Emgu.CV.Matrix{System.Single},System.Single,System.Int32)">
            <summary>
            Performs a radius nearest neighbor search for multiple query points
            </summary>
            <param name="queries">The query points, one per row</param>
            <param name="indices">Indices of the nearest neighbors found</param>
            <param name="distances">Distances to the nearest neighbors found</param>
            <param name="radius">The search radius</param>
            <param name="checks">The number of times the tree(s) in the index should be recursively traversed. A
            higher value for this parameter would give better search precision, but also take more
            time. If automatic configuration was used when the index was created, the number of
            checks required to achieve the specified precision was also computed, in which case
            this parameter is ignored </param>
        </member>
        <member name="M:Emgu.CV.Flann.Index.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this Flann Index
            </summary>
        </member>
        <member name="T:Emgu.CV.Geodetic.GeodeticCoordinate">
            <summary>
            A geodetic coordinate that is defined by its latitude, longitude and altitude
            </summary>
        </member>
        <member name="F:Emgu.CV.Geodetic.GeodeticCoordinate.Empty">
            <summary>
            Indicates the origin of the Geodetic Coordinate
            </summary>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Create a geodetic coordinate using the specific values
            </summary>
            <param name="latitude">Latitude in radian</param>
            <param name="longitude">Longitude in radian</param>
            <param name="altitude">Altitude in meters</param>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.op_Addition(Emgu.CV.Geodetic.GeodeticCoordinate,Emgu.CV.Geodetic.GeodeticCoordinate)">
            <summary>
            Compute the sum of two GeodeticCoordinates
            </summary>
            <param name="coor1">The first coordinate to be added</param>
            <param name="coor2">The second coordinate to be added</param>
            <returns>The sum of two GeodeticCoordinates</returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.op_Subtraction(Emgu.CV.Geodetic.GeodeticCoordinate,Emgu.CV.Geodetic.GeodeticCoordinate)">
            <summary>
            Compute <paramref name="coor1"/> - <paramref name="coor2"/>
            </summary>
            <param name="coor1">The first coordinate</param>
            <param name="coor2">The coordinate to be substracted</param>
            <returns><paramref name="coor1"/> - <paramref name="coor2"/></returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.op_Multiply(Emgu.CV.Geodetic.GeodeticCoordinate,System.Double)">
            <summary>
            Compute <paramref name="coor"/> * <paramref name="scale"/>
            </summary>
            <param name="coor">The coordinate</param>
            <param name="scale">The scale to be multiplied</param>
            <returns><paramref name="coor"/> * <paramref name="scale"/></returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.GeodeticCoordinate.Equals(Emgu.CV.Geodetic.GeodeticCoordinate)">
            <summary>
            Check if this Geodetic coordinate equals <paramref name="other"/>
            </summary>
            <param name="other">The other coordinate to be compared with</param>
            <returns>True if two coordinates equals</returns>
        </member>
        <member name="P:Emgu.CV.Geodetic.GeodeticCoordinate.Latitude">
            <summary>
            Latitude (phi) in radian
            </summary>
        </member>
        <member name="P:Emgu.CV.Geodetic.GeodeticCoordinate.Longitude">
            <summary>
            Longitude (lambda) in radian
            </summary>
        </member>
        <member name="P:Emgu.CV.Geodetic.GeodeticCoordinate.Altitude">
            <summary>
            Altitude (height) in meters
            </summary>
        </member>
        <member name="T:Emgu.CV.Geodetic.TransformationWGS84">
            <summary>
            Defines WGS84 transformation
            </summary>
        </member>
        <member name="M:Emgu.CV.Geodetic.TransformationWGS84.Geodetic2ECEF(Emgu.CV.Geodetic.GeodeticCoordinate)">
            <summary>
            Convert geodetic coordinate to ECEF coordinate
            </summary>
            <param name="coordinate">the geodetic coordinate</param>
            <returns>The ECEF coordinate</returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.TransformationWGS84.ECEF2Geodetic(Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Convert ECEF coordinate to geodetic coordinate
            </summary>
            <param name="ecef">The ecef coordinate</param>
            <returns>The geodetic coordinate</returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.TransformationWGS84.Geodetic2ENU(Emgu.CV.Geodetic.GeodeticCoordinate,Emgu.CV.Geodetic.GeodeticCoordinate)">
            <summary>
            Convert <paramref name="coor"/> to ENU (East North UP) coordinate using the reference coordinate <paramref name="refCoor"/>
            </summary>
            <param name="coor">The Geodetic Coordinate to be converted</param>
            <param name="refCoor">The reference Geodetic coordinate</param>
            <returns>The ENU (East North UP) coordinate related to the reference coordinate</returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.TransformationWGS84.Geodetic2ENU(Emgu.CV.Geodetic.GeodeticCoordinate,Emgu.CV.Geodetic.GeodeticCoordinate,Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Convert <paramref name="coor"/> to ENU (East North UP) coordinate using the reference coordinate <paramref name="refCoor"/>
            </summary>
            <param name="coor">The Geodetic Coordinate to be converted</param>
            <param name="refCoor">The reference Geodetic coordinate</param>
            <param name="refEcef"><paramref name="refCoor"/> in ECEF format. If this is provided, it speeds up the computation</param>
            <returns>The ENU (East North UP) coordinate related to the reference coordinate</returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.TransformationWGS84.Geodetic2NED(Emgu.CV.Geodetic.GeodeticCoordinate,Emgu.CV.Geodetic.GeodeticCoordinate)">
            <summary>
            Convert <paramref name="coor"/> to NED (North East Down) coordinate using the reference coordinate <paramref name="refCoor"/>
            </summary>
            <param name="coor">The Geodetic Coordinate to be converted</param>
            <param name="refCoor">The reference Geodetic coordinate</param>
            <returns>The NED (North East Down) coordinate related to the reference coordinate</returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.TransformationWGS84.Geodetic2NED(Emgu.CV.Geodetic.GeodeticCoordinate,Emgu.CV.Geodetic.GeodeticCoordinate,Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Convert <paramref name="coor"/> to NED (North East Down) coordinate using the reference coordinate <paramref name="refCoor"/>
            </summary>
            <param name="coor">The Geodetic Coordinate to be converted</param>
            <param name="refCoor">The reference Geodetic coordinate</param>
            <param name="refEcef"><paramref name="refCoor"/> in ECEF format. If this is provided, it speeds up the computation</param>
            <returns>The NED (North East Down) coordinate related to the reference coordinate</returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.TransformationWGS84.ENU2Geodetic(Emgu.CV.Structure.MCvPoint3D64f,Emgu.CV.Geodetic.GeodeticCoordinate)">
            <summary>
            Convert <paramref name="enu"/> to Geodetic coordinate using the reference coordinate <paramref name="refCoor"/>
            </summary>
            <param name="enu">The ENU (East North UP) coordinate to be converted</param>
            <param name="refCoor">The reference Geodetic coordinate</param>
            <returns>The Geodetic coordinate</returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.TransformationWGS84.ENU2Geodetic(Emgu.CV.Structure.MCvPoint3D64f,Emgu.CV.Geodetic.GeodeticCoordinate,Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Convert <paramref name="enu"/> to Geodetic coordinate using the reference coordinate <paramref name="refCoor"/>
            </summary>
            <param name="enu">The ENU (East North UP) coordinate to be converted</param>
            <param name="refCoor">The reference Geodetic coordinate</param>
            <param name="refEcef"><paramref name="refCoor"/> in ECEF format. If this is provided, it speeds up the computation</param>
            <returns>The Geodetic coordinate</returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.TransformationWGS84.NED2Geodetic(Emgu.CV.Structure.MCvPoint3D64f,Emgu.CV.Geodetic.GeodeticCoordinate,Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Convert <paramref name="ned"/> to Geodetic coordinate using the reference coordinate <paramref name="refCoor"/>
            </summary>
            <param name="ned">The NED (North East Down) coordinate to be converted</param>
            <param name="refCoor">The reference Geodetic coordinate</param>
            <param name="refEcef"><paramref name="refCoor"/> in ECEF format. If this is provided, it speeds up the computation</param>
            <returns>The Geodetic coordinate</returns>
        </member>
        <member name="M:Emgu.CV.Geodetic.TransformationWGS84.NED2Geodetic(Emgu.CV.Structure.MCvPoint3D64f,Emgu.CV.Geodetic.GeodeticCoordinate)">
            <summary>
            Convert <paramref name="ned"/> to Geodetic coordinate using the reference coordinate <paramref name="refCoor"/>
            </summary>
            <param name="ned">The NED (North East Down) coordinate to be converted</param>
            <param name="refCoor">The reference Geodetic coordinate</param>
            <returns>The Geodetic coordinate</returns>
        </member>
        <member name="T:Emgu.CV.HaarCascade">
            <summary> 
             HaarCascade for object detection
             </summary>
        </member>
        <member name="M:Emgu.CV.HaarCascade.#ctor(System.String)">
            <summary> Create a HaarCascade object from the specific file</summary>
            <param name="fileName"> The name of the file that contains the HaarCascade object</param>
        </member>
        <member name="M:Emgu.CV.HaarCascade.DisposeObject">
            <summary>
            Release the HaarCascade Object and all the memory associate with it
            </summary>
        </member>
        <member name="T:Emgu.CV.HOGDescriptor">
            <summary>
            A HOG discriptor
            </summary>
        </member>
        <member name="M:Emgu.CV.HOGDescriptor.#ctor">
            <summary>
            Create a new HOGDescriptor
            </summary>
        </member>
        <member name="M:Emgu.CV.HOGDescriptor.#ctor(System.Drawing.Size,System.Drawing.Size,System.Drawing.Size,System.Drawing.Size,System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
            <summary>
            Create a new HOGDescriptor using the specific parameters
            </summary>
        </member>
        <member name="M:Emgu.CV.HOGDescriptor.GetDefaultPeopleDetector">
            <summary>
            Return the default people detector
            </summary>
            <returns>the default people detector</returns>
        </member>
        <member name="M:Emgu.CV.HOGDescriptor.SetSVMDetector(System.Single[])">
            <summary>
            Set the SVM detector 
            </summary>
            <param name="detector">The SVM detector</param>
        </member>
        <member name="M:Emgu.CV.HOGDescriptor.DetectMultiScale(Emgu.CV.Image{Emgu.CV.Structure.Bgr,System.Byte},System.Double,System.Drawing.Size,System.Drawing.Size,System.Double,System.Int32)">
            <summary>
            
            </summary>
            <param name="image"></param>
            <param name="hitThreshold"></param>
            <param name="winStride"></param>
            <param name="padding"></param>
            <param name="scale"></param>
            <param name="groupThreshold"></param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.HOGDescriptor.DetectMultiScale(Emgu.CV.Image{Emgu.CV.Structure.Bgr,System.Byte})">
            <summary>
            
            </summary>
            <param name="image"></param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.HOGDescriptor.ReleaseManagedResources">
            <summary>
            Release the managed resources associated with this object
            </summary>
        </member>
        <member name="M:Emgu.CV.HOGDescriptor.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this HOGDescriptor
            </summary>
        </member>
        <member name="T:Emgu.CV.IImage">
            <summary>
            IImage interface
            </summary>
        </member>
        <member name="M:Emgu.CV.IImage.MinMax(System.Double[]@,System.Double[]@,System.Drawing.Point[]@,System.Drawing.Point[]@)">
            <summary>
            Returns the min / max location and values for the image
            </summary>
            <returns>
            Returns the min / max location and values for the image
            </returns>
        </member>
        <member name="M:Emgu.CV.IImage.Split">
            <summary> 
             Split current IImage into an array of gray scale images where each element 
             in the array represent a single color channel of the original image
            </summary>
            <returns> 
             An array of gray scale images where each element 
             in the array represent a single color channel of the original image 
            </returns>
        </member>
        <member name="M:Emgu.CV.IImage.Save(System.String)">
            <summary>
            Save the image to the specific <paramref name="fileName"/> 
            </summary>
            <param name="fileName">The file name of the image</param>
        </member>
        <member name="P:Emgu.CV.IImage.Bitmap">
            <summary>
            Convert this image into Bitmap, when avaialbe, data is shared with this image.
            </summary>
            <returns>The Bitmap, when avaialbe, data is shared with this image</returns>
        </member>
        <member name="P:Emgu.CV.IImage.Size">
            <summary>
            The size of this image
            </summary>
        </member>
        <member name="P:Emgu.CV.IImage.Ptr">
            <summary>
            Get the pointer to the unmanaged memory
            </summary>
        </member>
        <member name="P:Emgu.CV.IImage.NumberOfChannels">
            <summary>
            Get the number of channels for this image
            </summary>
        </member>
        <member name="T:Emgu.CV.Image`2">
            <summary>
            An Image is a wrapper to IplImage of OpenCV. 
            </summary>
            <typeparam name="TColor">Color type of this image (either Gray, Bgr, Bgra, Hsv, Hls, Lab, Luv, Xyz or Ycc)</typeparam>
            <typeparam name="TDepth">Depth of this image (either Byte, SByte, Single, double, UInt16, Int16 or Int32)</typeparam>
        </member>
        <member name="F:Emgu.CV.Image`2._numberOfChannels">
            <summary>
            The dimension of color
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor">
            <summary>
            Create an empty Image
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(`1[0:,0:,0:])">
            <summary>
            Create image from the specific multi-dimensional data, where the 1st dimesion is # of rows (height), the 2nd dimension is # cols (width) and the 3rd dimension is the channel
            </summary>
            <param name="data">The multi-dimensional data where the 1st dimesion is # of rows (height), the 2nd dimension is # cols (width) and the 3rd dimension is the channel </param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Int32,System.Int32,System.Int32,System.IntPtr)">
            <summary>
            Create an Image from unmanaged data. 
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
            <param name="stride">size of aligned image row in bytes</param>
            <param name="scan0">Pointer to aligned image data, <b>where each row should be 4-align</b> </param>
            <remarks>The caller is responsible for allocating and freeing the block of memory specified by the scan0 parameter, however, the memory should not be released until the related Image is released. </remarks>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.String)">
            <summary>
            Read image from a file
            </summary>
            <param name="fileName">the name of the file that contains the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.LoadFileUsingBitmap(System.IO.FileInfo)">
            <summary>
            Load the specific file using Bitmap
            </summary>
            <param name="file"></param>
        </member>
        <member name="M:Emgu.CV.Image`2.LoadImageUsingOpenCV(System.IO.FileInfo)">
            <summary>
            Load the specific file using OpenCV
            </summary>
            <param name="file"></param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Drawing.Bitmap)">
            <summary>
            Obtain the image from the specific Bitmap
            </summary>
            <param name="bmp">The bitmap which will be converted to the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Int32,System.Int32,`0)">
            <summary>
            Create a blank Image of the specified width, height and color.
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
            <param name="value">The initial color of the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a blank Image of the specified width and height. 
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Drawing.Size)">
            <summary>
            Create a blank Image of the specific size
            </summary>
            <param name="size">The size of the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.AllocateData(System.Int32,System.Int32,System.Int32)">
            <summary>
            Allocate data for the array
            </summary>
            <param name="rows">The number of rows</param>
            <param name="cols">The number of columns</param>
            <param name="numberOfChannels">The number of channels of this image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(Emgu.CV.Image{Emgu.CV.Structure.Gray,`1}[])">
            <summary>
            Create a multi-channel image from multiple gray scale images
            </summary>
            <param name="channels">The image channels to be merged into a single image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Image`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serilization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">streaming context</param>
        </member>
        <member name="M:Emgu.CV.Image`2.GetAverage">
            <summary>
            Get the average value on this image
            </summary>
            <returns>The average color of the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GetAverage(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Get the average value on this image, using the specific mask
            </summary>
            <param name="mask">The mask for find the average value</param>
            <returns>The average color of the masked area</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GetSum">
            <summary>Get the sum for each color channel </summary>
            <returns>The sum for each color channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SetValue(`0)">
            <summary>
            Set every pixel of the image to the specific color 
            </summary>
            <param name="color">The color to be set</param>
        </member>
        <member name="M:Emgu.CV.Image`2.SetValue(`0,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Set every pixel of the image to the specific color, using a mask
            </summary>
            <param name="color">The color to be set</param>
            <param name="mask">The mask for setting color</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Copy(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Copy the masked area of this image to destination
            </summary>
            <param name="dest">the destination to copy to</param>
            <param name="mask">the mask for copy</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Copy(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> 
             Make a copy of the image using a mask, if ROI is set, only copy the ROI 
             </summary> 
             <param name="mask">the mask for coping</param>
            <returns> A copy of the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Copy(System.Drawing.Rectangle)">
            <summary>
            Make a copy of the specific ROI (Region of Interest) from the image
            </summary>
            <param name="roi">The roi to be copied</param>
            <returns>The roi region on the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Copy(Emgu.CV.Structure.MCvBox2D)">
            <summary>
            Get a copy of the boxed region of the image
            </summary>
            <param name="box">The boxed region of the image</param>
            <returns>A copy of the boxed region of the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Copy">
            <summary> Make a copy of the image, if ROI is set, only copy the ROI</summary>
            <returns> A copy of the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.CopyBlank">
            <summary> 
            Create an image of the same size
            </summary>
            <remarks>The initial pixel in the image equals zero</remarks>
            <returns> The image of the same size</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Clone">
            <summary>
            Make a clone of the current image. All image data as well as the COI and ROI are cloned
            </summary>
            <returns>A clone of the current image. All image data as well as the COI and ROI are cloned</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GetSubRect(System.Drawing.Rectangle)">
            <summary>
            Get a subimage which image data is shared with the current image.
            </summary>
            <param name="rect">The rectangle area of the sub-image</param>
            <returns>A subimage which image data is shared with the current image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(System.Drawing.Rectangle,`0,System.Int32)">
            <summary> Draw an Rectangle of the specific color and thickness </summary>
            <param name="rect"> The rectangle to be drawn</param>
            <param name="color"> The color of the rectangle </param>
            <param name="thickness"> If thickness is less than 1, the rectangle is filled up </param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Structure.Cross2DF,`0,System.Int32)">
            <summary> Draw a 2D Cross using the specific color and thickness </summary>
            <param name="cross"> The 2D Cross to be drawn</param>
            <param name="color"> The color of the cross </param>
            <param name="thickness"> Must be &gt; 0 </param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Structure.LineSegment2DF,`0,System.Int32)">
            <summary> Draw a line segment using the specific color and thickness </summary>
            <param name="line"> The line segment to be drawn</param>
            <param name="color"> The color of the line segment </param>
            <param name="thickness"> The thickness of the line segment </param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Structure.LineSegment2D,`0,System.Int32)">
            <summary> Draw a line segment using the specific color and thickness </summary>
            <param name="line"> The line segment to be drawn</param>
            <param name="color"> The color of the line segment </param>
            <param name="thickness"> The thickness of the line segment </param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.IConvexPolygonF,`0,System.Int32)">
            <summary> Draw a convex polygon using the specific color and thickness </summary>
            <param name="polygon"> The convex polygon to be drawn</param>
            <param name="color"> The color of the triangle </param>
            <param name="thickness"> If thickness is less than 1, the triangle is filled up </param>
        </member>
        <member name="M:Emgu.CV.Image`2.FillConvexPoly(System.Drawing.Point[],`0)">
            <summary>
            Fill the convex polygon with the specific color
            </summary>
            <param name="pts">The array of points that define the convex polygon</param>
            <param name="color">The color to fill the polygon with</param>
        </member>
        <member name="M:Emgu.CV.Image`2.DrawPolyline(System.Drawing.Point[],System.Boolean,`0,System.Int32)">
            <summary>
            Draw the polyline defined by the array of 2D points
            </summary>
            <param name="pts">A polyline defined by its point</param>
            <param name="isClosed">if true, the last line segment is defined by the last point of the array and the first point of the array</param>
            <param name="color">the color used for drawing</param>
            <param name="thickness">the thinkness of the line</param>
        </member>
        <member name="M:Emgu.CV.Image`2.DrawPolyline(System.Drawing.Point[][],System.Boolean,`0,System.Int32)">
            <summary>
            Draw the polylines defined by the array of array of 2D points
            </summary>
            <param name="pts">An array of polylines each represented by an array of points</param>
            <param name="isClosed">if true, the last line segment is defined by the last point of the array and the first point of the array</param>
            <param name="color">the color used for drawing</param>
            <param name="thickness">the thinkness of the line</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Structure.CircleF,`0,System.Int32)">
            <summary> Draw a Circle of the specific color and thickness </summary>
            <param name="circle"> The circle to be drawn</param>
            <param name="color"> The color of the circle </param>
            <param name="thickness"> If thickness is less than 1, the circle is filled up </param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Structure.Ellipse,`0,System.Int32)">
            <summary> Draw a Ellipse of the specific color and thickness </summary>
            <param name="ellipse"> The ellipse to be draw</param>
            <param name="color"> The color of the ellipse </param>
            <param name="thickness"> If thickness is less than 1, the ellipse is filled up </param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(System.String,Emgu.CV.Structure.MCvFont@,System.Drawing.Point,`0)">
            <summary>
            Draw the text using the specific font on the image
            </summary>
            <param name="message">The text message to be draw</param>
            <param name="font">The font used for drawing</param>
            <param name="bottomLeft">The location of the bottom left corner of the font</param>
            <param name="color">The color of the text</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Seq{System.Drawing.Point},`0,System.Int32)">
            <summary>
            Draws contour outlines in the image if thickness&gt;=0 or fills area bounded by the contours if thickness&lt;0
            </summary>
            <param name="c">Pointer to the contour</param>
            <param name="color">Color of the contour</param>
            <param name="thickness">Thickness of lines the contours are drawn with. If it is negative, the contour interiors are drawn</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Seq{System.Drawing.Point},`0,`0,System.Int32,System.Int32)">
            <summary>
            Draws contour outlines in the image if thickness&gt;=0 or fills area bounded by the contours if thickness&lt;0
            </summary>
            <param name="c">Pointer to the first contour</param>
            <param name="externalColor">Color of the external contours</param>
            <param name="holeColor">Color of internal contours (holes). </param>
            <param name="maxLevel">
            Maximal level for drawn contours. 
            If 0, only contour is drawn. 
            If 1, the contour and all contours after it on the same level are drawn. 
            If 2, all contours after and all contours one level below the contours are drawn, etc. If the value is negative, the function does not draw the contours following after contour but draws child contours of contour up to abs(maxLevel)-1 level
            </param>
            <param name="thickness">Thickness of lines the contours are drawn with. If it is negative, the contour interiors are drawn</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Draw(Emgu.CV.Seq{System.Drawing.Point},`0,`0,System.Int32,System.Int32,System.Drawing.Point)">
            <summary>
            Draws contour outlines in the image if thickness&gt;=0 or fills area bounded by the contours if thickness&lt;0
            </summary>
            <param name="c">Pointer to the first contour</param>
            <param name="externalColor">Color of the external contours</param>
            <param name="holeColor">Color of internal contours (holes). </param>
            <param name="maxLevel">
            Maximal level for drawn contours. 
            If 0, only contour is drawn. 
            If 1, the contour and all contours after it on the same level are drawn. 
            If 2, all contours after and all contours one level below the contours are drawn, etc. If the value is negative, the function does not draw the contours following after contour but draws child contours of contour up to abs(maxLevel)-1 level
            </param>
            <param name="thickness">Thickness of lines the contours are drawn with. If it is negative, the contour interiors are drawn</param>
            <param name="offset">Shift all the point coordinates by the specified value. It is useful in case if the contours retrived in some image ROI and then the ROI offset needs to be taken into account during the rendering</param>
        </member>
        <member name="M:Emgu.CV.Image`2.DetectHaarCascade(Emgu.CV.HaarCascade)">
            <summary>
            Detect HaarCascade object in the current image, using predifined parameters
            </summary>
            <param name="haarObj">The object to be detected</param>
            <returns>The objects detected, one array per channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.DetectHaarCascade(Emgu.CV.HaarCascade,System.Double,System.Int32,Emgu.CV.CvEnum.HAAR_DETECTION_TYPE,System.Drawing.Size)">
            <summary>
            Finds rectangular regions in the given image that are likely to contain objects the cascade has been trained for and returns those regions as a sequence of rectangles. The function scans the image several times at different scales (see cvSetImagesForHaarClassifierCascade). Each time it considers overlapping regions in the image and applies the classifiers to the regions using cvRunHaarClassifierCascade. It may also apply some heuristics to reduce number of analyzed regions, such as Canny prunning. After it has proceeded and collected the candidate rectangles (regions that passed the classifier cascade), it groups them and returns a sequence of average rectangles for each large enough group. The default parameters (scale_factor=1.1, min_neighbors=3, flags=0) are tuned for accurate yet slow object detection. For a faster operation on real video images the settings are: scale_factor=1.2, min_neighbors=2, flags=CV_HAAR_DO_CANNY_PRUNING, min_size=&lt;minimum possible face size&gt; (for example, ~1/4 to 1/16 of the image area in case of video conferencing). 
            </summary>
            <param name="haarObj">Haar classifier cascade in internal representation</param>
            <param name="scaleFactor">The factor by which the search window is scaled between the subsequent scans, for example, 1.1 means increasing window by 10%</param>
            <param name="minNeighbors">Minimum number (minus 1) of neighbor rectangles that makes up an object. All the groups of a smaller number of rectangles than min_neighbors-1 are rejected. If min_neighbors is 0, the function does not any grouping at all and returns all the detected candidate rectangles, which may be useful if the user wants to apply a customized grouping procedure</param>
            <param name="flag">Mode of operation. Currently the only flag that may be specified is CV_HAAR_DO_CANNY_PRUNING. If it is set, the function uses Canny edge detector to reject some image regions that contain too few or too much edges and thus can not contain the searched object. The particular threshold values are tuned for face detection and in this case the pruning speeds up the processing.</param>
            <param name="minSize">Minimum window size. By default, it is set to the size of samples the classifier has been trained on (~20x20 for face detection)</param>
            <returns>The objects detected, one array per channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.HoughLinesBinary(System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary> 
            Apply Probabilistic Hough transform to find line segments. 
            The current image must be a binary image (eg. the edges as a result of the Canny edge detector) 
            </summary> 
            <param name="rhoResolution">Distance resolution in pixel-related units.</param>
            <param name="thetaResolution">Angle resolution measured in radians</param>
            <param name="threshold">A line is returned by the function if the corresponding accumulator value is greater than threshold</param>
            <param name="minLineWidth">Minimum width of a line</param>
            <param name="gapBetweenLines">Minimum gap between lines</param>
            <returns>The line segments detected for each of the channels</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.HoughLines(`0,`0,System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary> 
             Apply Canny Edge Detector follows by Probabilistic Hough transform to find line segments in the image 
            </summary>
            <param name="cannyThreshold"> The threshhold to find initial segments of strong edges</param>
            <param name="cannyThresholdLinking"> The threshold used for edge Linking</param>
            <param name="rhoResolution">Distance resolution in pixel-related units.</param>
            <param name="thetaResolution">Angle resolution measured in radians</param>
            <param name="threshold">A line is returned by the function if the corresponding accumulator value is greater than threshold</param>
            <param name="minLineWidth">Minimum width of a line</param>
            <param name="gapBetweenLines">Minimum gap between lines</param>
            <returns>The line segments detected for each of the channels</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.HoughCircles(`0,`0,System.Double,System.Double,System.Int32,System.Int32)">
            <summary> 
            First apply Canny Edge Detector on the current image, 
            then apply Hough transform to find circles 
            </summary>
            <param name="cannyThreshold">The higher threshold of the two passed to Canny edge detector (the lower one will be twice smaller).</param>
            <param name="accumulatorThreshold">Accumulator threshold at the center detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first</param>
            <param name="dp">Resolution of the accumulator used to detect centers of the circles. For example, if it is 1, the accumulator will have the same resolution as the input image, if it is 2 - accumulator will have twice smaller width and height, etc</param>
            <param name="minRadius">Minimal radius of the circles to search for</param>
            <param name="maxRadius">Maximal radius of the circles to search for</param>
            <param name="minDist">Minimum distance between centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed</param>
            <returns>The circle detected for each of the channels</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.FindContours">
            <summary>
            Find a list of contours using simple approximation method.
            </summary>
            <returns>
            Contour if there is any;
            null if no contour is found
            </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.FindContours(Emgu.CV.CvEnum.CHAIN_APPROX_METHOD,Emgu.CV.CvEnum.RETR_TYPE)">
            <summary>
            Find contours 
            </summary>
            <param name="method">The type of approximation method</param>
            <param name="type">The retrival type</param>
            <returns>
            Contour if there is any;
            null if no contour is found
            </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.FindContours(Emgu.CV.CvEnum.CHAIN_APPROX_METHOD,Emgu.CV.CvEnum.RETR_TYPE,Emgu.CV.MemStorage)">
            <summary>
            Find contours using the specific memory storage
            </summary>
            <param name="method">The type of approximation method</param>
            <param name="type">The retrival type</param>
            <param name="stor">The storage used by the sequences</param>
            <returns>
            Contour if there is any;
            null if no contour is found
            </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.RoiParam(System.IntPtr,System.Int64@,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Return parameters based on ROI
            </summary>
            <param name="ptr">The Pointer to the IplImage</param>
            <param name="start">The address of the pointer that point to the start of the Bytes taken into consideration ROI</param>
            <param name="elementCount">ROI.Width * ColorType.Dimension</param>
            <param name="byteWidth">The number of bytes in a row taken into consideration ROI</param>
            <param name="rows">The number of rows taken into consideration ROI</param>
            <param name="widthStep">The width step required to jump to the next row</param>
        </member>
        <member name="M:Emgu.CV.Image`2.ForEachChannel``1(System.Func{System.IntPtr,System.Int32,``0})">
            <summary>
            Apply convertor and compute result for each channel of the image.
            </summary>
            <remarks>
            For single channel image, apply converter directly.
            For multiple channel image, set the COI for the specific channel before appling the convertor
            </remarks>
            <typeparam name="TResult">The return type</typeparam>
            <param name="conv">The converter such that accept the IntPtr of a single channel IplImage, and image channel index which returning result of type R</param>
            <returns>An array which contains result for each channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ForEachDuplicateChannel(System.Action{Emgu.CV.IImage,System.Int32})">
            <summary>
            Apply convertor and compute result for each channel of the image, for single channel image, apply converter directly, for multiple channel image, make a copy of each channel to a temperary image and apply the convertor
            </summary>
            <param name="action">The converter such that accept the IntPtr of a single channel IplImage, and image channel index which returning result of type R</param>
            <returns>An array which contains result for each channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ForEachDuplicateChannel``1(System.Func{Emgu.CV.IImage,System.Int32,``0})">
            <summary>
            Apply convertor and compute result for each channel of the image, for single channel image, apply converter directly, for multiple channel image, make a copy of each channel to a temperary image and apply the convertor
            </summary>
            <typeparam name="TReturn">The return type</typeparam>
            <param name="conv">The converter such that accept the IntPtr of a single channel IplImage, and image channel index which returning result of type R</param>
            <returns>An array which contains result for each channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ForEachDuplicateChannel``1(System.Action{System.IntPtr,System.IntPtr,System.Int32},Emgu.CV.Image{`0,``0})">
            <summary>
            If the image has only one channel, apply the action directly on the IntPtr of this image and <paramref name="image2"/>,
            otherwise, make copy each channel of this image to a temperary one, apply action on it and another temperory image and copy the resulting image back to image2
            </summary>
            <typeparam name="TOtherDepth">The type of the depth of the <paramref name="dest"/> image</typeparam>
            <param name="act">The function which acepts the src IntPtr, dest IntPtr and index of the channel as input</param>
            <param name="dest">The destination image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Sobel(System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates the image derivative by convolving the image with the appropriate kernel
            The Sobel operators combine Gaussian smoothing and differentiation so the result is more or less robust to the noise. Most often, the function is called with (xorder=1, yorder=0, aperture_size=3) or (xorder=0, yorder=1, aperture_size=3) to calculate first x- or y- image derivative.
            </summary>
            <param name="xorder">Order of the derivative x</param>
            <param name="yorder">Order of the derivative y</param>
            <param name="apertureSize">Size of the extended Sobel kernel, must be 1, 3, 5 or 7. In all cases except 1, aperture_size xaperture_size separable kernel will be used to calculate the derivative.</param>
            <returns>The result of the sobel edge detector</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Laplace(System.Int32)">
             <summary>
             Calculates Laplacian of the source image by summing second x- and y- derivatives calculated using Sobel operator.
             Specifying aperture_size=1 gives the fastest variant that is equal to convolving the image with the following kernel:
            
             |0  1  0|
             |1 -4  1|
             |0  1  0|
             </summary>
             <param name="apertureSize">Aperture size </param>
             <returns>The Laplacian of the image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Canny(`0,`0)">
            <summary> Find the edges on this image and marked them in the returned image.</summary>
            <param name="thresh"> The threshhold to find initial segments of strong edges</param>
            <param name="threshLinking"> The threshold used for edge Linking</param>
            <returns> The edges found by the Canny edge detector</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ExtractSURF(Emgu.CV.MCvSURFParams@)">
            <summary>
            Finds robust features in the image (basic descriptor is returned in this case). For each feature it returns its location, size, orientation and optionally the descriptor, basic or extended. The function can be used for object tracking and localization, image stitching etc
            </summary>
            <param name="param">The SURF parameters</param>
            <returns>The SURF features</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ExtractSURF(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.MCvSURFParams@)">
            <summary>
            Finds robust features in the image (basic descriptor is returned in this case). For each feature it returns its location, size, orientation and optionally the descriptor, basic or extended. The function can be used for object tracking and localization, image stitching etc
            </summary>
            <param name="mask">The optional input 8-bit mask, can be null if not needed. The features are only found in the areas that contain more than 50% of non-zero mask pixels</param>
            <param name="param">The SURF parameters</param>
            <returns>The SURF features</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GetStarKeypoints(Emgu.CV.StarDetector@)">
            <summary>
            Get the star keypoints from this image
            </summary>
            <param name="param">The Star Detector parameters</param>
            <returns>The Star keypoints in this image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GetFASTKeypoints(System.Int32,System.Boolean)">
            <summary>
            Get the FAST keypoints from this image
            </summary>
            <param name="threshold">FAST threshold</param>
            <param name="nonmaxSupression">Specifiy if non-maximum supression should be used</param>
            <returns>The FAST keypoints in this image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ExtractMSER(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Structure.MCvMSERParams@,Emgu.CV.MemStorage)">
            <summary>
            Extracts the contours of Maximally Stable Extremal Regions
            </summary>
            <param name="mask">Can be null if not needed. Optional parameter for the region of interest</param>
            <param name="param">MSER parameter</param>
            <param name="storage">The storage where the contour will be saved</param>
            <returns>The MSER regions</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GoodFeaturesToTrack(System.Int32,System.Double,System.Double,System.Int32)">
            <summary>
            Finds corners with big eigenvalues in the image. 
            </summary>
            <remarks>The function first calculates the minimal eigenvalue for every source image pixel using cvCornerMinEigenVal function and stores them in eig_image. Then it performs non-maxima suppression (only local maxima in 3x3 neighborhood remain). The next step is rejecting the corners with the minimal eigenvalue less than quality_level?max(eig_image(x,y)). Finally, the function ensures that all the corners found are distanced enough one from another by considering the corners (the most strongest corners are considered first) and checking that the distance between the newly considered feature and the features considered earlier is larger than min_distance. So, the function removes the features than are too close to the stronger features</remarks>
            <param name="maxFeaturesPerChannel">The maximum features to be detected per channel</param>
            <param name="qualityLevel">Multiplier for the maxmin eigenvalue; specifies minimal accepted quality of image corners</param>
            <param name="minDistance">Limit, specifying minimum possible distance between returned corners; Euclidian distance is used. </param>
            <param name="blockSize">Size of the averaging block, passed to underlying cvCornerMinEigenVal or cvCornerHarris used by the function</param>
            <returns>The good features for each channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GoodFeaturesToTrack(System.Int32,System.Double,System.Double,System.Int32,System.Double)">
            <summary>
            Finds corners with big eigenvalues in the image. 
            </summary>
            <remarks>The function first calculates the minimal eigenvalue for every source image pixel using cvCornerMinEigenVal function and stores them in eig_image. Then it performs non-maxima suppression (only local maxima in 3x3 neighborhood remain). The next step is rejecting the corners with the minimal eigenvalue less than quality_level?max(eig_image(x,y)). Finally, the function ensures that all the corners found are distanced enough one from another by considering the corners (the most strongest corners are considered first) and checking that the distance between the newly considered feature and the features considered earlier is larger than min_distance. So, the function removes the features than are too close to the stronger features</remarks>
            <param name="maxFeaturesPerChannel">The maximum features to be detected per channel</param>
            <param name="qualityLevel">Multiplier for the maxmin eigenvalue; specifies minimal accepted quality of image corners</param>
            <param name="minDistance">Limit, specifying minimum possible distance between returned corners; Euclidian distance is used. </param>
            <param name="blockSize">Size of the averaging block, passed to underlying cvCornerMinEigenVal or cvCornerHarris used by the function</param>
            <param name="k">Free parameter of Harris detector. If provided, Harris operator (cvCornerHarris) is used instead of default cvCornerMinEigenVal. </param>
            <returns>The good features for each channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GoodFeaturesToTrack(System.Int32,System.Double,System.Double,System.Int32,System.Boolean,System.Double)">
            <summary>
            Finds corners with big eigenvalues in the image. 
            </summary>
            <remarks>The function first calculates the minimal eigenvalue for every source image pixel using cvCornerMinEigenVal function and stores them in eig_image. Then it performs non-maxima suppression (only local maxima in 3x3 neighborhood remain). The next step is rejecting the corners with the minimal eigenvalue less than quality_level?max(eig_image(x,y)). Finally, the function ensures that all the corners found are distanced enough one from another by considering the corners (the most strongest corners are considered first) and checking that the distance between the newly considered feature and the features considered earlier is larger than min_distance. So, the function removes the features than are too close to the stronger features</remarks>
            <param name="maxFeaturesPerChannel">The maximum features to be detected per channel</param>
            <param name="qualityLevel">Multiplier for the maxmin eigenvalue; specifies minimal accepted quality of image corners</param>
            <param name="minDistance">Limit, specifying minimum possible distance between returned corners; Euclidian distance is used. </param>
            <param name="blockSize">Size of the averaging block, passed to underlying cvCornerMinEigenVal or cvCornerHarris used by the function</param>
            <param name="useHarris">If nonzero, Harris operator (cvCornerHarris) is used instead of default cvCornerMinEigenVal</param>
            <param name="k">Free parameter of Harris detector; used only if use_harris = true </param>
            <returns>The good features for each channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.FindCornerSubPix(System.Drawing.PointF[][],System.Drawing.Size,System.Drawing.Size,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Iterates to find the sub-pixel accurate location of corners, or radial saddle points
            </summary>
            <param name="corners">Coordinates of the input corners, the values will be modified by this function call</param>
            <param name="win">Half sizes of the search window. For example, if win=(5,5) then 5*2+1 x 5*2+1 = 11 x 11 search window is used</param>
            <param name="zeroZone">Half size of the dead region in the middle of the search zone over which the summation in formulae below is not done. It is used sometimes to avoid possible singularities of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such size</param>
            <param name="criteria">Criteria for termination of the iterative process of corner refinement. That is, the process of corner position refinement stops either after certain number of iteration or when a required accuracy is achieved. The criteria may specify either of or both the maximum number of iteration and the required accuracy</param>
            <returns>Refined corner coordinates</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.MatchTemplate(Emgu.CV.Image{`0,`1},Emgu.CV.CvEnum.TM_TYPE)">
            <summary>
            The function slids through image, compares overlapped patches of size wxh with templ using the specified method and return the comparison results 
            </summary>
            <param name="template">Searched template; must be not greater than the source image and the same data type as the image</param>
            <param name="method">Specifies the way the template must be compared with image regions </param>
            <returns>The comparison result: width = this.Width - template.Width + 1; height = this.Height - template.Height + 1 </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Snake(Emgu.CV.Seq{System.Drawing.Point},System.Single,System.Single,System.Single,System.Drawing.Size,Emgu.CV.Structure.MCvTermCriteria,Emgu.CV.MemStorage)">
            <summary>
            Updates snake in order to minimize its total energy that is a sum of internal energy that depends on contour shape (the smoother contour is, the smaller internal energy is) and external energy that depends on the energy field and reaches minimum at the local energy extremums that correspond to the image edges in case of image gradient.
            </summary>
            <param name="contour">Some existing contour</param>
            <param name="alpha">Weight[s] of continuity energy, single float or array of length floats, one per each contour point</param>
            <param name="beta">Weight[s] of curvature energy, similar to alpha.</param>
            <param name="gamma">Weight[s] of image energy, similar to alpha.</param>
            <param name="windowSize">Size of neighborhood of every point used to search the minimum, both win.width and win.height must be odd</param>
            <param name="tc">Termination criteria. The parameter criteria.epsilon is used to define the minimal number of points that must be moved during any iteration to keep the iteration process running. If at some iteration the number of moved points is less than criteria.epsilon or the function performed criteria.max_iter iterations, the function terminates. </param>
            <param name="storage">The memory storage used by the resulting sequence</param>
            <returns>The snake[d] contour</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Snake(System.Drawing.Point[],System.Single,System.Single,System.Single,System.Drawing.Size,Emgu.CV.Structure.MCvTermCriteria,System.Boolean)">
            <summary>
            Updates snake in order to minimize its total energy that is a sum of internal energy that depends on contour shape (the smoother contour is, the smaller internal energy is) and external energy that depends on the energy field and reaches minimum at the local energy extremums that correspond to the image edges in case of image gradient.
            </summary>
            <param name="contour">Some existing contour. It's value will be update by this function</param>
            <param name="alpha">Weight[s] of continuity energy, single float or array of length floats, one per each contour point</param>
            <param name="beta">Weight[s] of curvature energy, similar to alpha.</param>
            <param name="gamma">Weight[s] of image energy, similar to alpha.</param>
            <param name="windowSize">Size of neighborhood of every point used to search the minimum, both win.width and win.height must be odd</param>
            <param name="tc">Termination criteria. The parameter criteria.epsilon is used to define the minimal number of points that must be moved during any iteration to keep the iteration process running. If at some iteration the number of moved points is less than criteria.epsilon or the function performed criteria.max_iter iterations, the function terminates. </param>
            <param name="calculateGradiant">If true, the function calculates gradient magnitude for every image pixel and considers it as the energy field, otherwise the input image itself is considered</param>
        </member>
        <member name="M:Emgu.CV.Image`2.And(Emgu.CV.Image{`0,`1})">
            <summary> Perform an elementwise AND operation with another image and return the result</summary>
            <param name="img2">The second image for the AND operation</param>
            <returns> The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.And(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> 
            Perform an elementwise AND operation with another image, using a mask, and return the result
            </summary>
            <param name="img2">The second image for the AND operation</param>
            <param name="mask">The mask for the AND operation</param>
            <returns> The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.And(`0)">
            <summary> Perform an binary AND operation with some color</summary>
            <param name="val">The color for the AND operation</param>
            <returns> The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.And(`0,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> Perform an binary AND operation with some color using a mask</summary>
            <param name="val">The color for the AND operation</param>
            <param name="mask">The mask for the AND operation</param>
            <returns> The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Or(Emgu.CV.Image{`0,`1})">
            <summary> Perform an elementwise OR operation with another image and return the result</summary>
            <param name="img2">The second image for the OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Or(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> Perform an elementwise OR operation with another image, using a mask, and return the result</summary>
            <param name="img2">The second image for the OR operation</param>
            <param name="mask">The mask for the OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Or(`0)">
            <summary> Perform an elementwise OR operation with some color</summary>
            <param name="val">The value for the OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Or(`0,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> Perform an elementwise OR operation with some color using a mask</summary>
            <param name="val">The color for the OR operation</param>
            <param name="mask">The mask for the OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Xor(Emgu.CV.Image{`0,`1})">
            <summary> Perform an elementwise XOR operation with another image and return the result</summary>
            <param name="img2">The second image for the XOR operation</param>
            <returns> The result of the XOR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Xor(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Perform an elementwise XOR operation with another image, using a mask, and return the result
            </summary>
            <param name="img2">The second image for the XOR operation</param>
            <param name="mask">The mask for the XOR operation</param>
            <returns>The result of the XOR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Xor(`0)">
            <summary> 
            Perform an binary XOR operation with some color
            </summary>
            <param name="val">The value for the XOR operation</param>
            <returns> The result of the XOR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Xor(`0,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Perform an binary XOR operation with some color using a mask
            </summary>
            <param name="val">The color for the XOR operation</param>
            <param name="mask">The mask for the XOR operation</param>
            <returns> The result of the XOR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Not">
            <summary> 
            Compute the complement image
            </summary>
            <returns> The complement image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Max(Emgu.CV.Image{`0,`1})">
            <summary> Find the elementwise maximum value </summary>
            <param name="img2">The second image for the Max operation</param>
            <returns> An image where each pixel is the maximum of <i>this</i> image and the parameter image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Max(System.Double)">
            <summary> Find the elementwise maximum value </summary>
            <param name="value">The value to compare with</param>
            <returns> An image where each pixel is the maximum of <i>this</i> image and <paramref name="value"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Min(Emgu.CV.Image{`0,`1})">
            <summary> Find the elementwise minimum value </summary>
            <param name="img2">The second image for the Min operation</param>
            <returns> An image where each pixel is the minimum of <i>this</i> image and the parameter image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Min(System.Double)">
            <summary> Find the elementwise minimum value </summary>
            <param name="value">The value to compare with</param>
            <returns> An image where each pixel is the minimum of <i>this</i> image and <paramref name="value"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.InRange(`0,`0)">
            <summary>Checks that image elements lie between two scalars</summary>
            <param name="lower"> The lower limit of color value</param>
            <param name="higher"> The upper limit of color value</param>
            <returns> res[i,j] = 255 if inrange, 0 otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.InRange(Emgu.CV.Image{`0,`1},Emgu.CV.Image{`0,`1})">
            <summary>Checks that image elements lie between values defined by two images of same size and type</summary>
            <param name="lower"> The lower limit of color value</param>
            <param name="higher"> The upper limit of color value</param>
            <returns> res[i,j] = 255 if inrange, 0 otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Cmp(Emgu.CV.Image{`0,`1},Emgu.CV.CvEnum.CMP_TYPE)">
            <summary>
            Compare the current image with <paramref name="img2"/> and returns the comparison mask
            </summary>
            <param name="img2">The other image to compare with</param>
            <param name="cmpType">The comparison type</param>
            <returns>The result of the comparison as a mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Cmp(System.Double,Emgu.CV.CvEnum.CMP_TYPE)">
            <summary>
            Compare the current image with <paramref name="value"/> and returns the comparison mask
            </summary>
            <param name="value">The value to compare with</param>
            <param name="comparisonType">The comparison type</param>
            <returns>The result of the comparison as a mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Equals(Emgu.CV.Image{`0,`1})">
            <summary>
            Compare two images, returns true if the each of the pixels are equal, false otherwise
            </summary>
            <param name="img2">The other image to compare with</param>
            <returns>true if the each of the pixels for the two images are equal, false otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GrabCut(System.Drawing.Rectangle,System.Int32)">
            <summary>
            Use grabcut to perform background forground segmentation.
            </summary>
            <param name="rect">The initial rectangle region for the forground</param>
            <param name="iteration">The number of iterations to run GrabCut</param>
            <returns>The background forground mask where 2 indicates background and 3 indicates forground</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Sub(Emgu.CV.Image{`0,`1})">
            <summary> Elementwise subtract another image from the current image </summary>
            <param name="img2">The second image to be subtraced from the current image</param>
            <returns> The result of elementwise subtracting img2 from the current image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Sub(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> Elementwise subtrace another image from the current image, using a mask</summary>
            <param name="img2">The image to be subtraced from the current image</param>
            <param name="mask">The mask for the subtract operation</param>
            <returns> The result of elementwise subtrating img2 from the current image, using the specific mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Sub(`0)">
            <summary> Elementwise subtrace a color from the current image</summary>
            <param name="val">The color value to be subtraced from the current image</param>
            <returns> The result of elementwise subtracting color 'val' from the current image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SubR(`0)">
            <summary>
            result = val - this
            </summary>
            <param name="val">the value which subtract this image</param>
            <returns>val - this</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SubR(`0,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            result = val - this, using a mask
            </summary>
            <param name="val">the value which subtract this image</param>
            <param name="mask"> The mask for substraction</param>
            <returns>val - this, with mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Add(Emgu.CV.Image{`0,`1})">
            <summary> Elementwise add another image with the current image </summary>
            <param name="img2">The image to be added to the current image</param>
            <returns> The result of elementwise adding img2 to the current image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Add(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> Elementwise add <paramref name="img2"/> with the current image, using a mask</summary>
            <param name="img2">The image to be added to the current image</param>
            <param name="mask">The mask for the add operation</param>
            <returns> The result of elementwise adding img2 to the current image, using the specific mask</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Add(`0)">
            <summary> Elementwise add a color <paramref name="val"/> to the current image</summary>
            <param name="val">The color value to be added to the current image</param>
            <returns> The result of elementwise adding color <paramref name="val"/> from the current image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Mul(Emgu.CV.Image{`0,`1},System.Double)">
            <summary> Elementwise multiply another image with the current image and the <paramref name="scale"/></summary>
            <param name="img2">The image to be elementwise multiplied to the current image</param>
            <param name="scale">The scale to be multiplied</param>
            <returns> this .* img2 * scale </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Mul(Emgu.CV.Image{`0,`1})">
            <summary> Elementwise multiply <paramref name="img2"/> with the current image</summary>
            <param name="img2">The image to be elementwise multiplied to the current image</param>
            <returns> this .* img2 </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Mul(System.Double)">
            <summary> Elementwise multiply the current image with <paramref name="scale"/></summary>
            <param name="scale">The scale to be multiplied</param>
            <returns> The scaled image </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Acc(Emgu.CV.Image{`0,`1},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Accumulate <paramref name="img2"/> to the current image using the specific mask
            </summary>
            <param name="img2">The image to be added to the current image</param>
            <param name="mask">the mask</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Acc(Emgu.CV.Image{`0,`1})">
            <summary>
            Accumulate <paramref name="img2"/> to the current image using the specific mask
            </summary>
            <param name="img2">The image to be added to the current image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.AddWeighted(Emgu.CV.Image{`0,`1},System.Double,System.Double,System.Double)">
            <summary> 
            Return the weighted sum such that: res = this * alpha + img2 * beta + gamma
            </summary>
            <param name="img2">img2 in: res = this * alpha + img2 * beta + gamma </param>
            <param name="alpha">alpha in: res = this * alpha + img2 * beta + gamma</param>
            <param name="beta">beta in: res = this * alpha + img2 * beta + gamma</param>
            <param name="gamma">gamma in: res = this * alpha + img2 * beta + gamma</param>
            <returns>this * alpha + img2 * beta + gamma</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.RunningAvg(Emgu.CV.Image{`0,`1},System.Double)">
            <summary> 
             Update Running Average. <i>this</i> = (1-alpha)*<i>this</i> + alpha*img
            </summary>
            <param name="img">Input image, 1- or 3-channel, Byte or Single (each channel of multi-channel image is processed independently). </param>
            <param name="alpha">the weight of <paramref name="img"/></param>
        </member>
        <member name="M:Emgu.CV.Image`2.RunningAvg(Emgu.CV.Image{`0,`1},System.Double,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary> 
             Update Running Average. <i>this</i> = (1-alpha)*<i>this</i> + alpha*img, using the mask
            </summary>
            <param name="img">Input image, 1- or 3-channel, Byte or Single (each channel of multi-channel image is processed independently). </param>
            <param name="alpha">The weight of <paramref name="img"/></param>
            <param name="mask">The mask for the running average</param>
        </member>
        <member name="M:Emgu.CV.Image`2.AbsDiff(Emgu.CV.Image{`0,`1})">
            <summary> 
            Computes absolute different between <i>this</i> image and the other image
            </summary>
            <param name="img2">The other image to compute absolute different with</param>
            <returns> The image that contains the absolute different value</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.AbsDiff(`0)">
            <summary> 
            Computes absolute different between <i>this</i> image and the specific color
            </summary>
            <param name="color">The color to compute absolute different with</param>
            <returns> The image that contains the absolute different value</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Pow(System.Double)">
            <summary>
            Raises every element of input array to p
            dst(I)=src(I)^p, if p is integer
            dst(I)=abs(src(I))^p, otherwise
            </summary>
            <param name="power">The exponent of power</param>
            <returns>The power image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Exp">
            <summary>
            Calculates exponent of every element of input array:
            dst(I)=exp(src(I))
            </summary>
            <remarks>Maximum relative error is ~7e-6. Currently, the function converts denormalized values to zeros on output.</remarks>
            <returns>The exponent image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Log">
            <summary>
            Calculates natural logarithm of absolute value of every element of input array
            </summary>
            <returns>Natural logarithm of absolute value of every element of input array</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Sample(Emgu.CV.Structure.LineSegment2D)">
            <summary> Sample the pixel values on the specific line segment </summary>
            <param name="line"> The line to obtain samples</param>
            <returns>The values on the (Eight-connected) line </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Sample(Emgu.CV.Structure.LineSegment2D,Emgu.CV.CvEnum.CONNECTIVITY)">
            <summary>
            Sample the pixel values on the specific line segment
            </summary>
            <param name="line">The line to obtain samples</param>
            <param name="type">The sampling type</param>
            <returns>The values on the line, the first dimension is the index of the point, the second dimension is the index of color channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Resize(System.Int32,System.Int32)">
            <summary>
            Scale the image to the specific size 
            </summary>
            <param name="width">The width of the returned image.</param>
            <param name="height">The height of the returned image.</param>
            <returns>The resized image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Resize(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Scale the image to the specific size
            </summary>
            <param name="width">The width of the returned image.</param>
            <param name="height">The height of the returned image.</param>
            <param name="preserverScale">if true, the scale is preservered and the resulting image has maximum width(height) possible that is &lt;= <paramref name="width"/> (<paramref name="height"/>), if false, this function is equaivalent to Resize(int width, int height)</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Resize(System.Double)">
            <summary>
            Scale the image to the specific size: width *= scale; height *= scale  
            </summary>
            <param name="scale">The resize scale</param>
            <returns>The scaled image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Resize(System.Int32,System.Int32,Emgu.CV.CvEnum.INTER)">
            <summary>
            Scale the image to the specific size 
            </summary>
            <param name="width">The width of the returned image.</param>
            <param name="height">The height of the returned image.</param>
            <param name="interpolationType">The type of interpolation</param>
            <returns>The resized image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Resize(System.Int32,System.Int32,Emgu.CV.CvEnum.INTER,System.Boolean)">
            <summary>
            Scale the image to the specific size
            </summary>
            <param name="width">The width of the returned image.</param>
            <param name="height">The height of the returned image.</param>
            <param name="interpolationType">The type of interpolation</param>
            <param name="preserveScale">if true, the scale is preservered and the resulting image has maximum width(height) possible that is &lt;= <paramref name="width"/> (<paramref name="height"/>), if false, this function is equaivalent to Resize(int width, int height)</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Resize(System.Double,Emgu.CV.CvEnum.INTER)">
            <summary>
            Scale the image to the specific size: width *= scale; height *= scale  
            </summary>
            <param name="scale">The scale to resize</param>
            <param name="interpolationType">The type of interpolation</param>
            <returns>The scaled image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Rotate(System.Double,`0)">
            <summary>
            Rotate the image the specified angle cropping the result to the original size
            </summary>
            <param name="angle">The angle of rotation in degrees.</param>
            <param name="background">The color with wich to fill the background</param>   
            <returns>The image rotates by the specific angle</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.WarpAffine``1(Emgu.CV.Matrix{``0},Emgu.CV.CvEnum.INTER,Emgu.CV.CvEnum.WARP,`0)">
            <summary>
            Transforms source image using the specified matrix
            </summary>
            <param name="mapMatrix">2x3 transformation matrix</param>
            <param name="interpolationType">Interpolation type</param>
            <param name="warpType">Warp type</param>
            <param name="backgroundColor">A value used to fill outliers</param>
            <returns>The result of the transformation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.WarpAffine``1(Emgu.CV.Matrix{``0},System.Int32,System.Int32,Emgu.CV.CvEnum.INTER,Emgu.CV.CvEnum.WARP,`0)">
            <summary>
            Transforms source image using the specified matrix
            </summary>
            <param name="mapMatrix">2x3 transformation matrix</param>
            <param name="width">The width of the resulting image</param>
            <param name="height">the height of the resulting image</param>
            <param name="interpolationType">Interpolation type</param>
            <param name="warpType">Warp type</param>
            <param name="backgroundColor">A value used to fill outliers</param>
            <typeparam name="TMapDepth">The depth type of <paramref name="mapMatrix"/>, should be either float or double</typeparam>
            <returns>The result of the transformation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.WarpPerspective``1(Emgu.CV.Matrix{``0},Emgu.CV.CvEnum.INTER,Emgu.CV.CvEnum.WARP,`0)">
            <summary>
            Transforms source image using the specified matrix
            </summary>
            <param name="mapMatrix">3x3 transformation matrix</param>
            <param name="interpolationType">Interpolation type</param>
            <param name="warpType">Warp type</param>
            <param name="backgroundColor">A value used to fill outliers</param>
            <typeparam name="TMapDepth">The depth type of <paramref name="mapMatrix"/>, should be either float or double</typeparam>
            <returns>The result of the transformation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.WarpPerspective``1(Emgu.CV.Matrix{``0},System.Int32,System.Int32,Emgu.CV.CvEnum.INTER,Emgu.CV.CvEnum.WARP,`0)">
            <summary>
            Transforms source image using the specified matrix
            </summary>
            <param name="mapMatrix">3x3 transformation matrix</param>
            <param name="width">The width of the resulting image</param>
            <param name="height">the height of the resulting image</param>
            <param name="interpolationType">Interpolation type</param>
            <param name="warpType">Warp type</param>
            <param name="backgroundColor">A value used to fill outliers</param>
            <typeparam name="TMapDepth">The depth type of <paramref name="mapMatrix"/>, should be either float or double</typeparam>
            <returns>The result of the transformation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Rotate(System.Double,`0,System.Boolean)">
            <summary>
            Rotate this image the specified <paramref name="angle"/>
            </summary>
            <param name="angle">The angle of rotation in degrees.</param>
            <param name="background">The color with wich to fill the background</param>
            <param name="crop">If set to true the image is cropped to its original size, possibly losing corners information. If set to false the result image has different size than original and all rotation information is preserved</param>
            <returns>The rotated image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.LogPolar(System.Drawing.PointF,System.Double,System.Int32)">
            <summary>
             Convert the image to log polar, simulating the human foveal vision
             </summary>
             <param name="center">The transformation center, where the output precision is maximal</param>
             <param name="M">Magnitude scale parameter</param>
             <param name="flags">A combination of interpolation method and the optional flag CV_WARP_FILL_OUTLIERS and/or CV_WARP_INVERSE_MAP</param>
             <returns>The converted image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``2">
            <summary> Convert the current image to the specific color and depth </summary>
            <typeparam name="TOtherColor"> The type of color to be converted to </typeparam>
            <typeparam name="TOtherDepth"> The type of pixel depth to be converted to </typeparam>
            <returns> Image of the specific color and depth </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ConvertFrom``2(Emgu.CV.Image{``0,``1})">
            <summary>
            Convert the source image to the current image, if the size are different, the current image will be a resized version of the srcImage. 
            </summary>
            <typeparam name="TSrcColor">The color type of the source image</typeparam>
            <typeparam name="TSrcDepth">The color depth of the source image</typeparam>
            <param name="srcImage">The sourceImage</param>
        </member>
        <member name="M:Emgu.CV.Image`2.ConvertScale``1(System.Double,System.Double)">
            <summary> Convert the current image to the specific depth, at the same time scale and shift the values of the pixel</summary>
            <param name="scale"> The value to be multipled with the pixel </param>
            <param name="shift"> The value to be added to the pixel</param>
             <typeparam name="TOtherDepth"> The type of depth to convert to</typeparam>
            <returns> Image of the specific depth, val = val * scale + shift </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.CopyFromBitmap(System.Drawing.Bitmap)">
            <summary>
            Utility function for Bitmap Set property
            </summary>
            <param name="bmp"></param>
        </member>
        <member name="M:Emgu.CV.Image`2.ToBitmap">
            <summary> 
            Convert this image into Bitmap, the pixel values are copied over to the Bitmap
            </summary>
            <remarks> For better performance on Image&lt;Gray, Byte&gt; and Image&lt;Bgr, Byte&gt;, consider using the Bitmap property </remarks>
            <returns> This image in Bitmap format, the pixel data are copied over to the Bitmap</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ToBitmap(System.Int32,System.Int32)">
            <summary> Create a Bitmap image of certain size</summary>
            <param name="width">The width of the bitmap</param>
            <param name="height"> The height of the bitmap</param>
            <returns> This image in Bitmap format of the specific size</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.PyrDown">
            <summary>
             Performs downsampling step of Gaussian pyramid decomposition. 
             First it convolves <i>this</i> image with the specified filter and then downsamples the image 
             by rejecting even rows and columns.
            </summary>
            <returns> The downsampled image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.PyrUp">
            <summary>
             Performs up-sampling step of Gaussian pyramid decomposition. 
             First it upsamples <i>this</i> image by injecting even zero rows and columns and then convolves 
             result with the specified filter multiplied by 4 for interpolation. 
             So the resulting image is four times larger than the source image.
            </summary>
            <returns> The upsampled image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.BuildPyramid(System.Int32)">
            <summary>
            Compute the image pyramid
            </summary>
            <param name="maxLevel">The number of level's for the pyramid; Level 0 referes to the current image, level n is computed by calling the PyrDown() function on level n-1</param>
            <returns>The image pyramid</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.InPaint(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},System.Double)">
            <summary> Use impaint to recover the intensity of the pixels which location defined by <paramref>mask</paramref> on <i>this</i> image </summary>
            <param name="mask">The inpainting mask. Non-zero pixels indicate the area that needs to be inpainted</param>
            <param name="radius">The radius of circular neighborhood of each point inpainted that is considered by the algorithm</param>
            <returns> The inpainted image </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.MorphologyEx(Emgu.CV.StructuringElementEx,Emgu.CV.CvEnum.CV_MORPH_OP,System.Int32)">
            <summary>
            Perform advanced morphological transformations using erosion and dilation as basic operations.
            </summary>
            <param name="element">Structuring element</param>
            <param name="operation">Type of morphological operation</param>
            <param name="iterations">Number of times erosion and dilation are applied</param>
            <returns>The result of the morphological operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Erode(System.Int32)">
            <summary>
            Erodes <i>this</i> image using a 3x3 rectangular structuring element.
            Erosion are applied serveral (iterations) times
            </summary>
            <param name="iterations">The number of erode iterations</param>
            <returns> The eroded image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Dilate(System.Int32)">
            <summary>
            Dilates <i>this</i> image using a 3x3 rectangular structuring element.
            Dilation are applied serveral (iterations) times
            </summary>
            <param name="iterations">The number of dilate iterations</param>
            <returns> The dialated image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2._MorphologyEx(Emgu.CV.StructuringElementEx,Emgu.CV.CvEnum.CV_MORPH_OP,System.Int32)">
            <summary>
            Perform inplace advanced morphological transformations using erosion and dilation as basic operations.
            </summary>
            <param name="element">Structuring element</param>
            <param name="operation">Type of morphological operation</param>
            <param name="iterations">Number of times erosion and dilation are applied</param>
        </member>
        <member name="M:Emgu.CV.Image`2._Erode(System.Int32)">
            <summary>
            Erodes <i>this</i> image inplace using a 3x3 rectangular structuring element.
            Erosion are applied serveral (iterations) times
            </summary>
            <param name="iterations">The number of erode iterations</param>
        </member>
        <member name="M:Emgu.CV.Image`2._Dilate(System.Int32)">
            <summary>
            Dilates <i>this</i> image inplace using a 3x3 rectangular structuring element.
            Dilation are applied serveral (iterations) times
            </summary>
            <param name="iterations">The number of dilate iterations</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Action(System.Action{`1})">
            <summary> 
            perform an generic action based on each element of the image
            </summary>
            <param name="action">The action to be applied to each element of the image</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Action``1(Emgu.CV.Image{`0,``0},System.Action{`1,``0})">
            <summary>
            Perform an generic operation based on the elements of the two images
            </summary>
            <typeparam name="TOtherDepth">The depth of the second image</typeparam>
            <param name="img2">The second image to perform action on</param>
            <param name="action">An action such that the first parameter is the a single channel of a pixel from the first image, the second parameter is the corresponding channel of the correspondind pixel from the second image </param>
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``1(System.Func{`1,System.Int32,System.Int32,``0})">
            <summary> 
            Compute the element of a new image based on the value as well as the x and y positions of each pixel on the image
            </summary> 
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``1(System.Converter{`1,``0})">
            <summary> Compute the element of the new image based on element of this image</summary> 
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``2(Emgu.CV.Image{`0,``0},System.Func{`1,``0,``1})">
            <summary> Compute the element of the new image based on the elements of the two image</summary>
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``3(Emgu.CV.Image{`0,``0},Emgu.CV.Image{`0,``1},System.Func{`1,``0,``1,``2})">
            <summary> Compute the element of the new image based on the elements of the three image</summary>
        </member>
        <member name="M:Emgu.CV.Image`2.Convert``4(Emgu.CV.Image{`0,``0},Emgu.CV.Image{`0,``1},Emgu.CV.Image{`0,``2},System.Func{`1,``0,``1,``2,``3})">
            <summary> Compute the element of the new image based on the elements of the four image</summary>
        </member>
        <member name="M:Emgu.CV.Image`2.DisposeObject">
            <summary>
            Release all unmanaged memory associate with the image
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(Emgu.CV.Image{`0,`1},Emgu.CV.Image{`0,`1})">
            <summary>
            Perform an elementwise AND operation on the two images
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="img2">The second image to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
            Perform an elementwise AND operation using an images and a color
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="val">The color to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
            Perform an elementwise AND operation using an images and a color
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="val">The color to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(Emgu.CV.Image{`0,`1},`0)">
            <summary>
            Perform an elementwise AND operation using an images and a color
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="val">The color to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseAnd(`0,Emgu.CV.Image{`0,`1})">
            <summary>
            Perform an elementwise AND operation using an images and a color
            </summary>
            <param name="img1">The first image to AND</param>
            <param name="val">The color to AND</param>
            <returns>The result of the AND operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(Emgu.CV.Image{`0,`1},Emgu.CV.Image{`0,`1})">
            <summary> Perform an elementwise OR operation with another image and return the result</summary>
            <param name="img1">The first image to apply bitwise OR operation</param>
            <param name="img2">The second image to apply bitwise OR operation</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(Emgu.CV.Image{`0,`1},System.Double)">
            <summary> 
             Perform an binary OR operation with some color
             </summary>
            <param name="img1">The image to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(System.Double,Emgu.CV.Image{`0,`1})">
            <summary> 
             Perform an binary OR operation with some color
             </summary>
            <param name="img1">The image to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(Emgu.CV.Image{`0,`1},`0)">
            <summary> 
             Perform an binary OR operation with some color
             </summary>
            <param name="img1">The image to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_BitwiseOr(`0,Emgu.CV.Image{`0,`1})">
            <summary> 
             Perform an binary OR operation with some color
             </summary>
            <param name="img1">The image to OR</param>
            <param name="val"> The color to OR</param>
            <returns> The result of the OR operation</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_OnesComplement(Emgu.CV.Image{`0,`1})">
            <summary>Compute the complement image</summary>
            <param name="image">The image to be inverted</param>
            <returns>The complement image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(Emgu.CV.Image{`0,`1},Emgu.CV.Image{`0,`1})">
            <summary>
            Elementwise add <paramref name="img1"/> with <paramref name="img2"/>
            </summary>
            <param name="img1">The first image to be added</param>
            <param name="img2">The second image to be added</param>
            <returns>The sum of the two images</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
            Elementwise add <paramref name="img1"/> with <paramref name="val"/>
            </summary>
            <param name="img1">The image to be added</param>
            <param name="val">The value to be added</param>
            <returns>The images plus the color</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
            Elementwise add <paramref name="image"/> with <paramref name="value"/>
            </summary>
            <param name="image">The image to be added</param>
            <param name="value">The value to be added</param>
            <returns>The images plus the color</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(Emgu.CV.Image{`0,`1},`0)">
            <summary>
            Elementwise add <paramref name="image"/> with <paramref name="value"/>
            </summary>
            <param name="image">The image to be added</param>
            <param name="value">The color to be added</param>
            <returns>The images plus the color</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Addition(`0,Emgu.CV.Image{`0,`1})">
            <summary>
            Elementwise add <paramref name="image"/> with <paramref name="value"/>
            </summary>
            <param name="image">The image to be added</param>
            <param name="value">The color to be added</param>
            <returns>The images plus the color</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(Emgu.CV.Image{`0,`1},Emgu.CV.Image{`0,`1})">
            <summary>
            Elementwise subtract another image from the current image
            </summary>
            <param name="image1">The image to be substracted</param>
            <param name="image2">The second image to be subtraced from <paramref name="image1"/></param>
            <returns> The result of elementwise subtracting img2 from <paramref name="image1"/> </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(Emgu.CV.Image{`0,`1},`0)">
            <summary>
            Elementwise subtract another image from the current image
            </summary>
            <param name="image">The image to be substracted</param>
            <param name="value">The color to be subtracted</param>
            <returns> The result of elementwise subtracting <paramred name="val"/> from <paramref name="image"/> </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(`0,Emgu.CV.Image{`0,`1})">
            <summary>
            Elementwise subtract another image from the current image
            </summary>
            <param name="image">The image to be substracted</param>
            <param name="value">The color to be subtracted</param>
            <returns> <paramred name="val"/> - <paramref name="image"/> </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
            <paramred name="val"/> - <paramref name="image"/>
            </summary>
            <param name="image">The image to be substracted</param>
            <param name="value">The value to be subtracted</param>
            <returns> <paramred name="val"/> - <paramref name="image"/> </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Subtraction(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
            Elementwise subtract another image from the current image
            </summary>
            <param name="image">The image to be substracted</param>
            <param name="value">The value to be subtracted</param>
            <returns> <paramref name="image"/> - <paramred name="val"/>   </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Multiply(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
             <paramref name="image"/> * <paramref name="scale"/>
            </summary>
            <param name="image">The image</param>
            <param name="scale">The multiplication scale</param>
            <returns><paramref name="image"/> * <paramref name="scale"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Multiply(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
              <paramref name="scale"/>*<paramref name="image"/>
            </summary>
            <param name="image">The image</param>
            <param name="scale">The multiplication scale</param>
            <returns><paramref name="scale"/>*<paramref name="image"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Multiply(Emgu.CV.Image{`0,`1},Emgu.CV.ConvolutionKernelF)">
            <summary>
            Perform the convolution with <paramref name="kernel"/> on <paramref name="image"/>
            </summary>
            <param name="image">The image</param>
            <param name="kernel">The kernel</param>
            <returns>Result of the convolution</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Division(Emgu.CV.Image{`0,`1},System.Double)">
            <summary>
             <paramref name="image"/> / <paramref name="scale"/>
            </summary>
            <param name="image">The image</param>
            <param name="scale">The division scale</param>
            <returns><paramref name="image"/> / <paramref name="scale"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.op_Division(System.Double,Emgu.CV.Image{`0,`1})">
            <summary>
              <paramref name="scale"/> / <paramref name="image"/>
            </summary>
            <param name="image">The image</param>
            <param name="scale">The scale</param>
            <returns><paramref name="scale"/> / <paramref name="image"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SmoothBlur(System.Int32,System.Int32)">
            <summary>
            Summation over a pixel param1 x param2 neighborhood with subsequent scaling by 1/(param1 x param2)
            </summary>
            <param name="width">The width of the window</param>
            <param name="height">The height of the window</param>
            <returns>The result of blur</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SmoothBlur(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Summation over a pixel param1 x param2 neighborhood. If scale is true, the result is subsequent scaled by 1/(param1 x param2)
            </summary>
            <param name="width">The width of the window</param>
            <param name="height">The height of the window</param>
            <param name="scale">If true, the result is subsequent scaled by 1/(param1 x param2)</param>
            <returns>The result of blur</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SmoothMedian(System.Int32)">
            <summary>
            Finding median of <paramref name="size"/>x<paramref name="size"/> neighborhood 
            </summary>
            <param name="size">The size (width &amp; height) of the window</param>
            <returns>The result of mediam smooth</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SmoothBilatral(System.Int32,System.Int32,System.Int32)">
            <summary>
            Applying bilateral 3x3 filtering
            </summary>
            <param name="colorSigma">Color sigma</param>
            <param name="spaceSigma">Space sigma</param>
            <param name="kernelSize">The size of the bilatral kernel</param>
            <returns>The result of bilateral smooth</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SmoothGaussian(System.Int32)">
            <summary> Perform Gaussian Smoothing in the current image and return the result </summary>
            <param name="kernelSize"> The size of the Gaussian kernel (<paramref name="kernelSize"/> x <paramref name="kernelSize"/>)</param>
            <returns> The smoothed image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.SmoothGaussian(System.Int32,System.Int32,System.Double,System.Double)">
            <summary> Perform Gaussian Smoothing in the current image and return the result </summary>
            <param name="kernelWidth"> The width of the Gaussian kernel</param>
            <param name="kernelHeight"> The height of the Gaussian kernel</param>
            <param name="sigma1"> The standard deviation of the Gaussian kernel in the horizontal dimwnsion</param>
            <param name="sigma2"> The standard deviation of the Gaussian kernel in the vertical dimwnsion</param>
            <returns> The smoothed image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2._SmoothGaussian(System.Int32)">
            <summary> Perform Gaussian Smoothing inplace for the current image </summary>
            <param name="kernelSize"> The size of the Gaussian kernel (<paramref name="kernelSize"/> x <paramref name="kernelSize"/>)</param>
        </member>
        <member name="M:Emgu.CV.Image`2._SmoothGaussian(System.Int32,System.Int32,System.Double,System.Double)">
            <summary> Perform Gaussian Smoothing inplace for the current image </summary>
            <param name="kernelWidth"> The width of the Gaussian kernel</param>
            <param name="kernelHeight"> The height of the Gaussian kernel</param>
            <param name="sigma1"> The standard deviation of the Gaussian kernel in the horizontal dimwnsion</param>
            <param name="sigma2"> The standard deviation of the Gaussian kernel in the vertical dimwnsion</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Convolution(Emgu.CV.ConvolutionKernelF)">
            <summary> 
            Performs a convolution using the specific <paramref name="kernel"/> 
            </summary>
            <param name="kernel">The convolution kernel</param>
            <returns>The result of the convolution</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Integral">
            <summary>
            Calculates integral images for the source image
            </summary>
            <returns>The integral image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Integral(Emgu.CV.Image{`0,System.Double}@,Emgu.CV.Image{`0,System.Double}@)">
            <summary>
            Calculates integral images for the source image
            </summary>
            <param name="sum">The integral image</param>
            <param name="squareSum">The integral image for squared pixel values</param>
            <returns>The integral image</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Integral(Emgu.CV.Image{`0,System.Double}@,Emgu.CV.Image{`0,System.Double}@,Emgu.CV.Image{`0,System.Double}@)">
            <summary>
            Calculates one or more integral images for the source image
            </summary>
            <param name="sum">The integral image</param>
            <param name="squareSum">The integral image for squared pixel values</param>
            <param name="titledSum">The integral for the image rotated by 45 degrees</param>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdBase(Emgu.CV.Image{`0,`1},`0,`0,Emgu.CV.CvEnum.THRESH)">
            <summary> 
            the base threshold method shared by public threshold functions 
            </summary>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdToZero(`0)">
            <summary> Threshold the image such that: dst(x,y) = src(x,y), if src(x,y)>threshold;  0, otherwise </summary>
            <param name="threshold">The threshold value</param>
            <returns> dst(x,y) = src(x,y), if src(x,y)>threshold;  0, otherwise </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdToZeroInv(`0)">
            <summary> 
            Threshold the image such that: dst(x,y) = 0, if src(x,y)>threshold;  src(x,y), otherwise 
            </summary>
            <param name="threshold">The threshold value</param>
            <returns>The image such that: dst(x,y) = 0, if src(x,y)>threshold;  src(x,y), otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdTrunc(`0)">
            <summary>
            Threshold the image such that: dst(x,y) = threshold, if src(x,y)>threshold; src(x,y), otherwise 
            </summary>
            <param name="threshold">The threshold value</param>
            <returns>The image such that: dst(x,y) = threshold, if src(x,y)>threshold; src(x,y), otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdBinary(`0,`0)">
            <summary> 
            Threshold the image such that: dst(x,y) = max_value, if src(x,y)>threshold; 0, otherwise 
            </summary>
            <returns>The image such that: dst(x,y) = max_value, if src(x,y)>threshold; 0, otherwise </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ThresholdBinaryInv(`0,`0)">
            <summary> Threshold the image such that: dst(x,y) = 0, if src(x,y)>threshold;  max_value, otherwise </summary>
            <param name="threshold">The threshold value</param>
            <param name="maxValue">The maximum value of the pixel on the result</param>
            <returns>The image such that: dst(x,y) = 0, if src(x,y)>threshold;  max_value, otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdToZero(`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = src(x,y), if src(x,y)>threshold;  0, otherwise </summary>
            <param name="threshold">The threshold value</param>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdToZeroInv(`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = 0, if src(x,y)>threshold;  src(x,y), otherwise </summary>
            <param name="threshold">The threshold value</param>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdTrunc(`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = threshold, if src(x,y)>threshold; src(x,y), otherwise </summary>
            <param name="threshold">The threshold value</param>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdBinary(`0,`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = max_value, if src(x,y)>threshold; 0, otherwise </summary>
            <param name="threshold">The threshold value</param>
            <param name="maxValue">The maximum value of the pixel on the result</param>
        </member>
        <member name="M:Emgu.CV.Image`2._ThresholdBinaryInv(`0,`0)">
            <summary> Threshold the image inplace such that: dst(x,y) = 0, if src(x,y)>threshold;  max_value, otherwise </summary>
            <param name="threshold">The threshold value</param>
            <param name="maxValue">The maximum value of the pixel on the result</param>
        </member>
        <member name="M:Emgu.CV.Image`2.AvgSdv(`0@,Emgu.CV.Structure.MCvScalar@,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Calculates the average value and standard deviation of array elements, independently for each channel
            </summary>
            <param name="average">The avg color</param>
            <param name="sdv">The standard deviation for each channel</param>
            <param name="mask">The operation mask</param>
        </member>
        <member name="M:Emgu.CV.Image`2.AvgSdv(`0@,Emgu.CV.Structure.MCvScalar@)">
            <summary>
            Calculates the average value and standard deviation of array elements, independently for each channel
            </summary>
            <param name="avg">The avg color</param>
            <param name="sdv">The standard deviation for each channel</param>
        </member>
        <member name="M:Emgu.CV.Image`2.CountNonzero">
            <summary>
            Count the non Zero elements for each channel
            </summary>
            <returns>Count the non Zero elements for each channel</returns>
        </member>
        <member name="M:Emgu.CV.Image`2.MinMax(System.Double[]@,System.Double[]@,System.Drawing.Point[]@,System.Drawing.Point[]@)">
            <summary>
            Returns the min / max location and values for the image
            </summary>
            <param name="maxLocations">The maximum locations for each channel </param>
            <param name="maxValues">The maximum values for each channel</param>
            <param name="minLocations">The minimum locations for each channel</param>
            <param name="minValues">The minimum values for each channel</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Flip(Emgu.CV.CvEnum.FLIP)">
            <summary> Return a filpped copy of the current image</summary>
            <param name="flipType">The type of the flipping</param>
            <returns> The flipped copy of <i>this</i> image </returns>
        </member>
        <member name="M:Emgu.CV.Image`2._Flip(Emgu.CV.CvEnum.FLIP)">
            <summary> Inplace flip the image</summary>
            <param name="flipType">The type of the flipping</param>
            <returns> The flipped copy of <i>this</i> image </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ConcateVertical(Emgu.CV.Image{`0,`1})">
            <summary>
            Concate the current image with another image vertically.
            </summary>
            <param name="otherImage">The other image to concate</param>
            <returns>A new image that is the vertical concatening of this image and <paramref name="otherImage"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.ConcateHorizontal(Emgu.CV.Image{`0,`1})">
            <summary>
            Concate the current image with another image horizontally. 
            </summary>
            <param name="otherImage">The other image to concate</param>
            <returns>A new image that is the horizontal concatening of this image and <paramref name="otherImage"/></returns>
        </member>
        <member name="M:Emgu.CV.Image`2.GetMoments(System.Boolean)">
            <summary>
            Calculates spatial and central moments up to the third order and writes them to moments. The moments may be used then to calculate gravity center of the shape, its area, main axises and various shape characeteristics including 7 Hu invariants.
            </summary>
            <param name="binary">If the flag is true, all the zero pixel values are treated as zeroes, all the others are treated as 1's</param>
            <returns>spatial and central moments up to the third order</returns>
        </member>
        <member name="M:Emgu.CV.Image`2._GammaCorrect(System.Double)">
            <summary>
            Gamma correct this image inplace. The image must have a depth type of Byte.
            </summary>
            <param name="gamma">The gamma value</param>
        </member>
        <member name="M:Emgu.CV.Image`2.Split">
            <summary> 
            Split current Image into an array of gray scale images where each element 
            in the array represent a single color channel of the original image
            </summary>
            <returns> 
            An array of gray scale images where each element  
            in the array represent a single color channel of the original image 
            </returns>
        </member>
        <member name="M:Emgu.CV.Image`2.Save(System.String)">
            <summary>
            Save this image to the specific file
            </summary>
            <param name="fileName">The name of the file to be saved to</param>
        </member>
        <member name="M:Emgu.CV.Image`2._EqualizeHist">
            <summary>
            The algorithm inplace normalizes brightness and increases contrast of the image.
            For color images, a HSV representation of the image is first obtained and the V (value) channel is histogram normalized
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.Data">
            <summary>
            Get or Set the data for this matrix. The Get function has O(1) complexity. The Set function make a copy of the data
            </summary>
            <remarks>
            If the image contains Byte and width is not a multiple of 4. The second dimension of the array might be larger than the Width of this image.  
            This is necessary since the length of a row need to be 4 align for OpenCV optimization. 
            The Set function always make a copy of the specific value. If the image contains Byte and width is not a multiple of 4. The second dimension of the array created might be larger than the Width of this image.  
            </remarks>
        </member>
        <member name="P:Emgu.CV.Image`2.MIplImage">
            <summary>
            The IplImage structure
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.ROI">
            <summary> 
             Get or Set the region of interest for this image. To clear the ROI, set it to System.Drawing.Rectangle.Empty
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.NumberOfChannels">
            <summary>
            Get the number of channels for this image
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.ManagedArray">
            <summary>
            Get the underneath managed array
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.CvDepth">
            <summary>
            Get the equivalent opencv depth type for this image
            </summary>
        </member>
        <member name="P:Emgu.CV.Image`2.IsROISet">
            <summary> 
            Indicates if the region of interest has been set
            </summary> 
        </member>
        <member name="P:Emgu.CV.Image`2.Item(System.Int32)">
            <summary>
            Get or Set the specific channel of the current image. 
            For Get operation, a copy of the specific channel is returned.
            For Set operation, the specific channel is copied to this image.
            </summary>
            <param name="channel">The channel to get from the current image, zero based index</param>
            <returns>The specific channel of the current image</returns>
        </member>
        <member name="P:Emgu.CV.Image`2.Item(System.Int32,System.Int32)">
            <summary>
            Get or Set the color in the <paramref name="row"/>th row (y direction) and <paramref name="column"/>th column (x direction)
            </summary>
            <param name="row">The zero-based row (y direction) of the pixel </param>
            <param name="col">The zero-based column (x direction) of the pixel</param>
            <returns>The color in the specific <paramref name="row"/> and <paramref name="column"/></returns>
        </member>
        <member name="P:Emgu.CV.Image`2.Item(System.Drawing.Point)">
            <summary>
            Get or Set the color in the <paramref name="location"/>
            </summary>
            <param name="location">the location of the pixel </param>
            <returns>the color in the <paramref name="location"/></returns>
        </member>
        <member name="P:Emgu.CV.Image`2.Bitmap">
            <summary>
            The Get property provide a more efficient way to convert Image&lt;Gray, Byte&gt;, Image&lt;Bgr, Byte&gt; and Image&lt;Bgra, Byte&gt; into Bitmap
            such that the image data is <b>shared</b> with Bitmap. 
            If you change the pixel value on the Bitmap, you change the pixel values on the Image object as well!
            For other types of image this property has the same effect as ToBitmap()
            <b>Take extra caution not to use the Bitmap after the Image object is disposed</b>
            The Set property convert the bitmap to this Image type.
            </summary>
        </member>
        <member name="T:Emgu.CV.ColorConversionCodeLookupTable">
            <summary>
            A cached color conversion code lookup table
            </summary>
        </member>
        <member name="T:Emgu.CV.ImageConstants">
            <summary>
            Constants used by the image class
            </summary>
        </member>
        <member name="F:Emgu.CV.ImageConstants.RoiOffset">
            <summary>
            Offset of roi
            </summary>
        </member>
        <member name="T:Emgu.CV.ImageFeature">
            <summary>
            An ImageFeature contains a keypoint and its descriptor
            </summary>
        </member>
        <member name="P:Emgu.CV.ImageFeature.Descriptor">
            <summary>
            The descriptor to the keypoint
            </summary>
        </member>
        <member name="P:Emgu.CV.ImageFeature.KeyPoint">
            <summary>
            The keypoint
            </summary>
        </member>
        <member name="T:Emgu.CV.Kalman">
            <summary>
            Kalman Filter 
            </summary>
        </member>
        <member name="M:Emgu.CV.Kalman.#ctor(Emgu.CV.Matrix{System.Single},Emgu.CV.Matrix{System.Single},Emgu.CV.Matrix{System.Single},Emgu.CV.Matrix{System.Single},Emgu.CV.Matrix{System.Single},Emgu.CV.Matrix{System.Single})">
            <summary>
            Create a Kalman Filter using the specific values
            </summary>
            <param name="initialState">The m x 1 matrix</param>
            <param name="transitionMatrix">The m x m matrix (A) </param>
            <param name="controlMatrix">The m x n matrix (B)</param>
            <param name="measurementMatrix">The n x m matrix (H)</param>
            <param name="processNoiseCovarianceMatrix">The n x n matrix (Q)</param>
            <param name="measurementNoiseCovarianceMatrix">The m x m matrix (R)</param>
        </member>
        <member name="M:Emgu.CV.Kalman.#ctor(Emgu.CV.Matrix{System.Single},Emgu.CV.Matrix{System.Single},Emgu.CV.Matrix{System.Single},Emgu.CV.Matrix{System.Single},Emgu.CV.Matrix{System.Single})">
            <summary>
            Create a Kalman Filter using the specific values
            </summary>
            <param name="initialState">The m x 1 matrix</param>
            <param name="transitionMatrix">The m x m matrix (A) </param>
            <param name="measurementMatrix">The n x m matrix (H)</param>
            <param name="processNoiseCovarianceMatrix">The n x n matrix (Q)</param>
            <param name="measurementNoiseCovarianceMatrix">The m x m matrix (R)</param>
        </member>
        <member name="M:Emgu.CV.Kalman.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Allocates CvKalman and all its matrices and initializes them somehow. 
            </summary>
            <param name="dynamParams">dimensionality of the state vector</param>
            <param name="measureParams">dimensionality of the measurement vector </param>
            <param name="controlParams">dimensionality of the control vector </param>
        </member>
        <member name="M:Emgu.CV.Kalman.Predict(Emgu.CV.Matrix{System.Single})">
            <summary>
            Estimates the subsequent stochastic model state by its current state and stores it at PredictedState
            </summary>
            <param name="control">the control vector</param>
            <returns>The predicted state</returns>
        </member>
        <member name="M:Emgu.CV.Kalman.Correct(Emgu.CV.Matrix{System.Single})">
            <summary>
            Adjusts stochastic model state on the basis of the given measurement of the model state
            </summary>
            <remarks>The function stores adjusted state at kalman->state_post and returns it on output</remarks>
            <param name="measurement">The measurement data</param>
            <returns>The corrected state</returns>
        </member>
        <member name="M:Emgu.CV.Kalman.Predict">
            <summary>
            Estimates the subsequent stochastic model state by its current state
            </summary>
            <returns>The predicted state</returns>
        </member>
        <member name="M:Emgu.CV.Kalman.DisposeObject">
            <summary>
            Release unmanaged resource
            </summary>
        </member>
        <member name="M:Emgu.CV.Kalman.ReleaseManagedResources">
            <summary>
            Release all the matrix associated to this object
            </summary>
        </member>
        <member name="P:Emgu.CV.Kalman.MCvKalman">
            <summary>
            Get the MCvKalman structure
            </summary>
        </member>
        <member name="P:Emgu.CV.Kalman.PredictedState">
            <summary>
            Get or Set the Predicted State
            </summary>
        </member>
        <member name="P:Emgu.CV.Kalman.CorrectedState">
            <summary>
            Get or Set the Corrected State
            </summary>
        </member>
        <member name="P:Emgu.CV.Kalman.MeasurementMatrix">
            <summary>
            Get or Set the measurement matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Kalman.TransitionMatrix">
            <summary>
            Get or Set the state transition matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Kalman.ProcessNoiseCovariance">
            <summary>
            Get or Set the process noise covariance matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Kalman.MeasurementNoiseCovariance">
            <summary>
            Get or Set the measurement noise covariance matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Kalman.ErrorCovariancePost">
            <summary>
            Get or Set the posteriori error estimate covariance matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Kalman.ErrorCovariancePre">
            <summary>
            Get or Set the prior error convariance matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.Kalman.ControlMatrix">
            <summary>
            Get or Set the control matrix 
            </summary>
        </member>
        <member name="P:Emgu.CV.Kalman.Gain">
            <summary>
            Get or Set the Kalman Gain
            </summary>
        </member>
        <member name="T:Emgu.CV.LDetector">
            <summary>
            V. Lepetit keypoint detector
            </summary>
        </member>
        <member name="F:Emgu.CV.LDetector.Radius">
            <summary>
            Radius
            </summary>
        </member>
        <member name="F:Emgu.CV.LDetector.Threshold">
            <summary>
            Threshold
            </summary>
        </member>
        <member name="F:Emgu.CV.LDetector.NOctaves">
            <summary>
            Number of Octaves
            </summary>
        </member>
        <member name="F:Emgu.CV.LDetector.NViews">
            <summary>
            Number of views
            </summary>
        </member>
        <member name="F:Emgu.CV.LDetector.Verbose">
            <summary>
            Verbose
            </summary>
        </member>
        <member name="F:Emgu.CV.LDetector.BaseFeatureSize">
            <summary>
            Base feature size
            </summary>
        </member>
        <member name="F:Emgu.CV.LDetector.ClusteringDistance">
            <summary>
            Clustering Distance
            </summary>
        </member>
        <member name="M:Emgu.CV.LDetector.SetDefaultParameters">
            <summary>
            Set the parameters to default value
            </summary>
        </member>
        <member name="M:Emgu.CV.LDetector.DetectKeyPoints(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},System.Int32,System.Boolean)">
            <summary>
            Detect the Lepetit keypoints from the image
            </summary>
            <param name="image">The image to extract Lepetit keypoints</param>
            <param name="maxCount">The maximum number of keypoints to be extracted</param>
            <param name="scaleCoords">Indicates if the coordinates should be scaled</param>
            <returns>The array of Lepetit keypoints</returns>
        </member>
        <member name="T:Emgu.CV.Map`2">
            <summary>
            A Map is similar to an Image, except that the location of the pixels is defined by 
            its area and resolution
            </summary>
            <typeparam name="TColor">The color of this map</typeparam>
            <typeparam name="TDepth">The depth of this map</typeparam>
        </member>
        <member name="M:Emgu.CV.Map`2.#ctor(System.Drawing.RectangleF,System.Drawing.PointF,`0)">
            <summary>
            Create a new Image Map defined by the Rectangle area. The center (0.0, 0.0) of this map is 
            defined by the center of the rectangle.
            </summary>
            <param name="area"></param>
            <param name="resolution">The resolution of x (y), (e.g. a value of 0.5 means each cell in the map is 0.5 unit in x (y) dimension)</param>
            <param name="color"> The initial color of the map</param>
        </member>
        <member name="M:Emgu.CV.Map`2.#ctor(System.Drawing.RectangleF,System.Drawing.PointF)">
            <summary>
            Create a new Image Map defined by the Rectangle area. The center (0.0, 0.0) of this map is 
            defined by the center of the rectangle. The initial value of the map is 0.0
            </summary>
            <param name="area"></param>
            <param name="resolution">The resolution of x (y), (e.g. a value of 0.5 means each cell in the map is 0.5 unit in x (y) dimension)</param>
        </member>
        <member name="M:Emgu.CV.Map`2.MapPointToImagePoint(Emgu.CV.Structure.MCvPoint2D64f)">
            <summary>
            Map a point to a position in the internal image
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Map`2.MapPointToImagePoint(System.Drawing.PointF)">
            <summary>
            Map a point to a position in the internal image
            </summary>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Map`2.ImagePointToMapPoint(System.Drawing.Point)">
            <summary>
            Map an image point to a Map point
            </summary>
            <param name="pt">The point on image</param>
            <returns>The point on map</returns>
        </member>
        <member name="M:Emgu.CV.Map`2.Copy(System.Drawing.RectangleF)">
            <summary>
            Get a copy of the map in the specific area
            </summary>
            <param name="area">the area of the map to be retrieve</param>
            <returns>The area of the map</returns>
        </member>
        <member name="M:Emgu.CV.Map`2.Draw(System.Drawing.RectangleF,`0,System.Int32)">
            <summary>
            Draw a rectangle in the map
            </summary>
            <param name="rect">The rectangle to draw</param>
            <param name="color">The color for the rectangle</param>
            <param name="thickness">The thickness of the rectangle, any value less than or equal to 0 will result in a filled rectangle</param>
        </member>
        <member name="M:Emgu.CV.Map`2.Draw(Emgu.CV.Structure.LineSegment2DF,`0,System.Int32)">
            <summary>
            Draw a line segment in the map
            </summary>
            <param name="line">The line to be draw</param>
            <param name="color">The color for the line</param>
            <param name="thickness">The thickness of the line</param>
        </member>
        <member name="M:Emgu.CV.Map`2.Draw(Emgu.CV.Structure.CircleF,`0,System.Int32)">
            <summary> Draw a Circle of the specific color and thickness </summary>
            <param name="circle"> The circle to be drawn</param>
            <param name="color"> The color of the circle </param>
            <param name="thickness"> If thickness is less than 1, the circle is filled up </param>
        </member>
        <member name="M:Emgu.CV.Map`2.Draw(Emgu.CV.IConvexPolygonF,`0,System.Int32)">
            <summary> Draw a convex polygon of the specific color and thickness </summary>
            <param name="polygon"> The convex polygon to be drawn</param>
            <param name="color"> The color of the convex polygon </param>
            <param name="thickness"> If thickness is less than 1, the triangle is filled up </param>
        </member>
        <member name="M:Emgu.CV.Map`2.Draw(System.String,Emgu.CV.Structure.MCvFont@,System.Drawing.PointF,`0)">
            <summary>
            Draw the text using the specific font on the image
            </summary>
            <param name="message">The text message to be draw</param>
            <param name="font">The font used for drawing</param>
            <param name="bottomLeft">The location of the bottom left corner of the font</param>
            <param name="color">The color of the text</param>
        </member>
        <member name="M:Emgu.CV.Map`2.DrawPolyline(System.Drawing.PointF[],System.Boolean,`0,System.Int32)">
            <summary>
            Draw the polyline defined by the array of 2D points
            </summary>
            <param name="pts">the points that defines the poly line</param>
            <param name="isClosed">if true, the last line segment is defined by the last point of the array and the first point of the array</param>
            <param name="color">the color used for drawing</param>
            <param name="thickness">the thinkness of the line</param>
        </member>
        <member name="M:Emgu.CV.Map`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.Map`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serilization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">streaming context</param>
        </member>
        <member name="P:Emgu.CV.Map`2.Area">
            <summary>
            Get the area of this map as a rectangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Map`2.Resolution">
            <summary>
            Get the resolution of this map as a 2D point
            </summary>
        </member>
        <member name="P:Emgu.CV.Map`2.ROI">
            <summary> 
             Get or Set the region of interest for this map. To clear the ROI, set it to System.Drawing.RectangleF.Empty
            </summary>
        </member>
        <member name="T:Emgu.CV.MatND`1">
            <summary>
            A MatND is a wrapper to cvMatND of OpenCV. 
            </summary>
            <typeparam name="TDepth">The type of depth</typeparam>
        </member>
        <member name="M:Emgu.CV.MatND`1.#ctor(System.Int32[])">
            <summary>
            Create a N-dimensional matrix 
            </summary>
            <param name="sizes">The size for each dimension</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Constructor used to deserialize runtime serialized object
            </summary>
            <param name="info">The serialization info</param>
            <param name="context">The streaming context</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.AllocateData(System.Int32,System.Int32,System.Int32)">
            <summary>
            This function is not implemented for MatND
            </summary>
            <param name="rows">Not implemented</param>
            <param name="cols">Not implemented</param>
            <param name="numberOfChannels">Not implemented</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.DisposeObject">
            <summary>
            Release the matrix and all the memory associate with it
            </summary>
        </member>
        <member name="M:Emgu.CV.MatND`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime serilization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.DeserializeObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            A function used for runtime deserailization of the object
            </summary>
            <param name="info">Serialization info</param>
            <param name="context">Streaming context</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.ReadXml(System.Xml.XmlReader)">
            <summary>
            Not Implemented
            </summary>
            <param name="reader">The XmlReader</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.WriteXml(System.Xml.XmlWriter)">
            <summary>
            Not Implemented
            </summary>
            <param name="writer">The XmlWriter</param>
        </member>
        <member name="M:Emgu.CV.MatND`1.Convert``1">
            <summary>
            Convert this matrix to different depth
            </summary>
            <typeparam name="TOtherDepth">The depth type to convert to</typeparam>
            <returns>Matrix of different depth</returns>
        </member>
        <member name="M:Emgu.CV.MatND`1.Equals(Emgu.CV.MatND{`0})">
            <summary>
            Check if the two MatND are equal
            </summary>
            <param name="other">The other MatND to compares to</param>
            <returns>True if the two MatND equals</returns>
        </member>
        <member name="P:Emgu.CV.MatND`1.NumberOfChannels">
            <summary>
            This function is not implemented for MatND
            </summary>
        </member>
        <member name="P:Emgu.CV.MatND`1.ManagedArray">
            <summary>
            Get the underneath managed array
            </summary>
        </member>
        <member name="P:Emgu.CV.MatND`1.CvDepth">
            <summary> Get the depth representation for openCV</summary>
        </member>
        <member name="P:Emgu.CV.MatND`1.MCvMatND">
            <summary>
            The MCvMatND structure
            </summary>
        </member>
        <member name="T:Emgu.CV.MemStorage">
            <summary>
            A MemStorage is a wrapper to cvMemStorage of OpenCV. 
            </summary>
        </member>
        <member name="M:Emgu.CV.MemStorage.#ctor">
            <summary>
            Create a OpenCV MemStorage
            </summary>
        </member>
        <member name="M:Emgu.CV.MemStorage.Clear">
            <summary>
            Resets the top (free space boundary) of the storage to the very beginning. This function does not deallocate any memory. If the storage has a parent, the function returns all blocks to the parent
            </summary>
        </member>
        <member name="M:Emgu.CV.MemStorage.CreateChildMemStorage">
            <summary>
            Creates a child memory storage that is similar to simple memory storage except for the differences in the memory allocation/deallocation mechanism. When a child storage needs a new block to add to the block list, it tries to get this block from the parent. The first unoccupied parent block available is taken and excluded from the parent block list. If no blocks are available, the parent either allocates a block or borrows one from its own parent, if any. In other words, the chain, or a more complex structure, of memory storages where every storage is a child/parent of another is possible. When a child storage is released or even cleared, it returns all blocks to the parent. In other aspects, the child storage is the same as the simple storage
            </summary>
            <returns>Child MemStorage</returns>
        </member>
        <member name="M:Emgu.CV.MemStorage.DisposeObject">
            <summary>
            Release the storage
            </summary>
        </member>
        <member name="T:Emgu.CV.MotionHistory">
            <summary>
            The motion history class
            </summary>
            <remarks>
            For help on using this class, take a look at the Motion Detection example
            </remarks>
        </member>
        <member name="M:Emgu.CV.MotionHistory.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Create a motion history object
            </summary>
            <param name="mhiDuration">In second, the duration of motion history you wants to keep</param>
            <param name="maxTimeDelta">In second. Any change happens between a time interval greater than this will not be considerred</param>
            <param name="minTimeDelta">In second. Any change happens between a time interval smaller than this will not be considerred.</param>
        </member>
        <member name="M:Emgu.CV.MotionHistory.#ctor(System.Double,System.Double,System.Double,System.DateTime)">
            <summary>
            Create a motion history object
            </summary>
            <param name="mhiDuration">In second, the duration of motion history you wants to keep</param>
            <param name="maxTimeDelta">In second. Any change happens between a time interval larger than this will not be considerred</param>
            <param name="minTimeDelta">In second. Any change happens between a time interval smaller than this will not be considerred.</param>
            <param name="startTime">The start time of the motion history</param>
        </member>
        <member name="M:Emgu.CV.MotionHistory.Update(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Update the motion history with the specific image and current timestamp
            </summary>
            <param name="image">The image to be added to history</param>
        </member>
        <member name="M:Emgu.CV.MotionHistory.Update(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},System.DateTime)">
            <summary>
            Update the motion history with the specific image and the specific timestamp
            </summary>
            <param name="forgroundMask">The forground of the image to be added to history</param>
            <param name="timestamp">The time when the image is captured</param>
        </member>
        <member name="M:Emgu.CV.MotionHistory.GetMotionComponents(Emgu.CV.MemStorage)">
            <summary>
            Get a sequence of motion component
            </summary>
            <param name="storage">The storage used by the motion components</param>
            <returns>A sequence of motion components</returns>
        </member>
        <member name="M:Emgu.CV.MotionHistory.MotionInfo(System.Drawing.Rectangle,System.Double@,System.Double@)">
            <summary>
            Given a rectagle area of the motion, output the angle of the motion and the number of pixels that are considered to be motion pixel 
            </summary>
            <param name="motionRectangle">The rectangle area of the motion</param>
            <param name="angle">The orientation of the motion</param>
            <param name="motionPixelCount">Number of motion pixels within silhoute ROI</param>
        </member>
        <member name="M:Emgu.CV.MotionHistory.DisposeObject">
            <summary>
            Release unmanaged resources
            </summary>
        </member>
        <member name="M:Emgu.CV.MotionHistory.ReleaseManagedResources">
            <summary>
            Release any images associated with this object
            </summary>
        </member>
        <member name="P:Emgu.CV.MotionHistory.SegmentMask">
            <summary>
            The Motion Segment Mask. 
            Same as the seg_mask in cvSegmentMotion function
            Do not dispose this image.
            </summary>
        </member>
        <member name="P:Emgu.CV.MotionHistory.Mask">
            <summary>
            The motion mask. 
            Do not dispose this image.
            </summary>
        </member>
        <member name="T:Emgu.CV.Octree">
            <summary>
            Oct-Tree
            </summary>
        </member>
        <member name="M:Emgu.CV.Octree.#ctor">
            <summary>
            Create an empty Oct-Tree
            </summary>
        </member>
        <member name="M:Emgu.CV.Octree.#ctor(Emgu.CV.Structure.MCvPoint3D32f[],System.Int32,System.Int32)">
            <summary>
            Create an Oct-Tree from the given points
            </summary>
            <param name="points">The points to be inserted into the Oct-Tree</param>
            <param name="maxLevels">The maximum levels of the Oct-Tree</param>
            <param name="minPoints">The minimum number of points in each level</param>
        </member>
        <member name="M:Emgu.CV.Octree.BuildTree(Emgu.CV.Structure.MCvPoint3D32f[],System.Int32,System.Int32)">
            <summary>
            Build an Oct-Tree from the given points
            </summary>
            <param name="points">The points to be inserted into the Oct-Tree</param>
            <param name="maxLevels">The maximum levels of the Oct-Tree</param>
            <param name="minPoints">The minimum number of points in each level</param>
        </member>
        <member name="M:Emgu.CV.Octree.GetPointsWithinSphere(Emgu.CV.Structure.MCvPoint3D32f,System.Single)">
            <summary>
            Get the points within the specific sphere
            </summary>
            <param name="center">The center of the sphere</param>
            <param name="radius">The radius of the sphere</param>
            <returns>The points withing the specific sphere</returns>
        </member>
        <member name="M:Emgu.CV.Octree.ReleaseManagedResources">
            <summary>
            Release the managed memory associated with this Oct Tree
            </summary>
        </member>
        <member name="M:Emgu.CV.Octree.DisposeObject">
            <summary>
            Release the Oct Tree
            </summary>
        </member>
        <member name="T:Emgu.CV.OpticalFlow">
            <summary>
            Contains a collection of optical flow methods
            </summary>
        </member>
        <member name="M:Emgu.CV.OpticalFlow.PyrLK(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},System.Drawing.PointF[],System.Drawing.Size,System.Int32,Emgu.CV.Structure.MCvTermCriteria,System.Drawing.PointF[]@,System.Byte[]@,System.Single[]@)">
            <summary>
            Calculates optical flow for a sparse feature set using iterative Lucas-Kanade method in pyramids
            </summary>
            <param name="prev">First frame, at time t</param>
            <param name="curr">Second frame, at time t + dt </param>
            <param name="prevFeatures">Array of points for which the flow needs to be found</param>
            <param name="winSize">Size of the search window of each pyramid level</param>
            <param name="level">Maximal pyramid level number. If 0 , pyramids are not used (single level), if 1 , two levels are used, etc</param>
            <param name="criteria">Specifies when the iteration process of finding the flow for each point on each pyramid level should be stopped</param>
            <param name="currFeatures">Array of 2D points containing calculated new positions of input features in the second image</param>
            <param name="status">Array. Every element of the array is set to 1 if the flow for the corresponding feature has been found, 0 otherwise</param>
            <param name="trackError">Array of double numbers containing difference between patches around the original and moved points</param>
        </member>
        <member name="M:Emgu.CV.OpticalFlow.PyrLK(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},System.Drawing.PointF[],System.Drawing.Size,System.Int32,Emgu.CV.Structure.MCvTermCriteria,Emgu.CV.CvEnum.LKFLOW_TYPE,System.Drawing.PointF[]@,System.Byte[]@,System.Single[]@)">
            <summary>
            Calculates optical flow for a sparse feature set using iterative Lucas-Kanade method in pyramids
            </summary>
            <param name="prev">First frame, at time t</param>
            <param name="curr">Second frame, at time t + dt </param>
            <param name="prevPyrBuffer">Buffer for the pyramid for the first frame. If it is not NULL, the buffer must have a sufficient size to store the pyramid from level 1 to level #level ; the total size of (image_width+8)*image_height/3 bytes is sufficient</param>
            <param name="currPyrBuffer">Similar to prev_pyr, used for the second frame</param>
            <param name="prevFeatures">Array of points for which the flow needs to be found</param>
            <param name="winSize">Size of the search window of each pyramid level</param>
            <param name="level">Maximal pyramid level number. If 0 , pyramids are not used (single level), if 1 , two levels are used, etc</param>
            <param name="criteria">Specifies when the iteration process of finding the flow for each point on each pyramid level should be stopped</param>
            <param name="flags">Flags</param>
            <param name="currFeatures">Array of 2D points containing calculated new positions of input features in the second image</param>
            <param name="status">Array. Every element of the array is set to 1 if the flow for the corresponding feature has been found, 0 otherwise</param>
            <param name="trackError">Array of double numbers containing difference between patches around the original and moved points</param>
        </member>
        <member name="M:Emgu.CV.OpticalFlow.LK(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},System.Drawing.Size,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Single},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Single})">
            <summary>
            Computes flow for every pixel of the first input image using Lucas &amp; Kanade algorithm
            </summary>
            <param name="prev">First image</param>
            <param name="curr">Second image</param>
            <param name="winSize">Size of the averaging window used for grouping pixels</param>
            <param name="velx">Horizontal component of the optical flow of the same size as input images</param>
            <param name="vely">Vertical component of the optical flow of the same size as input images</param>
        </member>
        <member name="M:Emgu.CV.OpticalFlow.HS(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},System.Boolean,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Single},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Single},System.Double,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Computes flow for every pixel of the first input image using Horn &amp; Schunck algorithm 
            </summary>
            <param name="prev">First image, 8-bit, single-channel</param>
            <param name="curr">Second image, 8-bit, single-channel</param>
            <param name="usePrevious">Uses previous (input) velocity field</param>
            <param name="velx">Horizontal component of the optical flow of the same size as input images, 32-bit floating-point, single-channel</param>
            <param name="vely">Vertical component of the optical flow of the same size as input images, 32-bit floating-point, single-channel</param>
            <param name="lambda">Lagrangian multiplier</param>
            <param name="criteria">Criteria of termination of velocity computing</param>
        </member>
        <member name="M:Emgu.CV.OpticalFlow.BM(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},System.Drawing.Size,System.Drawing.Size,System.Drawing.Size,System.Boolean,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Single},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Single})">
            <summary>
            Calculates optical flow for overlapped blocks block_size.width * block_size.height pixels each, thus the velocity fields are smaller than the original images. 
            For every block in prev the functions tries to find a similar block in curr in some neighborhood of the original block or shifted by (velx(x0,y0),vely(x0,y0)) block as has been calculated by previous function call (if use_previous)
            </summary>
            <param name="prev">First image</param>
            <param name="curr">Second image</param>
            <param name="blockSize">Size of basic blocks that are compared.</param>
            <param name="shiftSize">Block coordinate increments. </param>
            <param name="maxRange">Size of the scanned neighborhood in pixels around block.</param>
            <param name="usePrevious">Uses previous (input) velocity field. </param>
            <param name="velx">Horizontal component of the optical flow of floor((prev->width - block_size.width)/shiftSize.width) x floor((prev->height - block_size.height)/shiftSize.height) size. </param>
            <param name="vely">Vertical component of the optical flow of the same size velx.</param>
        </member>
        <member name="M:Emgu.CV.OpticalFlow.Farneback(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Single},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Single},System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,Emgu.CV.CvEnum.OPTICALFLOW_FARNEBACK_FLAG)">
            <summary>
            Computes dense optical flow using Gunnar Farneback's algorithm
            </summary>
            <param name="prev0">The first 8-bit single-channel input image</param>
            <param name="next0">The second input image of the same size and the same type as prevImg</param>
            <param name="flowX">The computed flow image for x-velocity; will have the same size as prevImg</param>
            <param name="flowY">The computed flow image for y-velocity; will have the same size as prevImg</param>
            <param name="pyrScale">Specifies the image scale (!1) to build the pyramids for each image. pyrScale=0.5 means the classical pyramid, where each next layer is twice smaller than the previous</param>
            <param name="levels">The number of pyramid layers, including the initial image. levels=1 means that no extra layers are created and only the original images are used</param>
            <param name="winSize">The averaging window size; The larger values increase the algorithm robustness to image noise and give more chances for fast motion detection, but yield more blurred motion field</param>
            <param name="iterations">The number of iterations the algorithm does at each pyramid level</param>
            <param name="polyN">Size of the pixel neighborhood used to find polynomial expansion in each pixel. The larger values mean that the image will be approximated with smoother surfaces, yielding more robust algorithm and more blurred motion field. Typically, poly n=5 or 7</param>
            <param name="polySigma">Standard deviation of the Gaussian that is used to smooth derivatives that are used as a basis for the polynomial expansion. For poly n=5 you can set poly sigma=1.1, for poly n=7 a good value would be poly sigma=1.5</param>
            <param name="flags">The operation flags</param>
        </member>
        <member name="T:Emgu.CV.PatchGenerator">
            <summary>
            OpenCV's PatchGenerator
            </summary>
        </member>
        <member name="F:Emgu.CV.PatchGenerator.BackgroundMin">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.PatchGenerator.BackgroundMax">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.PatchGenerator.NoiseRange">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.PatchGenerator.RandomBlur">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.PatchGenerator.LambdaMin">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.PatchGenerator.LambdaMax">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.PatchGenerator.ThetaMin">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.PatchGenerator.ThetaMax">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.PatchGenerator.PhiMin">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.PatchGenerator.PhiMax">
            <summary>
            
            </summary>
        </member>
        <member name="M:Emgu.CV.PatchGenerator.SetDefaultParameters">
            <summary>
            Set the parameters to default value
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.NORM_TYPE">
            <summary>
            Type for cvNorm
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NORM_TYPE.CV_C">
            <summary>
            if arr2 is NULL, norm = ||arr1||_C = max_I abs(arr1(I));
            if arr2 is not NULL, norm = ||arr1-arr2||_C = max_I abs(arr1(I)-arr2(I))
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NORM_TYPE.CV_L1">
            <summary>
            if arr2 is NULL, norm = ||arr1||_L1 = sum_I abs(arr1(I));
            if arr2 is not NULL, norm = ||arr1-arr2||_L1 = sum_I abs(arr1(I)-arr2(I))
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NORM_TYPE.CV_L2">
            <summary>
            if arr2 is NULL, norm = ||arr1||_L2 = sqrt( sum_I arr1(I)^2);
            if arr2 is not NULL, norm = ||arr1-arr2||_L2 = sqrt( sum_I (arr1(I)-arr2(I))^2 )
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NORM_TYPE.CV_NORM_MASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NORM_TYPE.CV_RELATIVE">
            <summary>
            It is used in combination with either CV_C, CV_L1 or CV_L2
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NORM_TYPE.CV_DIFF">
            <summary>
            It is used in combination with either CV_C, CV_L1 or CV_L2
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NORM_TYPE.CV_MINMAX">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NORM_TYPE.CV_DIFF_C">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NORM_TYPE.CV_DIFF_L1">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NORM_TYPE.CV_DIFF_L2">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NORM_TYPE.CV_RELATIVE_C">
            <summary>
            norm = ||arr1-arr2||_C/||arr2||_C
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NORM_TYPE.CV_RELATIVE_L1">
            <summary>
            norm = ||arr1-arr2||_L1/||arr2||_L1
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.NORM_TYPE.CV_RELATIVE_L2">
            <summary>
            norm = ||arr1-arr2||_L2/||arr2||_L2
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.REDUCE_TYPE">
            <summary>
            Type used for cvReduce function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.REDUCE_TYPE.CV_REDUCE_SUM">
            <summary>
            The output is the sum of all the matrix rows/columns
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.REDUCE_TYPE.CV_REDUCE_AVG">
            <summary>
            The output is the mean vector of all the matrix rows/columns
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.REDUCE_TYPE.CV_REDUCE_MAX">
            <summary>
            The output is the maximum (column/row-wise) of all the matrix rows/columns
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.REDUCE_TYPE.CV_REDUCE_MIN">
            <summary>
            The output is the minimum (column/row-wise) of all the matrix rows/columns
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.REDUCE_DIMENSION">
            <summary>
            Type used for cvReduce function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.REDUCE_DIMENSION.SINGLE_ROW">
            <summary>
            The matrix is reduced to a single row
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.REDUCE_DIMENSION.SINGLE_COL">
            <summary>
            The matrix is reduced to a single column
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.REDUCE_DIMENSION.AUTO">
            <summary>
            The dimension is chosen automatically by analysing the dst size
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CMP_TYPE">
            <summary>
            Type used for cvCmp function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CMP_TYPE.CV_CMP_EQ">
            <summary>
            src1(I) "equal to" src2(I)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CMP_TYPE.CV_CMP_GT">
            <summary>
            src1(I) "greater than" src2(I)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CMP_TYPE.CV_CMP_GE">
            <summary>
            src1(I) "greater or equal" src2(I)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CMP_TYPE.CV_CMP_LT">
            <summary>
            src1(I) "less than" src2(I)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CMP_TYPE.CV_CMP_LE">
            <summary>
            src1(I) "less or equal" src2(I)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CMP_TYPE.CV_CMP_NE">
            <summary>
            src1(I) "not equal to" src2(I)
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.APPROX_POLY_TYPE">
            <summary>
            Polygon approximation type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.APPROX_POLY_TYPE.CV_POLY_APPROX_DP">
            <summary>
            Douglas-Peucker algorithm
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CAP_PROP">
            <summary>
            CV Capture property identifier
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_POS_MSEC">
            <summary>
            film current position in milliseconds or video capture timestamp
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_POS_FRAMES">
            <summary>
            0-based index of the frame to be decoded/captured next
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_POS_AVI_RATIO">
            <summary>
            position in relative units (0 - start of the file, 1 - end of the file)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_FRAME_WIDTH">
            <summary>
            width of frames in the video stream
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_FRAME_HEIGHT">
            <summary>
            height of frames in the video stream
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_FPS">
            <summary>
            frame rate 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_FOURCC">
            <summary>
            4-character code of codec
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_FRAME_COUNT">
            <summary>
            number of frames in video file
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_FORMAT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_MODE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_BRIGHTNESS">
            <summary>
            Brightness
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_CONTRAST">
            <summary>
            Contrast
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_SATURATION">
            <summary>
            Saturation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_HUE">
            <summary>
            Hue
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_GAIN">
            <summary>
            Gain
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CAP_PROP.CV_CAP_PROP_CONVERT_RGB">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CHAIN_APPROX_METHOD">
            <summary>
            contour approximation method
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CHAIN_APPROX_METHOD.CV_CHAIN_CODE">
            <summary>
            output contours in the Freeman chain code. All other methods output polygons (sequences of vertices). 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CHAIN_APPROX_METHOD.CV_CHAIN_APPROX_NONE">
            <summary>
            translate all the points from the chain code into points;
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CHAIN_APPROX_METHOD.CV_CHAIN_APPROX_SIMPLE">
            <summary>
            compress horizontal, vertical, and diagonal segments, that is, the function leaves only their ending points; 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CHAIN_APPROX_METHOD.CV_CHAIN_APPROX_TC89_L1">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CHAIN_APPROX_METHOD.CV_CHAIN_APPROX_TC89_KCOS">
            <summary>
            apply one of the flavors of Teh-Chin chain approximation algorithm
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CHAIN_APPROX_METHOD.CV_LINK_RUNS">
            <summary>
            use completely different contour retrieval algorithm via linking of horizontal segments of 1s. Only CV_RETR_LIST retrieval mode can be used with this method
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.COLOR_CONVERSION">
            <summary>
            Color Conversion code
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR2BGRA">
            <summary>
            Convert BGR color to BGRA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGRA2BGR">
            <summary>
            Convert BGRA color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR2GRAY">
            <summary>
            Convert BGR color to GRAY color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_GRAY2BGR">
            <summary>
            Convert GRAY color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_GRAY2BGRA">
            <summary>
            Convert GRAY color to BGRA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGRA2GRAY">
            <summary>
            Convert BGRA color to GRAY color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR2BGR565">
            <summary>
            Convert BGR color to BGR565 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR5652BGR">
            <summary>
            Convert BGR565 color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGRA2BGR565">
            <summary>
            Convert BGRA color to BGR565 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR5652BGRA">
            <summary>
            Convert BGR565 color to BGRA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_GRAY2BGR565">
            <summary>
            Convert GRAY color to BGR565 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR5652GRAY">
            <summary>
            Convert BGR565 color to GRAY color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR2BGR555">
            <summary>
            Convert BGR color to BGR555 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR5552BGR">
            <summary>
            Convert BGR555 color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGRA2BGR555">
            <summary>
            Convert BGRA color to BGR555 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR5552BGRA">
            <summary>
            Convert BGR555 color to BGRA color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_GRAY2BGR555">
            <summary>
            Convert GRAY color to BGR555 color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR5552GRAY">
            <summary>
            Convert BGR555 color to GRAY color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR2XYZ">
            <summary>
            Convert BGR color to XYZ color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_XYZ2BGR">
            <summary>
            Convert XYZ color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR2YCrCb">
            <summary>
            Convert BGR color to YCrCb color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_YCrCb2BGR">
            <summary>
            Convert YCrCb color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR2HSV">
            <summary>
            Convert BGR color to HSV color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR2Lab">
            <summary>
            Convert BGR color to Lab color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BayerBG2BGR">
            <summary>
            Convert BayerBG color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BayerGB2BGR">
            <summary>
            Convert BayerGB color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BayerRG2BGR">
            <summary>
            Convert BayerRG color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BayerGR2BGR">
            <summary>
            Convert BayerGR color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR2Luv">
            <summary>
            Convert BGR color to Luv color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_BGR2HLS">
            <summary>
            Convert BGR color to HLS color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_HSV2BGR">
            <summary>
            Convert HSV color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_Lab2BGR">
            <summary>
            Convert Lab color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_Luv2BGR">
            <summary>
            Convert Luv color to BGR color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COLOR_CONVERSION.CV_HLS2BGR">
            <summary>
            Convert HLS color to BGR color
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.FILTER_TYPE">
            <summary>
            Type for cvPyrUp(cvPryDown)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FILTER_TYPE.CV_GAUSSIAN_5x5">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.FONT">
            <summary>
            Fonts
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FONT.CV_FONT_HERSHEY_SIMPLEX">
            <summary>
            HERSHEY_SIMPLEX
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FONT.CV_FONT_HERSHEY_PLAIN">
            <summary>
            HERSHEY_PLAIN
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FONT.CV_FONT_HERSHEY_DUPLEX">
            <summary>
            HERSHEY_DUPLEX
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FONT.CV_FONT_HERSHEY_COMPLEX">
            <summary>
            HERSHEY_COMPLEX
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FONT.CV_FONT_HERSHEY_TRIPLEX">
            <summary>
            HERSHEY_TRIPLEX
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FONT.CV_FONT_HERSHEY_COMPLEX_SMALL">
            <summary>
            HERSHEY_COMPLEX_SMALL
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FONT.CV_FONT_HERSHEY_SCRIPT_SIMPLEX">
            <summary>
            HERSHEY_SCRIPT_SIMPLEX
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FONT.CV_FONT_HERSHEY_SCRIPT_COMPLEX">
            <summary>
            HERSHEY_SCRIPT_COMPLEX
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.GEMM_TYPE">
            <summary>
            Flags used for cvGEMM function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GEMM_TYPE.CV_GEMM_DEFAULT">
            <summary>
            Do not apply transpose to neither matrices
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GEMM_TYPE.CV_GEMM_A_T">
            <summary>
            transpose src1
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GEMM_TYPE.CV_GEMM_B_T">
            <summary>
            transpose src2
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GEMM_TYPE.CV_GEMM_C_T">
            <summary>
            transpose src3
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.HOUGH_TYPE">
            <summary>
            Hough detection type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HOUGH_TYPE.CV_HOUGH_STANDARD">
            <summary>
            Classical or standard Hough transform. Every line is represented by two floating-point numbers (rho, theta), where rho is a distance between (0,0) point and the line, and theta is the angle between x-axis and the normal to the line. Thus, the matrix must be (the created sequence will be) of CV_32FC2 type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HOUGH_TYPE.CV_HOUGH_PROBABILISTIC">
            <summary>
            Probabilistic Hough transform (more efficient in case if picture contains a few long linear segments). It returns line segments rather than the whole lines. Every segment is represented by starting and ending points, and the matrix must be (the created sequence will be) of CV_32SC4 type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HOUGH_TYPE.CV_HOUGH_MULTI_SCALE">
            <summary>
            Multi-scale variant of classical Hough transform. The lines are encoded the same way as in CV_HOUGH_STANDARD
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HOUGH_TYPE.CV_HOUGH_GRADIENT">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.INPAINT_TYPE">
            <summary>
            Inpaint type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.INPAINT_TYPE.CV_INPAINT_NS">
            <summary>
            Navier-Stokes based method.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.INPAINT_TYPE.CV_INPAINT_TELEA">
            <summary>
            The method by Alexandru Telea 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.INTER">
            <summary>
            Types for CvResize
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.INTER.CV_INTER_NN">
            <summary>
            Nearest-neighbor interpolation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.INTER.CV_INTER_LINEAR">
            <summary>
            Bilinear interpolation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.INTER.CV_INTER_CUBIC">
            <summary>
            resampling using pixel area relation. It is the preferred method for image decimation that gives moire-free results. In case of zooming it is similar to CV_INTER_NN method
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.INTER.CV_INTER_AREA">
            <summary>
            Bicubic interpolation
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SMOOTH_TYPE">
            <summary>
            Interpolation type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SMOOTH_TYPE.CV_BLUR_NO_SCALE">
            <summary>
            (simple blur with no scaling) - summation over a pixel param1xparam2 neighborhood. If the neighborhood size may vary, one may precompute integral image with cvIntegral function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SMOOTH_TYPE.CV_BLUR">
            <summary>
            (simple blur) - summation over a pixel param1xparam2 neighborhood with subsequent scaling by 1/(param1xparam2). 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SMOOTH_TYPE.CV_GAUSSIAN">
            <summary>
            (gaussian blur) - convolving image with param1xparam2 Gaussian kernel. 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SMOOTH_TYPE.CV_MEDIAN">
            <summary>
            (median blur) - finding median of param1xparam1 neighborhood (i.e. the neighborhood is square). 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SMOOTH_TYPE.CV_BILATERAL">
            <summary>
            (bilateral filter) - applying bilateral 3x3 filtering with color sigma=param1 and space sigma=param2. Information about bilateral filtering can be found 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.LOAD_IMAGE_TYPE">
            <summary>
            cvLoadImage type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LOAD_IMAGE_TYPE.CV_LOAD_IMAGE_UNCHANGED">
            <summary>
            8bit, color or not 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LOAD_IMAGE_TYPE.CV_LOAD_IMAGE_GRAYSCALE">
            <summary>
            8bit, gray
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LOAD_IMAGE_TYPE.CV_LOAD_IMAGE_COLOR">
            <summary>
            ?, color
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LOAD_IMAGE_TYPE.CV_LOAD_IMAGE_ANYDEPTH">
            <summary>
            any depth, ?
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LOAD_IMAGE_TYPE.CV_LOAD_IMAGE_ANYCOLOR">
            <summary>
            ?, any color
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.MAT_DEPTH">
            <summary>
            Type of matrix depth
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MAT_DEPTH.CV_8U">
            <summary>
            8bit unsigned
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MAT_DEPTH.CV_8S">
            <summary>
            8bit signed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MAT_DEPTH.CV_16U">
            <summary>
            16bit unsigned
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MAT_DEPTH.CV_16S">
            <summary>
            16bit signed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MAT_DEPTH.CV_32S">
            <summary>
            32bit signed 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MAT_DEPTH.CV_32F">
            <summary>
            32bit float
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MAT_DEPTH.CV_64F">
            <summary>
            64bit
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.RAND_TYPE">
            <summary>
            CV_RAND TYPE
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RAND_TYPE.CV_RAND_UNI">
            <summary>
            Uniform distribution
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RAND_TYPE.CV_RAND_NORMAL">
            <summary>
            Normal distribution
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.RETR_TYPE">
            <summary>
            contour retrieval mode
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RETR_TYPE.CV_RETR_EXTERNAL">
            <summary>
            retrive only the extreme outer contours 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RETR_TYPE.CV_RETR_LIST">
            <summary>
             retrieve all the contours and puts them in the list 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RETR_TYPE.CV_RETR_CCOMP">
            <summary>
            retrieve all the contours and organizes them into two-level hierarchy: top level are external boundaries of the components, second level are bounda boundaries of the holes 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.RETR_TYPE.CV_RETR_TREE">
            <summary>
            retrieve all the contours and reconstructs the full hierarchy of nested contours 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqConst.CV_SEQ_ELTYPE_BITS">
            <summary>
            The bit to shift for SEQ_ELTYPE
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqConst.CV_SEQ_ELTYPE_MASK">
            <summary>
            The mask of CV_SEQ_ELTYPE
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqConst.CV_SEQ_KIND_BITS">
            <summary>
            The bits to shift for SEQ_KIND
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SeqConst.CV_SEQ_FLAG_SHIFT">
            <summary>
            The bits to shift for SEQ_FLAG
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SEQ_ELTYPE">
            <summary>
            CV_SEQ_ELTYPE
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_ELTYPE.CV_SEQ_ELTYPE_POINT">
            <summary>
              (x,y) 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_ELTYPE.CV_SEQ_ELTYPE_CODE">
            <summary>  
            freeman code: 0..7 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_ELTYPE.CV_SEQ_ELTYPE_GENERIC">
            <summary>  
            unspecified type of sequence elements 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_ELTYPE.CV_SEQ_ELTYPE_PTR">
            <summary>  
            =6 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_ELTYPE.CV_SEQ_ELTYPE_PPOINT">
            <summary>  
            pointer to element of other sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_ELTYPE.CV_SEQ_ELTYPE_INDEX">
            <summary>  
            index of element of some other sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_ELTYPE.CV_SEQ_ELTYPE_GRAPH_EDGE">
            <summary>  
            next_o, next_d, vtx_o, vtx_d 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_ELTYPE.CV_SEQ_ELTYPE_GRAPH_VERTEX">
            <summary>  
            first_edge, (x,y) 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_ELTYPE.CV_SEQ_ELTYPE_TRIAN_ATR">
            <summary>  
            vertex of the binary tree   
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_ELTYPE.CV_SEQ_ELTYPE_CONNECTED_COMP">
            <summary>  
            connected component  
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_ELTYPE.CV_SEQ_ELTYPE_POINT3D">
            <summary>  
            (x,y,z)  
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SEQ_KIND">
            <summary>
            The kind of sequence available
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_KIND.CV_SEQ_KIND_GENERIC">
            <summary>
            generic (unspecified) kind of sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_KIND.CV_SEQ_KIND_CURVE">
            <summary>
            dense sequence subtypes 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_KIND.CV_SEQ_KIND_BIN_TREE">
            <summary>
            dense sequence subtypes 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_KIND.CV_SEQ_KIND_GRAPH">
            <summary>
            sparse sequence (or set) subtypes 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_KIND.CV_SEQ_KIND_SUBDIV2D">
            <summary>
            sparse sequence (or set) subtypes 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SEQ_FLAG">
            <summary>
            Sequence flag
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_FLAG.CV_SEQ_FLAG_CLOSED">
            <summary>
            close sequence
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_FLAG.CV_SEQ_FLAG_SIMPLE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_FLAG.CV_SEQ_FLAG_CONVEX">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_FLAG.CV_SEQ_FLAG_HOLE">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SEQ_TYPE">
            <summary>
            Sequence type for point sets
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_TYPE.CV_SEQ_POINT_SET">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_TYPE.CV_SEQ_POINT3D_SET">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_TYPE.CV_SEQ_POLYLINE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_TYPE.CV_SEQ_POLYGON">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SEQ_TYPE.CV_SEQ_SIMPLE_POLYGON">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.TERMCRIT">
            <summary>
            CV_TERMCRIT
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TERMCRIT.CV_TERMCRIT_ITER">
            <summary>
            Iteration
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TERMCRIT.CV_TERMCRIT_EPS">
            <summary>
            Epsilon
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.THRESH">
            <summary>
            Types of thresholding 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.THRESH.CV_THRESH_BINARY">
            <summary>
            value = value > threshold ? max_value : 0
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.THRESH.CV_THRESH_BINARY_INV">
            <summary>
             value = value > threshold ? 0 : max_value       
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.THRESH.CV_THRESH_TRUNC">
            <summary>
             value = value > threshold ? threshold : value   
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.THRESH.CV_THRESH_TOZERO">
            <summary>
             value = value > threshold ? value : 0           
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.THRESH.CV_THRESH_TOZERO_INV">
            <summary>
             value = value > threshold ? 0 : value           
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.THRESH.CV_THRESH_MASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.THRESH.CV_THRESH_OTSU">
            <summary>
             use Otsu algorithm to choose the optimal threshold value;
             combine the flag with one of the above CV_THRESH_* values 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.TM_TYPE">
            <summary>
            Methods for comparing two array
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TM_TYPE.CV_TM_SQDIFF">
            <summary>
            R(x,y)=sumx',y'[T(x',y')-I(x+x',y+y')]2
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TM_TYPE.CV_TM_SQDIFF_NORMED">
            <summary>
            R(x,y)=sumx',y'[T(x',y')-I(x+x',y+y')]2/sqrt[sumx',y'T(x',y')2 sumx',y'I(x+x',y+y')2]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TM_TYPE.CV_TM_CCORR">
            <summary>
            R(x,y)=sumx',y'[T(x',y') I(x+x',y+y')]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TM_TYPE.CV_TM_CCORR_NORMED">
            <summary>
            R(x,y)=sumx',y'[T(x',y') I(x+x',y+y')]/sqrt[sumx',y'T(x',y')2 sumx',y'I(x+x',y+y')2]
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TM_TYPE.CV_TM_CCOEFF">
            <summary>
            R(x,y)=sumx',y'[T'(x',y') I'(x+x',y+y')],
            where T'(x',y')=T(x',y') - 1/(wxh) sumx",y"T(x",y")
               I'(x+x',y+y')=I(x+x',y+y') - 1/(wxh) sumx",y"I(x+x",y+y")
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.TM_TYPE.CV_TM_CCOEFF_NORMED">
            <summary>
            R(x,y)=sumx',y'[T'(x',y') I'(x+x',y+y')]/sqrt[sumx',y'T'(x',y')2 sumx',y'I'(x+x',y+y')2]
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.IPL_DEPTH">
            <summary>
            IPL_DEPTH
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_SIGN">
            <summary>
            indicates if the value is signed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_1U">
            <summary>
            1bit unsigned
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_8U">
            <summary>
            8bit unsigned (Byte)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_16U">
            <summary>
            16bit unsigned
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_32F">
            <summary>
            32bit float (Single)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_8S">
            <summary>
            8bit signed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_16S">
            <summary>
            16bit signed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_32S">
            <summary>
            32bit signed 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.IPL_DEPTH.IPL_DEPTH_64F">
            <summary>
            double
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.FLIP">
            <summary>
            Enumeration used by cvFlip
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FLIP.NONE">
            <summary>
            No flipping
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FLIP.HORIZONTAL">
            <summary>
            Flip horizontally
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FLIP.VERTICAL">
            <summary>
            Flip vertically
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CHECK_TYPE">
            <summary>
            Enumeration used by cvCheckArr
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CHECK_TYPE.CHECK_NAN_INFINITY">
            <summary>
            Checks that every element is neigther NaN nor Infinity
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CHECK_TYPE.CHECK_RANGE">
            <summary>
            If set, the function checks that every value of array is within [minVal,maxVal) range, otherwise it just checks that every element is neigther NaN nor Infinity
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CHECK_TYPE.CHECK_QUIET">
            <summary>
            If set, the function does not raises an error if an element is invalid or out of range
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.FLOODFILL_FLAG">
            <summary>
            Type of floodfill operation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FLOODFILL_FLAG.DEFAULT">
            <summary>
            The default type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FLOODFILL_FLAG.FIXED_RANGE">
            <summary>
            If set the difference between the current pixel and seed pixel is considered,
            otherwise difference between neighbor pixels is considered (the range is floating).
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FLOODFILL_FLAG.MASK_ONLY">
            <summary>
            If set, the function does not fill the image (new_val is ignored),
            but the fills mask (that must be non-NULL in this case).
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CONNECTIVITY">
            <summary>
            The type for cvSampleLine
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CONNECTIVITY.EIGHT_CONNECTED">
            <summary>
            8-connected
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CONNECTIVITY.FOUR_CONNECTED">
            <summary>
            4-connected
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.LINE_TYPE">
            <summary>
            The type of line for drawing
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LINE_TYPE.EIGHT_CONNECTED">
            <summary>
            8-connected
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LINE_TYPE.FOUR_CONNECTED">
            <summary>
            4-connected
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LINE_TYPE.CV_AA">
            <summary>
            Antialias
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.DIST_TYPE">
            <summary>
            Defines for Distance Transform
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DIST_TYPE.CV_DIST_USER">
            <summary>
              User defined distance 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DIST_TYPE.CV_DIST_L1">
            <summary>
              distance = |x1-x2| + |y1-y2| 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DIST_TYPE.CV_DIST_L2">
            <summary>
              Simple euclidean distance 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DIST_TYPE.CV_DIST_C">
            <summary>
              distance = max(|x1-x2|,|y1-y2|) 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DIST_TYPE.CV_DIST_L12">
            <summary>
              L1-L2 metric: distance = 2(sqrt(1+x*x/2) - 1)) 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DIST_TYPE.CV_DIST_FAIR">
            <summary>
              distance = c^2(|x|/c-log(1+|x|/c)), c = 1.3998 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DIST_TYPE.CV_DIST_WELSCH">
            <summary>
              distance = c^2/2(1-exp(-(x/c)^2)), c = 2.9846 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.DIST_TYPE.CV_DIST_HUBER">
            <summary>
              distance = |x|&lt;c ? x^2/2 : c(|x|-c/2), c=1.345 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.MUL_SPECTRUMS_TYPE">
            <summary>
            The types for cvMulSpectrums
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MUL_SPECTRUMS_TYPE.DEFAULT">
            <summary>
            The default type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MUL_SPECTRUMS_TYPE.CV_DXT_ROWS">
            <summary>
            Do forward or inverse transform of every individual row of the input matrix. This flag allows user to transform multiple vectors simultaneously and can be used to decrease the overhead (which is sometimes several times larger than the processing itself), to do 3D and higher-dimensional transforms etc
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MUL_SPECTRUMS_TYPE.CV_DXT_MUL_CONJ">
            <summary>
            Conjugate the second argument of cvMulSpectrums
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CV_DXT">
            <summary>
            Flag used for cvDFT
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_DXT.CV_DXT_FORWARD">
            <summary>
             do forward 1D or 2D transform. The result is not scaled
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_DXT.CV_DXT_INVERSE">
            <summary>
            do inverse 1D or 2D transform. The result is not scaled. CV_DXT_FORWARD and CV_DXT_INVERSE are mutually exclusive, of course
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_DXT.CV_DXT_SCALE">
            <summary>
            scale the result: divide it by the number of array elements. Usually, it is combined with CV_DXT_INVERSE, and one may use a shortcut 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_DXT.CV_DXT_ROWS">
            <summary>
            do forward or inverse transform of every individual row of the input matrix. This flag allows user to transform multiple vectors simultaneously and can be used to decrease the overhead (which is sometimes several times larger than the processing itself), to do 3D and higher-dimensional transforms etc
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_DXT.CV_DXT_INV_SCALE">
            <summary>
            Inverse and scale
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CV_DCT_TYPE">
            <summary>
            Flag used for cvDCT
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_DCT_TYPE.CV_DXT_FORWARD">
            <summary>
             do forward 1D or 2D transform. The result is not scaled
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_DCT_TYPE.CV_DXT_INVERSE">
            <summary>
            do inverse 1D or 2D transform. The result is not scaled. CV_DXT_FORWARD and CV_DXT_INVERSE are mutually exclusive, of course
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_DCT_TYPE.CV_DXT_ROWS">
            <summary>
            do forward or inverse transform of every individual row of the input matrix. This flag allows user to transform multiple vectors simultaneously and can be used to decrease the overhead (which is sometimes several times larger than the processing itself), to do 3D and higher-dimensional transforms etc
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CV_FM">
            <summary>
            Calculates fundamental matrix given a set of corresponding points
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_FM.CV_FM_7POINT">
            <summary>
            for 7-point algorithm. N == 7
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_FM.CV_FM_8POINT">
            <summary>
            for 8-point algorithm. N >= 8
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_FM.CV_FM_LMEDS_ONLY">
            <summary>
            for LMedS algorithm. N >= 8
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_FM.CV_FM_RANSAC_ONLY">
            <summary>
            for RANSAC algorithm. N >= 8
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_FM.CV_FM_LMEDS">
            <summary>
            CV_FM_LMEDS_ONLY | CV_FM_8POINT
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_FM.CV_FM_RANSAC">
            <summary>
            CV_FM_RANSAC_ONLY | CV_FM_8POINT
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.GENERAL">
            <summary>
            General enumeration
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GENERAL.CV_MAX_DIM">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GENERAL.CV_SEQ_MAGIC_VAL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GENERAL.CV_SET_MAGIC_VAL">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ERROR_CODES">
            <summary>
             Error codes
             </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSOK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSBACKTRACE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSERROR">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSINTERNAL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSNOMEM">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSBADARG">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSBADFUNC">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSNOCONV">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSAUTOTRACE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_HEADERISNULL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADIMAGESIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADOFFSET">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADDATAPTR">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADSTEP">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADMODELORCHSEQ">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADNUMCHANNELS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADNUMCHANNEL1U">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADDEPTH">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADALPHACHANNEL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADORDER">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADORIGIN">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADALIGN">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADCALLBACK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADTILESIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADCOI">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_BADROISIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_MASKISTILED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSNULLPTR">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSVECLENGTHERR">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSFILTERSTRUCTCONTENTERR">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSKERNELSTRUCTCONTENTERR">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSFILTEROFFSETERR">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSBADSIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSDIVBYZERO">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSINPLACENOTSUPPORTED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSOBJECTNOTFOUND">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSUNMATCHEDFORMATS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSBADFLAG">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSBADPOINT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSBADMASK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSUNMATCHEDSIZES">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSUNSUPPORTEDFORMAT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSOUTOFRANGE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSPARSEERROR">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSNOTIMPLEMENTED">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ERROR_CODES.CV_STSBADMEMBLOCK">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.WARP">
            <summary>
            Types for CvWarpAffine
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.WARP.CV_WARP_DEFAULT">
            <summary>
            Neither FILL_OUTLIERS nor CV_WRAP_INVERSE_MAP
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.WARP.CV_WARP_FILL_OUTLIERS">
            <summary>
            Fill all the destination image pixels. If some of them correspond to outliers in the source image, they are set to fillval.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.WARP.CV_WARP_INVERSE_MAP">
            <summary>
            Indicates that matrix is inverse transform from destination image to source and, thus, can be used directly for pixel interpolation. Otherwise, the function finds the inverse transform from map_matrix.
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ADAPTIVE_THRESHOLD_TYPE">
            <summary>
            Types of Adaptive Threshold
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ADAPTIVE_THRESHOLD_TYPE.CV_ADAPTIVE_THRESH_MEAN_C">
            <summary>
            indicates that "Mean minus C" should be used for adaptive threshold.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ADAPTIVE_THRESHOLD_TYPE.CV_ADAPTIVE_THRESH_GAUSSIAN_C">
            <summary>
            indicates that "Gaussian minus C" should be used for adaptive threshold.
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CV_ELEMENT_SHAPE">
            <summary>
            Shape of the Structuring Element
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_ELEMENT_SHAPE.CV_SHAPE_RECT">
            <summary>
            A rectangular element.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_ELEMENT_SHAPE.CV_SHAPE_CROSS">
            <summary>
            A cross-shaped element.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_ELEMENT_SHAPE.CV_SHAPE_ELLIPSE">
            <summary>
            An elliptic element.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_ELEMENT_SHAPE.CV_SHAPE_CUSTOM">
            <summary>
            A user-defined element.
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.PCA_TYPE">
            <summary>
            PCA Type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.PCA_TYPE.CV_PCA_DATA_AS_ROW">
            <summary>
            the vectors are stored as rows (i.e. all the components of a certain vector are stored continously)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.PCA_TYPE.CV_PCA_DATA_AS_COL">
            <summary>
             the vectors are stored as columns (i.e. values of a certain vector component are stored continuously)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.PCA_TYPE.CV_PCA_USE_AVG">
            <summary>
            use pre-computed average vector
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CV_MORPH_OP">
            <summary>
            Type of Morphological Operation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_MORPH_OP.CV_MOP_OPEN">
            <summary>
            Opening.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_MORPH_OP.CV_MOP_CLOSE">
            <summary>
            Closing.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_MORPH_OP.CV_MOP_GRADIENT">
            <summary>
            Morphological Gradient.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_MORPH_OP.CV_MOP_TOPHAT">
            <summary>
            "Top Hat".
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_MORPH_OP.CV_MOP_BLACKHAT">
            <summary>
            "Black Hat".
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.HIST_TYPE">
            <summary>
            The type of histogram
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HIST_TYPE.CV_HIST_ARRAY">
            <summary>
            array
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HIST_TYPE.CV_HIST_SPARSE">
            <summary>
            sparse matrix
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.INVERT_METHOD">
            <summary>
            cvInvert method
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.INVERT_METHOD.CV_LU">
            <summary>
            Gaussian elimination with optimal pivot element chose
            In case of LU method the function returns src1 determinant (src1 must be square). If it is 0, the matrix is not inverted and src2 is filled with zeros.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.INVERT_METHOD.CV_SVD">
            <summary>
            Singular value decomposition (SVD) method
            In case of SVD methods the function returns the inversed condition number of src1 (ratio of the smallest singular value to the largest singular value) and 0 if src1 is all zeros. The SVD methods calculate a pseudo-inverse matrix if src1 is singular
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.INVERT_METHOD.CV_SVD_SYM">
            <summary>
            method for a symmetric positively-defined matrix
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.COVAR_METHOD">
            <summary>
            cvCalcCovarMatrix method types
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COVAR_METHOD.CV_COVAR_SCRAMBLED">
            <summary>
            Calculates covariation matrix for a set of vectors 
            transpose([v1-avg, v2-avg,...]) * [v1-avg,v2-avg,...] 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COVAR_METHOD.CV_COVAR_NORMAL">
            <summary>
            [v1-avg, v2-avg,...] * transpose([v1-avg,v2-avg,...])
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COVAR_METHOD.CV_COVAR_USE_AVG">
            <summary>
            Do not calc average (i.e. mean vector) - use the input vector instead
            (useful for calculating covariance matrix by parts)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COVAR_METHOD.CV_COVAR_SCALE">
            <summary>
            Scale the covariance matrix coefficients by number of the vectors
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COVAR_METHOD.CV_COVAR_ROWS">
            <summary>
            All the input vectors are stored in a single matrix, as its rows 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.COVAR_METHOD.CV_COVAR_COLS">
            <summary>
            All the input vectors are stored in a single matrix, as its columns
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.SVD_TYPE">
            <summary>
            Type for cvSVD
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SVD_TYPE.CV_SVD_DEFAULT">
            <summary>
            The default type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SVD_TYPE.CV_SVD_MODIFY_A">
            <summary>
            enables modification of matrix src1 during the operation. It speeds up the processing. 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SVD_TYPE.CV_SVD_U_T">
            <summary>
            means that the tranposed matrix U is returned. Specifying the flag speeds up the processing. 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.SVD_TYPE.CV_SVD_V_T">
            <summary>
            means that the tranposed matrix V is returned. Specifying the flag speeds up the processing. 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.LKFLOW_TYPE">
            <summary>
            Type for cvCalcOpticalFlowPyrLK
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LKFLOW_TYPE.DEFAULT">
            <summary>
            The default type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LKFLOW_TYPE.CV_LKFLOW_PYR_A_READY">
            <summary>
            Pyramid for the first frame is precalculated before the call
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LKFLOW_TYPE.CV_LKFLOW_PYR_B_READY">
            <summary>
            Pyramid for the second frame is precalculated before the call
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.LKFLOW_TYPE.CV_LKFLOW_INITIAL_GUESSES">
            <summary>
            Array B contains initial coordinates of features before the function call.
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CALIB_TYPE">
            <summary>
            Various camera calibration flags
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CALIB_TYPE.DEFAULT">
            <summary>
            The default value
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CALIB_TYPE.CV_CALIB_USE_INTRINSIC_GUESS">
            <summary>
            intrinsic_matrix contains valid initial values of fx, fy, cx, cy that are optimized further. Otherwise, (cx, cy) is initially set to the image center (image_size is used here), and focal distances are computed in some least-squares fashion
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CALIB_TYPE.CV_CALIB_FIX_ASPECT_RATIO">
            <summary>
            The optimization procedure consider only one of fx and fy as independent variable and keeps the aspect ratio fx/fy the same as it was set initially in intrinsic_matrix. In this case the actual initial values of (fx, fy) are either taken from the matrix (when CV_CALIB_USE_INTRINSIC_GUESS is set) or estimated somehow (in the latter case fx, fy may be set to arbitrary values, only their ratio is used)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CALIB_TYPE.CV_CALIB_FIX_PRINCIPAL_POINT">
            <summary>
            The principal point is not changed during the global optimization, it stays at the center and at the other location specified (when CV_CALIB_FIX_FOCAL_LENGTH - Both fx and fy are fixed.
            CV_CALIB_USE_INTRINSIC_GUESS is set as well)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CALIB_TYPE.CV_CALIB_ZERO_TANGENT_DIST">
            <summary>
            Tangential distortion coefficients are set to zeros and do not change during the optimization
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CALIB_TYPE.CV_CALIB_FIX_FOCAL_LENGTH">
            <summary>
            The focal length is fixed
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CALIB_TYPE.CV_CALIB_FIX_K1">
            <summary>
            The 0-th distortion coefficient (k1) is fixed (to 0 or to the initial passed value if CV_CALIB_USE_INTRINSIC_GUESS is passed)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CALIB_TYPE.CV_CALIB_FIX_K2">
            <summary>
            The 1-st distortion coefficient (k2) is fixed (see above)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CALIB_TYPE.CV_CALIB_FIX_K3">
            <summary>
            The 4-th distortion coefficient (k3) is fixed (see above)
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CALIB_CB_TYPE">
            <summary>
            Type of chessboard calibration
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CALIB_CB_TYPE.DEFAULT">
            <summary>
            Default type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CALIB_CB_TYPE.ADAPTIVE_THRESH">
            <summary>
            Use adaptive thresholding to convert the image to black-n-white, rather than a fixed threshold level (computed from the average image brightness)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CALIB_CB_TYPE.NORMALIZE_IMAGE">
            <summary>
            Normalize the image using cvNormalizeHist before applying fixed or adaptive thresholding.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CALIB_CB_TYPE.FILTER_QUADS">
            <summary>
            Use additional criteria (like contour area, perimeter, square-like shape) to filter out false quads that are extracted at the contour retrieval stage
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CALIB_CB_TYPE.FAST_CHECK">
            <summary>
            If it is on, then this check is performed before the main algorithm and if a chessboard is not found, the function returns 0 instead of wasting 0.3-1s on doing the full search.
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.EIGOBJ_TYPE">
            <summary>
            IO type for eigen object related functions
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.EIGOBJ_TYPE.CV_EIGOBJ_NO_CALLBACK">
            <summary>
            No callback
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.EIGOBJ_TYPE.CV_EIGOBJ_INPUT_CALLBACK">
            <summary>
            input callback
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.EIGOBJ_TYPE.CV_EIGOBJ_OUTPUT_CALLBACK">
            <summary>
            output callback
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.EIGOBJ_TYPE.CV_EIGOBJ_BOTH_CALLBACK">
            <summary>
            both callback
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CV_NEXT_EDGE_TYPE">
            <summary>
            CvNextEdgeType
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_NEXT_EDGE_TYPE.CV_NEXT_AROUND_ORG">
            <summary>
            next around the edge origin (eOnext)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_NEXT_EDGE_TYPE.CV_NEXT_AROUND_DST">
            <summary>
            next around the edge vertex (eDnext) 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_NEXT_EDGE_TYPE.CV_PREV_AROUND_ORG">
            <summary>
            previous around the edge origin (reversed eRnext)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_NEXT_EDGE_TYPE.CV_PREV_AROUND_DST">
            <summary>
            previous around the edge destination (reversed eLnext) 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_NEXT_EDGE_TYPE.CV_NEXT_AROUND_LEFT">
            <summary>
            next around the left facet (eLnext) 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_NEXT_EDGE_TYPE.CV_NEXT_AROUND_RIGHT">
            <summary>
            next around the right facet (eRnext)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_NEXT_EDGE_TYPE.CV_PREV_AROUND_LEFT">
            <summary>
            previous around the left facet (reversed eOnext)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CV_NEXT_EDGE_TYPE.CV_PREV_AROUND_RIGHT">
            <summary>
            previous around the right facet (reversed eDnext) 
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.ORIENTATION">
            <summary>
            orientation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ORIENTATION.CV_CLOCKWISE">
            <summary>
            clockwise
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.ORIENTATION.CV_COUNTER_CLOCKWISE">
            <summary>
            counter clockwise
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.STEREO_BM_TYPE">
            <summary>
            Stereo Block Matching type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.STEREO_BM_TYPE.BASIC">
            <summary>
            Basic type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.STEREO_BM_TYPE.FISH_EYE">
            <summary>
            Fish eye
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.STEREO_BM_TYPE.NARROW">
            <summary>
            Narrow
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.STEREO_BM_PREFILTER">
            <summary>
            Stereo Block Matching Prefilter type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.STEREO_BM_PREFILTER.NORMALIZED_RESPONSE">
            <summary>
            No prefilter
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.STEREO_BM_PREFILTER.XSOBEL">
            <summary>
            XSobel
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.HOMOGRAPHY_METHOD">
            <summary>
            Type of cvHomography method
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HOMOGRAPHY_METHOD.DEFAULT">
            <summary>
            regular method using all the point pairs
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HOMOGRAPHY_METHOD.LMEDS">
            <summary>
            Least-Median robust method
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HOMOGRAPHY_METHOD.RANSAC">
            <summary>
            RANSAC-based robust method
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE">
            <summary>
            Type used by cvMatchShapes
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE.CV_CONTOUR_MATCH_I1">
            <summary>
            I_1(A,B)=sum_{i=1..7} abs(1/m^A_i - 1/m^B_i) where m^A_i=sign(h^A_i) log(h^A_i), m^B_i=sign(h^B_i) log(h^B_i), h^A_i, h^B_i - Hu moments of A and B, respectively
            </summary> 
        </member>
        <member name="F:Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE.CV_CONTOURS_MATCH_I2">
            <summary>
            I_2(A,B)=sum_{i=1..7} abs(m^A_i - m^B_i) where m^A_i=sign(h^A_i) log(h^A_i), m^B_i=sign(h^B_i) log(h^B_i), h^A_i, h^B_i - Hu moments of A and B, respectively
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE.CV_CONTOURS_MATCH_I3">
            <summary>
            I_3(A,B)=sum_{i=1..7} abs(m^A_i - m^B_i)/abs(m^A_i) where m^A_i=sign(h^A_i) log(h^A_i), m^B_i=sign(h^B_i) log(h^B_i), h^A_i, h^B_i - Hu moments of A and B, respectively
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.Subdiv2DPointLocationType">
            <summary>
            The result type of cvSubdiv2DLocate.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Subdiv2DPointLocationType.ERROR">
            <summary>
            One of input arguments is invalid.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Subdiv2DPointLocationType.OUTSIDE_RECT">
            <summary>
            Point is outside the subdivision reference rectangle
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Subdiv2DPointLocationType.INSIDE">
            <summary>
            Point falls into some facet
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Subdiv2DPointLocationType.VERTEX">
            <summary>
            Point coincides with one of subdivision vertices
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.Subdiv2DPointLocationType.ON_EDGE">
            <summary>
            Point falls onto the edge
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.STEREO_RECTIFY_TYPE">
            <summary>
            Type used in cvStereoRectify
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.STEREO_RECTIFY_TYPE.DEFAULT">
            <summary>
            Shift one of the image in horizontal or vertical direction (depending on the orientation of epipolar lines) in order to maximise the useful image area
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.STEREO_RECTIFY_TYPE.CALIB_ZERO_DISPARITY">
            <summary>
            Makes the principal points of each camera have the same pixel coordinates in the rectified views
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.BORDER_TYPE">
            <summary>
            The type for CopyMakeBorder function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BORDER_TYPE.CONSTANT">
            <summary>
            border is filled with the fixed value, passed as last parameter of the function
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BORDER_TYPE.REPLICATE">
            <summary>
             the pixels from the top and bottom rows, the left-most and right-most columns are replicated to fill the border
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.HAAR_DETECTION_TYPE">
            <summary>
            The types for haar detection
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HAAR_DETECTION_TYPE.DEFAULT">
            <summary>
            The default type where no optimization is done.
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HAAR_DETECTION_TYPE.DO_CANNY_PRUNING">
            <summary>
            If it is set, the function uses Canny edge detector to reject some image regions that contain too few or too much edges and thus can not contain the searched object. The particular threshold values are tuned for face detection and in this case the pruning speeds up the processing
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HAAR_DETECTION_TYPE.SCALE_IMAGE">
            <summary>
            For each scale factor used the function will downscale the image rather than "zoom" the feature coordinates in the classifier cascade. Currently, the option can only be used alone, i.e. the flag can not be set together with the others
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HAAR_DETECTION_TYPE.FIND_BIGGEST_OBJECT">
            <summary>
            If it is set, the function finds the largest object (if any) in the image. That is, the output sequence will contain one (or zero) element(s)
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HAAR_DETECTION_TYPE.DO_ROUGH_SEARCH">
            <summary>
            It should be used only when CV_HAAR_FIND_BIGGEST_OBJECT is set and min_neighbors &gt; 0. If the flag is set, the function does not look for candidates of a smaller size as soon as it has found the object (with enough neighbor candidates) at the current scale. Typically, when min_neighbors is fixed, the mode yields less accurate (a bit larger) object rectangle than the regular single-object mode (flags=CV_HAAR_FIND_BIGGEST_OBJECT), but it is much faster, up to an order of magnitude. A greater value of min_neighbors may be specified to improve the accuracy
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.BACK_OR_FRONT">
            <summary>
            Specific if it is back or front
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BACK_OR_FRONT.BACK">
            <summary>
            Back
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BACK_OR_FRONT.FRONT">
            <summary>
            Front
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.MATCH_CONTOUR_TREE_METHOD">
            <summary>
            The method for matching contour tree
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.MATCH_CONTOUR_TREE_METHOD.CONTOUR_TREES_MATCH_I1">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.STORAGE_OP">
            <summary>
            The file storage operation type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.STORAGE_OP.READ">
            <summary>
            The storage is open for reading
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.STORAGE_OP.WRITE">
            <summary>
            The storage is open for writing
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.STORAGE_OP.APPEND">
            <summary>
            The storage is open for append
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.BLOB_DETECTOR_TYPE">
            <summary>
            The type of blob detector
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BLOB_DETECTOR_TYPE.Simple">
            <summary>
            Simple blob detector
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BLOB_DETECTOR_TYPE.CC">
            <summary>
            Conected Component blob detector
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.BLOBTRACKER_MS_PROFILE">
            <summary>
            MCvBlobTrackerParamMS profile
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BLOBTRACKER_MS_PROFILE.PROFILE_EPANECHNIKOV">
            <summary>
            EPANECHNIKOV
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BLOBTRACKER_MS_PROFILE.PROFILE_DOG">
            <summary>
            DoG
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.BLOBTRACKER_TYPE">
            <summary>
            The types of blob trakcer
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BLOBTRACKER_TYPE.CC">
            <summary>
            Simple blob tracker based on connected component tracking
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BLOBTRACKER_TYPE.CCMSPF">
            <summary>
            Connected component tracking and mean-shift particle filter collion-resolver
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BLOBTRACKER_TYPE.MSFG">
            <summary>
            Blob tracker that integrates meanshift and connected components
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BLOBTRACKER_TYPE.MSFGS">
            <summary>
            Blob tracker that integrates meanshift and connected components
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BLOBTRACKER_TYPE.MS">
            <summary>
            Meanshift without connected-components
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BLOBTRACKER_TYPE.MSPF">
            <summary>
            Particle filtering via Bhattacharya coefficient, which is roughly the dot-product of two probability densities.
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.BLOB_POST_PROCESS_TYPE">
            <summary>
            The type of blob post process module
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BLOB_POST_PROCESS_TYPE.Kalman">
            <summary>
            Kalman 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BLOB_POST_PROCESS_TYPE.TimeAverRect">
            <summary>
            TimeAverRect
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BLOB_POST_PROCESS_TYPE.TimeAverExp">
            <summary>
            TimeAverExp
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.HISTOGRAM_COMP_METHOD">
            <summary>
            Histogram comparison method
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HISTOGRAM_COMP_METHOD.CV_COMP_CORREL">
            <summary>
            Correlation/ 
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HISTOGRAM_COMP_METHOD.CV_COMP_CHISQR">
            <summary>
            Chi-Square
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HISTOGRAM_COMP_METHOD.CV_COMP_INTERSECT">
            <summary>
            Intersection
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.HISTOGRAM_COMP_METHOD.CV_COMP_BHATTACHARYYA">
            <summary>
            Bhattacharyya distance
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.BG_STAT_TYPE">
            <summary>
            The type of BGStatModel
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BG_STAT_TYPE.FGD_STAT_MODEL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.BG_STAT_TYPE.GAUSSIAN_BG_MODEL">
            <summary>
            Gaussian background model
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.FORGROUND_DETECTOR_TYPE">
            <summary>
            Type of forground detector
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FORGROUND_DETECTOR_TYPE.FGD">
            <summary>
            Latest and greatest algorithm
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FORGROUND_DETECTOR_TYPE.MOG">
            <summary>
            "Mixture of Gaussians", older algorithm
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.FORGROUND_DETECTOR_TYPE.FGD_SIMPLE">
            <summary>
             A simplified version of FGD
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.OPTICALFLOW_FARNEBACK_FLAG">
            <summary>
            The available flags for farneback optical flow computation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.OPTICALFLOW_FARNEBACK_FLAG.DEFAULT">
            <summary>
            Default
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.OPTICALFLOW_FARNEBACK_FLAG.USE_INITIAL_FLOW">
            <summary>
            Use the input flow as the initial flow approximation
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.OPTICALFLOW_FARNEBACK_FLAG.FARNEBACK_GAUSSIAN">
            <summary>
            Use a Gaussian winsize x winsizefilter instead of box
            filter of the same size for optical flow estimation. Usually, this option gives more accurate
            flow than with a box filter, at the cost of lower speed (and normally winsize for a
            Gaussian window should be set to a larger value to achieve the same level of robustness)
            </summary>
        </member>
        <member name="T:Emgu.CV.CvEnum.GRABCUT_INIT_TYPE">
            <summary>
            Grabcut initialization type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GRABCUT_INIT_TYPE.INIT_WITH_RECT">
            <summary>
            Initialize with rectangle
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GRABCUT_INIT_TYPE.INIT_WITH_MASK">
            <summary>
            Initialize with mask
            </summary>
        </member>
        <member name="F:Emgu.CV.CvEnum.GRABCUT_INIT_TYPE.EVAL">
            <summary>
            Eval
            </summary>
        </member>
        <member name="T:Emgu.CV.CvInvoke">
            <summary>
            Library to invoke OpenCV functions
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke._stringMarshalType">
            <summary>
            string marshaling type
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.CXCORE_LIBRARY">
            <summary>
            The file name of the cxcore library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.CV_LIBRARY">
            <summary>
            The file name of the cv library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.HIGHGUI_LIBRARY">
            <summary>
            The file name of the highgui library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.CVAUX_LIBRARY">
            <summary>
            The file name of the cvaux library
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.EXTERN_LIBRARY">
            <summary>
            The file name of the cvextern library
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.#cctor">
            <summary>
            Static Constructor to setup opencv environment
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CV_MAKETYPE(System.Int32,System.Int32)">
            <summary>
            This function performs the same as CV_MAKETYPE macro
            </summary>
            <param name="depth">The type of depth</param>
            <param name="cn">The number of channels</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CV_FOURCC(System.Char,System.Char,System.Char,System.Char)">
            <summary>
            Generate 4-character code of codec used to compress the frames. For example, CV_FOURCC('P','I','M','1') is MPEG-1 codec, CV_FOURCC('M','J','P','G') is motion-jpeg codec etc.
            </summary>
            <param name="c1"></param>
            <param name="c2"></param>
            <param name="c3"></param>
            <param name="c4"></param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSampleLine(System.IntPtr,System.Drawing.Point,System.Drawing.Point,System.IntPtr,Emgu.CV.CvEnum.CONNECTIVITY)">
            <summary>
            Implements a particular case of application of line iterators. The function reads all the image points lying on the line between pt1 and pt2, including the ending points, and stores them into the buffer
            </summary>
            <param name="image">Image to sample the line from</param>
            <param name="pt1">Starting the line point.</param>
            <param name="pt2">Ending the line point</param>
            <param name="buffer">Buffer to store the line points; must have enough size to store max( |pt2.x-pt1.x|+1, |pt2.y-pt1.y|+1 ) points in case of 8-connected line and |pt2.x-pt1.x|+|pt2.y-pt1.y|+1 in case of 4-connected line</param>
            <param name="connectivity">The line connectivity, 4 or 8</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetRectSubPix(System.IntPtr,System.IntPtr,System.Drawing.PointF)">
            <summary>
            Extracts pixels from src:
            dst(x, y) = src(x + center.x - (width(dst)-1)*0.5, y + center.y - (height(dst)-1)*0.5)
            where the values of pixels at non-integer coordinates are retrieved using bilinear interpolation. Every channel of multiple-channel images is processed independently. Whereas the rectangle center must be inside the image, the whole rectangle may be partially occluded. In this case, the replication border mode is used to get pixel values beyond the image boundaries.
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Extracted rectangle</param>
            <param name="center">Floating point coordinates of the extracted rectangle center within the source image. The center must be inside the image.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetQuadrangleSubPix(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Extracts pixels from src at sub-pixel accuracy and stores them to dst as follows:
            dst(x, y)= src( A_11 x'+A_12 y'+ b1, A_21 x'+A_22 y'+ b2),
            where A and b are taken from map_matrix:
            map_matrix = [ [A11 A12  b1], [ A21 A22  b2 ] ]
            x'=x-(width(dst)-1)*0.5, y'=y-(height(dst)-1)*0.5
            where the values of pixels at non-integer coordinates A (x,y)^T + b are retrieved using bilinear interpolation. When the function needs pixels outside of the image, it uses replication border mode to reconstruct the values. Every channel of multiple-channel images is processed independently.
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Extracted quadrangle</param>
            <param name="mapMatrix">The transformation 2 x 3 matrix [A|b]</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvResize(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.INTER)">
            <summary>
            Resizes image src so that it fits exactly to dst. If ROI is set, the function consideres the ROI as supported as usual
            </summary>
            <param name="src">Source image.</param>
            <param name="dst">Destination image</param>
            <param name="interpolation">Interpolation method</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvWarpAffine(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Transforms source image using the specified matrix
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="mapMatrix">2x3 transformation matrix</param>
            <param name="flags"> flags </param>
            <param name="fillval">A value used to fill outliers</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetAffineTransform(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Calculates the matrix of an affine transform such that:
            (x'_i,y'_i)^T=map_matrix (x_i,y_i,1)^T
            where dst(i)=(x'_i,y'_i), src(i)=(x_i,y_i), i=0..2.
            </summary>
            <param name="src">Pointer to an array of PointF, Coordinates of 3 triangle vertices in the source image.</param>
            <param name="dst">Pointer to an array of PointF, Coordinates of the 3 corresponding triangle vertices in the destination image</param>
            <param name="mapMatrix">Pointer to the destination 2x3 matrix</param>
            <returns>Pointer to the destination 2x3 matrix</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetAffineTransform(System.Drawing.PointF[],System.Drawing.PointF[],System.IntPtr)">
            <summary>
            Calculates the matrix of an affine transform such that:
            (x'_i,y'_i)^T=map_matrix (x_i,y_i,1)^T
            where dst(i)=(x'_i,y'_i), src(i)=(x_i,y_i), i=0..2.
            </summary>
            <param name="src">Coordinates of 3 triangle vertices in the source image.</param>
            <param name="dst">Coordinates of the 3 corresponding triangle vertices in the destination image</param>
            <param name="mapMatrix">Pointer to the destination 2x3 matrix</param>
            <returns>Pointer to the destination 2x3 matrix</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cv2DRotationMatrix(System.Drawing.PointF,System.Double,System.Double,System.IntPtr)">
            <summary>
            Calculates rotation matrix
            </summary>
            <param name="center">Center of the rotation in the source image. </param>
            <param name="angle">The rotation angle in degrees. Positive values mean couter-clockwise rotation (the coordiate origin is assumed at top-left corner).</param>
            <param name="scale">Isotropic scale factor</param>
            <param name="mapMatrix">Pointer to the destination 2x3 matrix</param>
            <returns>Pointer to the destination 2x3 matrix</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvWarpPerspective(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Transforms source image using the specified matrix
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="mapMatrix">3? transformation matrix</param>
            <param name="flags"></param>
            <param name="fillval">A value used to fill outliers</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetPerspectiveTransform(System.Drawing.PointF[],System.Drawing.PointF[],System.IntPtr)">
            <summary>
            calculates matrix of perspective transform such that:
            (t_i x'_i,t_i y'_i,t_i)^T=map_matrix (x_i,y_i,1)^T
            where dst(i)=(x'_i,y'_i), src(i)=(x_i,y_i), i=0..3.
            </summary>
            <param name="src">Coordinates of 4 quadrangle vertices in the source image</param>
            <param name="dst">Coordinates of the 4 corresponding quadrangle vertices in the destination image</param>
            <param name="mapMatrix">Pointer to the destination 3x3 matrix</param>
            <returns>Pointer to the perspective transform matrix</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetPerspectiveTransform(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            calculates matrix of perspective transform such that:
            (t_i x'_i,t_i y'_i,t_i)^T=map_matrix (x_i,y_i,1)T
            where dst(i)=(x'_i,y'_i), src(i)=(x_i,y_i), i=0..3.
            </summary>
            <param name="src">Coordinates of 4 quadrangle vertices in the source image</param>
            <param name="dst">Coordinates of the 4 corresponding quadrangle vertices in the destination image</param>
            <param name="mapMatrix">Pointer to the destination 3x3 matrix</param>
            <returns>Pointer to the perspective transform matrix</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvRemap(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Similar to other geometrical transformations, some interpolation method (specified by user) is used to extract pixels with non-integer coordinates.
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="mapx">The map of x-coordinates (32fC1 image)</param>
            <param name="mapy">The map of y-coordinates (32fC1 image)</param>
            <param name="flags">A combination of interpolation method and the optional flag CV_WARP_FILL_OUTLIERS </param>
            <param name="fillval">A value used to fill outliers</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvLogPolar(System.IntPtr,System.IntPtr,System.Drawing.PointF,System.Double,System.Int32)">
            <summary>
            The function emulates the human "foveal" vision and can be used for fast scale and rotation-invariant template matching, for object tracking etc.
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="center">The transformation center, where the output precision is maximal</param>
            <param name="M">Magnitude scale parameter</param>
            <param name="flags">A combination of interpolation method and the optional flag CV_WARP_FILL_OUTLIERS and/or CV_WARP_INVERSE_MAP</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvLinearPolar(System.IntPtr,System.IntPtr,System.Drawing.PointF,System.Double,System.Int32)">
            <summary>
            The function emulates the human "foveal" vision and can be used for fast scale and rotation-invariant template matching, for object tracking etc.
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="center">The transformation center, where the output precision is maximal</param>
            <param name="maxRadius">Maximum radius</param>
            <param name="flags">A combination of interpolation method and the optional flag CV_WARP_FILL_OUTLIERS and/or CV_WARP_INVERSE_MAP</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSegmentMotion(System.IntPtr,System.IntPtr,System.IntPtr,System.Double,System.Double)">
            <summary>
            Finds all the motion segments and marks them in segMask with individual values each (1,2,...). It also returns a sequence of CvConnectedComp structures, one per each motion components. After than the motion direction for every component can be calculated with cvCalcGlobalOrientation using extracted mask of the particular component (using cvCmp) 
            </summary>
            <param name="mhi">Motion history image</param>
            <param name="segMask">Image where the mask found should be stored, single-channel, 32-bit floating-point</param>
            <param name="storage">Memory storage that will contain a sequence of motion connected components</param>
            <param name="timestamp">Current time in milliseconds or other units</param>
            <param name="segThresh">Segmentation threshold; recommended to be equal to the interval between motion history "steps" or greater</param>
            <returns>Pointer to the sequence of MCvConnectedComp</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcGlobalOrientation(System.IntPtr,System.IntPtr,System.IntPtr,System.Double,System.Double)">
            <summary>
            Calculates the general motion direction in the selected region and returns the angle between 0 and 360. At first the function builds the orientation histogram and finds the basic orientation as a coordinate of the histogram maximum. After that the function calculates the shift relative to the basic orientation as a weighted sum of all orientation vectors: the more recent is the motion, the greater is the weight. The resultant angle is a circular sum of the basic orientation and the shift. 
            </summary>
            <param name="orientation">Motion gradient orientation image; calculated by the function cvCalcMotionGradient.</param>
            <param name="mask">Mask image. It may be a conjunction of valid gradient mask, obtained with cvCalcMotionGradient and mask of the region, whose direction needs to be calculated. </param>
            <param name="mhi">Motion history image.</param>
            <param name="timestamp">Current time in milliseconds or other units, it is better to store time passed to cvUpdateMotionHistory before and reuse it here, because running cvUpdateMotionHistory and cvCalcMotionGradient on large images may take some time.</param>
            <param name="duration">Maximal duration of motion track in milliseconds, the same as in cvUpdateMotionHistory</param>
            <returns>The angle</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvPyrDown(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.FILTER_TYPE)">
            <summary>
            Performs downsampling step of Gaussian pyramid decomposition. First it convolves source image with the specified filter and then downsamples the image by rejecting even rows and columns.
            </summary>
            <param name="src">The source image.</param>
            <param name="dst">The destination image, should have 2x smaller width and height than the source.</param>
            <param name="filter">Type of the filter used for convolution; only CV_GAUSSIAN_5x5 is currently supported.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvPyrUp(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.FILTER_TYPE)">
            <summary>
            Performs up-sampling step of Gaussian pyramid decomposition. First it upsamples the source image by injecting even zero rows and columns and then convolves result with the specified filter multiplied by 4 for interpolation. So the destination image is four times larger than the source image.
            </summary>
            <param name="src">The source image.</param>
            <param name="dst">The destination image, should have 2x smaller width and height than the source.</param>
            <param name="filter">Type of the filter used for convolution; only CV_GAUSSIAN_5x5 is currently supported.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvPyrSegmentation(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr@,System.Int32,System.Double,System.Double)">
            <summary>
            The function cvPyrSegmentation implements image segmentation by pyramids. The pyramid builds up to the level level. The links between any pixel a on level i and its candidate father pixel b on the adjacent level are established if 
            p(c(a),c(b))&gt;threshold1. After the connected components are defined, they are joined into several clusters. Any two segments A and B belong to the same cluster, if 
            p(c(A),c(B))&gt;threshold2. The input image has only one channel, then 
            p(c1,c2)=|c1-c2|. If the input image has three channels (red, green and blue), then 
            p(c1,c2)=0.3*(c1r-c2r)+0.59 * (c1g-c2g)+0.11 *(c1b-c2b) . There may be more than one connected component per a cluster.
            </summary>
            <param name="src">The source image, should be 8-bit single-channel or 3-channel images </param>
            <param name="dst">The destination image, should be 8-bit single-channel or 3-channel images, same size as src </param>
            <param name="storage">Storage; stores the resulting sequence of connected components</param>
            <param name="comp">Pointer to the output sequence of the segmented components</param>
            <param name="level">Maximum level of the pyramid for the segmentation</param>
            <param name="threshold1">Error threshold for establishing the links</param>
            <param name="threshold2">Error threshold for the segments clustering</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvWatershed(System.IntPtr,System.IntPtr)">
            <summary>
            Implements one of the variants of watershed, non-parametric marker-based segmentation algorithm, described in [Meyer92] Before passing the image to the function, user has to outline roughly the desired regions in the image markers with positive (>0) indices, i.e. every region is represented as one or more connected components with the pixel values 1, 2, 3 etc. Those components will be "seeds" of the future image regions. All the other pixels in markers, which relation to the outlined regions is not known and should be defined by the algorithm, should be set to 0's. On the output of the function, each pixel in markers is set to one of values of the "seed" components, or to -1 at boundaries between the regions.
            </summary>
            <remarks>Note, that it is not necessary that every two neighbor connected components are separated by a watershed boundary (-1's pixels), for example, in case when such tangent components exist in the initial marker image. </remarks>
            <param name="image">The input 8-bit 3-channel image</param>
            <param name="markers">The input/output Int32 depth single-channel image (map) of markers. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMaxRect(System.Drawing.Rectangle@,System.Drawing.Rectangle@)">
            <summary>
            Finds minimum area rectangle that contains both input rectangles inside
            </summary>
            <param name="rect1">First rectangle </param>
            <param name="rect2">Second rectangle </param>
            <returns>The minimum area rectangle that contains both input rectangles inside</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFitLine(System.IntPtr,Emgu.CV.CvEnum.DIST_TYPE,System.Double,System.Double,System.Double,System.Single[])">
            <summary>
            Fits line to 2D or 3D point set 
            </summary>
            <param name="points">Sequence or array of 2D or 3D points with 32-bit integer or floating-point coordinates</param>
            <param name="distType">The distance used for fitting </param>
            <param name="param">Numerical parameter (C) for some types of distances, if 0 then some optimal value is chosen</param>
            <param name="reps">Sufficient accuracy for radius (distance between the coordinate origin and the line),  0.01 would be a good default</param>
            <param name="aeps">Sufficient accuracy for angle, 0.01 would be a good default</param>
            <param name="line">The output line parameters. In case of 2d fitting it is array of 4 floats (vx, vy, x0, y0) where (vx, vy) is a normalized vector collinear to the line and (x0, y0) is some point on the line. In case of 3D fitting it is array of 6 floats (vx, vy, vz, x0, y0, z0) where (vx, vy, vz) is a normalized vector collinear to the line and (x0, y0, z0) is some point on the line.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvBoxPoints(Emgu.CV.Structure.MCvBox2D,System.Single[])">
            <summary>
            Calculates vertices of the input 2d box.
            </summary>
            <param name="box">The box</param>
            <param name="pt">An array of size 8, where the coordinate for ith point is: [pt[i&gt;&gt;1], pt[(i&gt;&gt;1)+1]]</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvBoxPoints(Emgu.CV.Structure.MCvBox2D,System.Drawing.PointF[])">
            <summary>
            Calculates vertices of the input 2d box.
            </summary>
            <param name="box">The box</param>
            <param name="pt">An array of size 4 points</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFitEllipse2(System.IntPtr)">
            <summary>
            Calculates ellipse that fits best (in least-squares sense) to a set of 2D points. The meaning of the returned structure fields is similar to those in cvEllipse except that size stores the full lengths of the ellipse axises, not half-lengths
            </summary>
            <param name="points">Sequence or array of points</param>
            <returns>The ellipse that fits best (in least-squares sense) to a set of 2D points</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvConvexHull2(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.ORIENTATION,System.Int32)">
            <summary>
            The function cvConvexHull2 finds convex hull of 2D point set using Sklansky's algorithm. 
            </summary>
            <param name="input">Sequence or array of 2D points with 32-bit integer or floating-point coordinates</param>
            <param name="hullStorage">The destination array (CvMat*) or memory storage (CvMemStorage*) that will store the convex hull. If it is array, it should be 1d and have the same number of elements as the input array/sequence. On output the header is modified so to truncate the array downto the hull size</param>
            <param name="orientation">Desired orientation of convex hull: CV_CLOCKWISE or CV_COUNTER_CLOCKWISE</param>
            <param name="returnPoints">If non-zero, the points themselves will be stored in the hull instead of indices if hull_storage is array, or pointers if hull_storage is memory storage</param>
            <returns>If hull_storage is memory storage, the function creates a sequence containing the hull points or pointers to them, depending on return_points value and returns the sequence on output</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateSubdivDelaunay2D(System.Drawing.Rectangle,System.IntPtr)">
            <summary>
            Creates an empty Delaunay subdivision, where 2d points can be added further using function cvSubdivDelaunay2DInsert. All the points to be added must be within the specified rectangle, otherwise a runtime error will be raised. 
            </summary>
            <param name="rect">Rectangle that includes all the 2d points that are to be added to subdivision.</param>
            <param name="storage">Container for subdivision</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInitSubdivDelaunay2D(System.IntPtr,System.Drawing.Rectangle)">
            <summary>
            Initializes Delaunay triangulation 
            </summary>
            <param name="subdiv"></param>
            <param name="rect"></param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFindNearestPoint2D(System.IntPtr,System.Drawing.PointF)">
            <summary>
            Locates input point within subdivision. It finds subdivision vertex that is the closest to the input point. It is not necessarily one of vertices of the facet containing the input point, though the facet (located using cvSubdiv2DLocate) is used as a starting point. 
            </summary>
            <param name="subdiv">Delaunay or another subdivision</param>
            <param name="pt">Input point</param>
            <returns>pointer to the found subdivision vertex (CvSubdiv2DPoint)</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateSubdiv2D(System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr)">
            <summary>
            Creates new subdivision
            </summary>
            <param name="subdiv_type"></param>
            <param name="header_size"></param>
            <param name="vtx_size"></param>
            <param name="quadedge_size"></param>
            <param name="storage"></param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSubdivDelaunay2DInsert(System.IntPtr,System.Drawing.PointF)">
            <summary>
            Inserts a single point to subdivision and modifies the subdivision topology appropriately. If a points with same coordinates exists already, no new points is added. The function returns pointer to the allocated point. No virtual points coordinates is calculated at this stage.
            </summary>
            <param name="subdiv">Delaunay subdivision created by function cvCreateSubdivDelaunay2D</param>
            <param name="pt">Inserted point.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSubdiv2DLocate(System.IntPtr,System.Drawing.PointF,System.IntPtr@,System.IntPtr@)">
            <summary>
            Locates input point within subdivision
            </summary>
            <param name="subdiv">Plannar subdivision</param>
            <param name="pt">The point to locate</param>
            <param name="edge">The output edge the point falls onto or right to</param>
            <param name="vertex">Optional output vertex double pointer the input point coincides with</param>
            <returns>The type of location for the point</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcSubdivVoronoi2D(System.IntPtr)">
            <summary>
            Calculates coordinates of virtual points. All virtual points corresponding to some vertex of original subdivision form (when connected together) a boundary of Voronoi cell of that point
            </summary>
            <param name="subdiv">Delaunay subdivision, where all the points are added already</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreatePOSITObject(System.Single[0:,0:],System.Int32)">
            <summary>
            Allocates memory for the object structure and computes the object inverse matrix. 
            </summary>
            <remarks>The preprocessed object data is stored in the structure CvPOSITObject, internal for OpenCV, which means that the user cannot directly access the structure data. The user may only create this structure and pass its pointer to the function. 
            Object is defined as a set of points given in a coordinate system. The function cvPOSIT computes a vector that begins at a camera-related coordinate system center and ends at the points[0] of the object. 
            Once the work with a given object is finished, the function cvReleasePOSITObject must be called to free memory</remarks>
            <param name="points3D">A two dimensional array contains the points of the 3D object model, the second dimension must be 3. </param>
            <param name="pointCount">Number of object points</param>
            <returns>A pointer to the CvPOSITObject</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvPOSIT(System.IntPtr,System.Single[0:,0:],System.Double,Emgu.CV.Structure.MCvTermCriteria,System.Single[],System.Single[])">
            <summary>
            Implements POSIT algorithm. Image coordinates are given in a camera-related coordinate system. The focal length may be retrieved using camera calibration functions. At every iteration of the algorithm new perspective projection of estimated pose is computed. 
            </summary>
            <remarks>Difference norm between two projections is the maximal distance between corresponding points. </remarks>
            <param name="positObject">Pointer to the object structure</param>
            <param name="imagePoints">2D array to the object points projections on the 2D image plane, the second dimension must be 2.</param>
            <param name="focalLength">Focal length of the camera used</param>
            <param name="criteria">Termination criteria of the iterative POSIT algorithm. The parameter criteria.epsilon serves to stop the algorithm if the difference is small.</param>
            <param name="rotationMatrix">A vector which contains the 9 elements of the 3x3 rotation matrix</param>
            <param name="translationVector">Translation vector (3x1)</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvPOSIT(System.IntPtr,System.IntPtr,System.Double,Emgu.CV.Structure.MCvTermCriteria,System.IntPtr,System.IntPtr)">
            <summary>
            Implements POSIT algorithm. Image coordinates are given in a camera-related coordinate system. The focal length may be retrieved using camera calibration functions. At every iteration of the algorithm new perspective projection of estimated pose is computed. 
            </summary>
            <remarks>Difference norm between two projections is the maximal distance between corresponding points. </remarks>
            <param name="positObject">Pointer to the object structure</param>
            <param name="imagePoints">2D array to the object points projections on the 2D image plane, the second dimension must be 2.</param>
            <param name="focalLength">Focal length of the camera used</param>
            <param name="criteria">Termination criteria of the iterative POSIT algorithm. The parameter criteria.epsilon serves to stop the algorithm if the difference is small.</param>
            <param name="rotationMatrix">A vector which contains the 9 elements of the 3x3 rotation matrix</param>
            <param name="translationVector">Translation vector (3x1)</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleasePOSITObject(System.IntPtr@)">
            <summary>
            The function cvReleasePOSITObject releases memory previously allocated by the function cvCreatePOSITObject. 
            </summary>
            <param name="positObject">pointer to CvPOSIT structure</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateKDTree(System.IntPtr)">
            <summary>
            Constructs a balanced kd-tree index of the given feature vectors. The lifetime of the desc matrix must exceed that of the returned tree. I.e., no copy is made of the vectors.
            </summary>
            <param name="desc">n x d matrix of n d-dimensional feature vectors (CV_32FC1 or CV_64FC1)</param>
            <returns>A balanced kd-tree index of the given feature vectors</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateSpillTree(System.IntPtr,System.Int32,System.Double,System.Double)">
            <summary>
            Constructs a spill tree index of the given feature vectors. The lifetime of the desc matrix must exceed that of the returned tree. I.e., no copy is made of the vectors.
            </summary>
            <param name="desc">n x d matrix of n d-dimensional feature vectors (CV_32FC1 or CV_64FC1)</param>
            <param name="naive"></param>
            <param name="rho"></param>
            <param name="tau"></param>
            <returns>A spill tree index of the given feature vectors</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseFeatureTree(System.IntPtr)">
            <summary>
            Deallocates the given kd-tree
            </summary>
            <param name="tr">Pointer to tree being destroyed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFindFeatures(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Searches feature tree for k nearest neighbors of given reference points.
            </summary>
            <remarks> In case of k-d tree: Finds (with high probability) the k nearest neighbors in tr for each of the given (row-)vectors in desc, using best-bin-first searching ([Beis97]). The complexity of the entire operation is at most O(m*emax*log2(n)), where n is the number of vectors in the tree</remarks>
            <param name="tr">Pointer to kd-tree index of reference vectors</param>
            <param name="desc">m x d matrix of (row-)vectors to find the nearest neighbors of</param>
            <param name="results">m x k set of row indices of matching vectors (referring to matrix passed to cvCreateFeatureTree). Contains -1 in some columns if fewer than k neighbors found</param>
            <param name="dist">m x k matrix of distances to k nearest neighbors</param>
            <param name="k">The number of neighbors to find</param>
            <param name="emax">For k-d tree only: the maximum number of leaves to visit.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFindFeaturesBoxed(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Performs orthogonal range seaching on the given kd-tree. That is, it returns the set of vectors v in tr that satisfy bounds_min[i] &lt;= v[i] &lt;= bounds_max[i], 0 &lt;= i &lt; d, where d is the dimension of vectors in the tree. The function returns the number of such vectors found
            </summary>
            <param name="tr">Pointer to kd-tree index of reference vectors</param>
            <param name="boundsMin">1 x d or d x 1 vector (CV_32FC1 or CV_64FC1) giving minimum value for each dimension</param>
            <param name="boundsMax">1 x d or d x 1 vector (CV_32FC1 or CV_64FC1) giving maximum value for each dimension</param>
            <param name="results">1 x m or m x 1 vector (CV_32SC1) to contain output row indices (referring to matrix passed to cvCreateFeatureTree)</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvErode(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Erodes the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the minimum is taken:
            dst=erode(src,element):  dst(x,y)=min((x',y') in element)) src(x+x',y+y')
            The function supports the in-place mode. Erosion can be applied several (iterations) times. In case of color image each channel is processed independently.
            </summary>
            <param name="src">Source image. </param>
            <param name="dst">Destination image</param>
            <param name="element">Structuring element used for erosion. If it is IntPtr.Zero, a 3x3 rectangular structuring element is used.</param>
            <param name="iterations">Number of times erosion is applied.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvDilate(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Dilates the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the maximum is taken
            The function supports the in-place mode. Dilation can be applied several (iterations) times. In case of color image each channel is processed independently
            </summary>
            <param name="src">Source image</param>
            <param name="dst">Destination image</param>
            <param name="element">Structuring element used for erosion. If it is IntPtr.Zero, a 3x3 rectangular structuring element is used</param>
            <param name="iterations">Number of times erosion is applied</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseHaarClassifierCascade(System.IntPtr@)">
            <summary>
            Deallocates the cascade that has been created manually or loaded using cvLoadHaarClassifierCascade or cvLoad
            </summary>
            <param name="cascade">Double pointer to the released cascade. The pointer is cleared by the function. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInpaint(System.IntPtr,System.IntPtr,System.IntPtr,System.Double,Emgu.CV.CvEnum.INPAINT_TYPE)">
            <summary>
            Reconstructs the selected image area from the pixel near the area boundary. The function may be used to remove dust and scratches from a scanned photo, or to remove undesirable objects from still images or video.
            </summary>
            <param name="src">The input 8-bit 1-channel or 3-channel image</param>
            <param name="mask">The inpainting mask, 8-bit 1-channel image. Non-zero pixels indicate the area that needs to be inpainted</param>
            <param name="dst">The output image of the same format and the same size as input</param>
            <param name="flags">The inpainting method</param>
            <param name="inpaintRadius">The radius of circlular neighborhood of each point inpainted that is considered by the algorithm</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSmooth(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.SMOOTH_TYPE,System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Smooths image using one of several methods. Every of the methods has some features and restrictions listed below
            Blur with no scaling works with single-channel images only and supports accumulation of 8-bit to 16-bit format (similar to cvSobel and cvLaplace) and 32-bit floating point to 32-bit floating-point format.
            Simple blur and Gaussian blur support 1- or 3-channel, 8-bit and 32-bit floating point images. These two methods can process images in-place.
            Median and bilateral filters work with 1- or 3-channel 8-bit images and can not process images in-place.
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image</param>
            <param name="type">Type of the smoothing</param>
            <param name="param1">The first parameter of smoothing operation</param>
            <param name="param2">The second parameter of smoothing operation. In case of simple scaled/non-scaled and Gaussian blur if param2 is zero, it is set to param1</param>
            <param name="param3">In case of Gaussian kernel this parameter may specify Gaussian sigma (standard deviation). If it is zero, it is calculated from the kernel size:
            sigma = (n/2 - 1)*0.3 + 0.8, where n=param1 for horizontal kernel,
            n=param2 for vertical kernel.
            With the standard sigma for small kernels (3x3 to 7x7) the performance is better. If param3 is not zero, while param1 and param2 are zeros, the kernel size is calculated from the sigma (to provide accurate enough operation). 
            </param>
            <param name="param4">In case of non-square Gaussian kernel the parameter may be used to specify a different (from param3) sigma in the vertical direction</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSobel(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
             <summary>
             The Sobel operators combine Gaussian smoothing and differentiation so the result is more or less robust to the noise. Most often, the function is called with (xorder=1, yorder=0, aperture_size=3) or (xorder=0, yorder=1, aperture_size=3) to calculate first x- or y- image derivative. The first case corresponds to
             <pre> 
              |-1  0  1|
              |-2  0  2|
              |-1  0  1|</pre>
             kernel and the second one corresponds to
             <pre>
              |-1 -2 -1|
              | 0  0  0|
              | 1  2  1|</pre>
             or
             <pre>
              | 1  2  1|
              | 0  0  0|
              |-1 -2 -1|</pre>
             kernel, depending on the image origin (origin field of IplImage structure). No scaling is done, so the destination image usually has larger by absolute value numbers than the source image. To avoid overflow, the function requires 16-bit destination image if the source image is 8-bit. The result can be converted back to 8-bit using cvConvertScale or cvConvertScaleAbs functions. Besides 8-bit images the function can process 32-bit floating-point images. Both source and destination must be single-channel images of equal size or ROI size
             </summary>
             <param name="src">Source image.</param>
             <param name="dst">Destination image</param>
             <param name="xorder">Order of the derivative x </param>
             <param name="yorder">Order of the derivative y</param>
             <param name="apertureSize">Size of the extended Sobel kernel, must be 1, 3, 5 or 7. In all cases except 1, <paramref name="appertureSize"/> x <paramref name="appertureSize"/> separable kernel will be used to calculate the derivative. For aperture_size=1 3x1 or 1x3 kernel is used (Gaussian smoothing is not done). There is also special value CV_SCHARR (=-1) that corresponds to 3x3 Scharr filter that may give more accurate results than 3x3 Sobel. Scharr aperture is: 
             <pre>
             | -3 0  3|
             |-10 0 10|
             | -3 0  3|</pre>
             for x-derivative or transposed for y-derivative. 
            </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvLaplace(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Calculates Laplacian of the source image by summing second x- and y- derivatives calculated using Sobel operator:
            dst(x,y) = d2src/dx2 + d2src/dy2
            Specifying aperture_size=1 gives the fastest variant that is equal to convolving the image with the following kernel:
            |0  1  0|
            |1 -4  1|
            |0  1  0|
            Similar to cvSobel function, no scaling is done and the same combinations of input and output formats are supported. 
            </summary>
            <param name="src">Source image. </param>
            <param name="dst">Destination image. </param>
            <param name="aperture_size">Aperture size </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCanny(System.IntPtr,System.IntPtr,System.Double,System.Double,System.Int32)">
            <summary>
            Finds the edges on the input image image and marks them in the output image edges using the Canny algorithm. The smallest of threshold1 and threshold2 is used for edge linking, the largest - to find initial segments of strong edges.
            </summary>
            <param name="image">Input image</param>
            <param name="edges">Image to store the edges found by the function</param>
            <param name="threshold1">The first threshold</param>
            <param name="threshold2">The second threshold.</param>
            <param name="aperture_size">Aperture parameter for Sobel operator </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCheckContourConvexity(System.IntPtr)">
            <summary>
            Tests whether the input contour is convex or not. The contour must be simple, i.e. without self-intersections. 
            </summary>
            <param name="contour">Tested contour (sequence or array of points). </param>
            <returns>true if convex</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvPointPolygonTest(System.IntPtr,System.Drawing.PointF,System.Int32)">
            <summary>
            Determines whether the point is inside contour, outside, or lies on an edge (or coinsides with a vertex). It returns positive, negative or zero value, correspondingly
            </summary>
            <param name="contour">Input contour</param>
            <param name="pt">The point tested against the contour</param>
            <param name="measureDist">If != 0, the function estimates distance from the point to the nearest contour edge</param>
            <returns>
            When measureDist = 0, the return value is &gt;0 (inside), &lt;0 (outside) and =0 (on edge), respectively. 
            When measureDist != 0, it is a signed distance between the point and the nearest contour edge
            </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvConvexityDefects(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Finds all convexity defects of the input contour and returns a sequence of the CvConvexityDefect structures. 
            </summary>
            <param name="contour">Input contour</param>
            <param name="convexhull">Convex hull obtained using cvConvexHull2 that should contain pointers or indices to the contour points, not the hull points themselves, i.e. return_points parameter in cvConvexHull2 should be 0</param>
            <param name="storage">Container for output sequence of convexity defects. If it is NULL, contour or hull (in that order) storage is used</param>
            <returns>Pointer to the sequence of the CvConvexityDefect structures. </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvPointPolygonTest(System.IntPtr,System.Drawing.PointF,System.Boolean)">
            <summary>
            Determines whether the point is inside contour, outside, or lies on an edge (or coinsides with a vertex). It returns positive, negative or zero value, correspondingly
            </summary>
            <param name="contour">Input contour</param>
            <param name="pt">The point tested against the contour</param>
            <param name="measureDist">If true, the function estimates distance from the point to the nearest contour edge</param>
            <returns>
            When measureDist == false, the return value is &gt;0 (inside), &lt;0 (outside) and =0 (on edge), respectively. 
            When measureDist == true, it is a signed distance between the point and the nearest contour edge
            </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMinAreaRect2(System.IntPtr,System.IntPtr)">
            <summary>
            Finds a circumscribed rectangle of the minimal area for 2D point set by building convex hull for the set and applying rotating calipers technique to the hull.
            </summary>
            <param name="points">Sequence of points, or two channel int/float depth matrix</param>
            <param name="storage">temporary memory storage</param>
            <returns>a circumscribed rectangle of the minimal area for 2D point set</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMinEnclosingCircle(System.IntPtr,System.Drawing.PointF@,System.Single@)">
            <summary>
            Finds the minimal circumscribed circle for 2D point set using iterative algorithm. It returns nonzero if the resultant circle contains all the input points and zero otherwise (i.e. algorithm failed)
            </summary>
            <param name="points">Sequence or array of 2D points</param>
            <param name="center">Output parameter. The center of the enclosing circle</param>
            <param name="radius">Output parameter. The radius of the enclosing circle.</param>
            <returns>Nonzero if the resultant circle contains all the input points and zero otherwise (i.e. algorithm failed)</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvApproxPoly(System.IntPtr,System.Int32,System.IntPtr,Emgu.CV.CvEnum.APPROX_POLY_TYPE,System.Double,System.Int32)">
            <summary>
            Approximates one or more curves and returns the approximation result[s]. 
            In case of multiple curves approximation the resultant tree will have the same structure as the input one (1:1 correspondence). 
            </summary>
            <param name="srcSeq">Sequence of array of points</param>
            <param name="headerSize">Header size of approximated curve[s].</param>
            <param name="storage">Container for approximated contours. If it is NULL, the input sequences' storage is used</param>
            <param name="method">Approximation method</param>
            <param name="parameter">Desired approximation accuracy</param>
            <param name="parameter2">
            In case if srcSeq is sequence it means whether the single sequence should be approximated or all sequences on the same level or below srcSeq (see cvFindContours for description of hierarchical contour structures). 
            And if srcSeq is array (CvMat*) of points, the parameter specifies whether the curve is closed (parameter2!=0) or not (parameter2=0). 
            </param>
            <returns>The approximation result</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvBoundingRect(System.IntPtr,System.Int32)">
            <summary>
            Returns the up-right bounding rectangle for 2d point set
            </summary>
            <param name="points">Either a 2D point set, represented as a sequence (CvSeq*, CvContour*) or vector (CvMat*) of points, or 8-bit single-channel mask image (CvMat*, IplImage*), in which non-zero pixels are considered</param>
            <param name="update">The update flag. Here is list of possible combination of the flag values and type of contour: 
            points is CvContour*, update=0: the bounding rectangle is not calculated, but it is read from rect field of the contour header. 
            points is CvContour*, update=1: the bounding rectangle is calculated and written to rect field of the contour header. For example, this mode is used by cvFindContours. 
            points is CvSeq* or CvMat*: update is ignored, the bounding rectangle is calculated and returned. 
            </param>
            <returns>The up-right bounding rectangle for 2d point set</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvBoundingRect(System.IntPtr,System.Boolean)">
            <summary>
            Returns the up-right bounding rectangle for 2d point set
            </summary>
            <param name="points">Either a 2D point set, represented as a sequence (CvSeq*, CvContour*) or vector (CvMat*) of points, or 8-bit single-channel mask image (CvMat*, IplImage*), in which non-zero pixels are considered</param>
            <param name="update">The update flag. Here is list of possible combination of the flag values and type of contour: 
            points is CvContour*, update=false: the bounding rectangle is not calculated, but it is read from rect field of the contour header. 
            points is CvContour*, update=true: the bounding rectangle is calculated and written to rect field of the contour header. For example, this mode is used by cvFindContours. 
            points is CvSeq* or CvMat*: update is ignored, the bounding rectangle is calculated and returned. 
            </param>
            <returns>The up-right bounding rectangle for 2d point set</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvContourArea(System.IntPtr,Emgu.CV.Structure.MCvSlice,System.Int32)">
            <summary>
            Calculates area of the whole contour or contour section. 
            </summary>
            <param name="contour">Seq (sequence or array of vertices). </param>
            <param name="slice">Starting and ending points of the contour section of interest, by default area of the whole contour is calculated</param>
            <param name="oriented">If zero, the absolute area will be returned. Otherwise the returned value mighted be negative</param>
            <returns>The area of the whole contour or contour section</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvArcLength(System.IntPtr,Emgu.CV.Structure.MCvSlice,System.Int32)">
            <summary>
            Calculates length or curve as sum of lengths of segments between subsequent points
            </summary>
            <param name="curve">Sequence or array of the curve points</param>
            <param name="slice">Starting and ending points of the curve, by default the whole curve length is calculated</param>
            <param name="is_closed">
            Indicates whether the curve is closed or not. There are 3 cases:
            is_closed=0 - the curve is assumed to be unclosed. 
            is_closed&gt;0 - the curve is assumed to be closed. 
            is_closed&lt;0 - if curve is sequence, the flag CV_SEQ_FLAG_CLOSED of ((CvSeq*)curve)-&gt;flags is checked to determine if the curve is closed or not, otherwise (curve is represented by array (CvMat*) of points) it is assumed to be unclosed. 
            </param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvContourPerimeter(System.IntPtr)">
            <summary>
            Find the perimeter of the contour
            </summary>
            <param name="contour">Pointer to the contour</param>
            <returns>the perimeter of the contour</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateContourTree(System.IntPtr,System.IntPtr,System.Double)">
            <summary>
            Creates binary tree representation for the input contour and returns the pointer to its root.
            </summary>
            <param name="contour">Input contour</param>
            <param name="storage">Container for output tree</param>
            <param name="threshold">If the parameter threshold is less than or equal to 0, the function creates full binary tree representation. If the threshold is greater than 0, the function creates representation with the precision threshold: if the vertices with the interceptive area of its base line are less than threshold, the tree should not be built any further</param>
            <returns>The binary tree representation for the input contour</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvContourFromContourTree(System.IntPtr,System.IntPtr,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Return the contour from its binary tree representation
            </summary>
            <param name="tree">Contour tree</param>
            <param name="storage">Container for the reconstructed contour</param>
            <param name="criteria">Criteria, where to stop reconstruction</param>
            <returns>The contour represented by this contour tree</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMatchContourTrees(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.MATCH_CONTOUR_TREE_METHOD,System.Double)">
            <summary>
            Calculates the value of the matching measure for two contour trees. The similarity measure is calculated level by level from the binary tree roots. If at the certain level difference between contours becomes less than threshold, the reconstruction process is interrupted and the current difference is returned
            </summary>
            <param name="tree1">First contour tree</param>
            <param name="tree2">Second contour tree</param>
            <param name="method">Similarity measure, only CV_CONTOUR_TREES_MATCH_I1 is supported</param>
            <param name="threshold">Similarity threshold</param>
            <returns>The value of the matching measure for two contour trees</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFilter2D(System.IntPtr,System.IntPtr,System.IntPtr,System.Drawing.Point)">
            <summary>
            Applies arbitrary linear filter to the image. In-place operation is supported. When the aperture is partially outside the image, the function interpolates outlier pixel values from the nearest pixels that is inside the image
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image</param>
            <param name="kernel">Convolution kernel, single-channel floating point matrix. If you want to apply different kernels to different channels, split the image using cvSplit into separate color planes and process them individually</param>
            <param name="anchor">The anchor of the kernel that indicates the relative position of a filtered point within the kernel. The anchor shoud lie within the kernel. The special default value (-1,-1) means that it is at the kernel center</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCopyMakeBorder(System.IntPtr,System.IntPtr,System.Drawing.Point,Emgu.CV.CvEnum.BORDER_TYPE,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Copies the source 2D array into interior of destination array and makes a border of the specified type around the copied area. The function is useful when one needs to emulate border type that is different from the one embedded into a specific algorithm implementation. For example, morphological functions, as well as most of other filtering functions in OpenCV, internally use replication border type, while the user may need zero border or a border, filled with 1's or 255's
            </summary>
            <param name="src">The source image</param>
            <param name="dst">The destination image</param>
            <param name="offset">Coordinates of the top-left corner (or bottom-left in case of images with bottom-left origin) of the destination image rectangle where the source image (or its ROI) is copied. Size of the rectangle matches the source image size/ROI size</param>
            <param name="bordertype">Type of the border to create around the copied source image rectangle</param>
            <param name="value">Value of the border pixels if bordertype=CONSTANT</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvThreshold(System.IntPtr,System.IntPtr,System.Double,System.Double,Emgu.CV.CvEnum.THRESH)">
            <summary>
            Applies fixed-level thresholding to single-channel array. The function is typically used to get bi-level (binary) image out of grayscale image (cvCmpS could be also used for this purpose) or for removing a noise, i.e. filtering out pixels with too small or too large values. There are several types of thresholding the function supports that are determined by threshold_type
            </summary>
            <param name="src">Source array (single-channel, 8-bit of 32-bit floating point). </param>
            <param name="dst">Destination array; must be either the same type as src or 8-bit. </param>
            <param name="threshold">Threshold value</param>
            <param name="maxValue">Maximum value to use with CV_THRESH_BINARY and CV_THRESH_BINARY_INV thresholding types</param>
            <param name="thresholdType">Thresholding type </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvAdaptiveThreshold(System.IntPtr,System.IntPtr,System.Double,Emgu.CV.CvEnum.ADAPTIVE_THRESHOLD_TYPE,Emgu.CV.CvEnum.THRESH,System.Int32,System.Double)">
            <summary>
            Transforms grayscale image to binary image. 
            Threshold calculated individually for each pixel. 
            For the method CV_ADAPTIVE_THRESH_MEAN_C it is a mean of <paramref name="blockSize"/> x <paramref name="blockSize"/> pixel
            neighborhood, subtracted by param1. 
            For the method CV_ADAPTIVE_THRESH_GAUSSIAN_C it is a weighted sum (gaussian) of <paramref name="blockSize"/> x <paramref name="blockSize"/> pixel neighborhood, subtracted by param1.
            </summary>
            <param name="src">Source array (single-channel, 8-bit of 32-bit floating point). </param>
            <param name="dst">Destination array; must be either the same type as src or 8-bit. </param>
            <param name="maxValue">Maximum value to use with CV_THRESH_BINARY and CV_THRESH_BINARY_INV thresholding types</param>
            <param name="adaptiveType">Adaptive_method </param>
            <param name="thresholdType">Thresholding type. must be one of CV_THRESH_BINARY, CV_THRESH_BINARY_INV  </param>
            <param name="blockSize">The size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, ... </param>
            <param name="param1">Constant subtracted from mean or weighted mean. It may be negative. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvHaarDetectObjects(System.IntPtr,System.IntPtr,System.IntPtr,System.Double,System.Int32,Emgu.CV.CvEnum.HAAR_DETECTION_TYPE,System.Drawing.Size)">
            <summary>
            Finds rectangular regions in the given image that are likely to contain objects the cascade has been trained for and returns those regions as a sequence of rectangles. The function scans the image several times at different scales (see cvSetImagesForHaarClassifierCascade). Each time it considers overlapping regions in the image and applies the classifiers to the regions using cvRunHaarClassifierCascade. It may also apply some heuristics to reduce number of analyzed regions, such as Canny prunning. After it has proceeded and collected the candidate rectangles (regions that passed the classifier cascade), it groups them and returns a sequence of average rectangles for each large enough group. The default parameters (scale_factor=1.1, min_neighbors=3, flags=0) are tuned for accurate yet slow object detection. For a faster operation on real video images the settings are: scale_factor=1.2, min_neighbors=2, flags=CV_HAAR_DO_CANNY_PRUNING, min_size=&lt;minimum possible face size&gt; (for example, ~1/4 to 1/16 of the image area in case of video conferencing). 
            </summary>
            <param name="image">Image to detect objects in.</param>
            <param name="cascade">Haar classifier cascade in internal representation</param>
            <param name="storage">Memory storage to store the resultant sequence of the object candidate rectangles</param>
            <param name="scaleFactor">Use 1.1 as default. The factor by which the search window is scaled between the subsequent scans, for example, 1.1 means increasing window by 10%</param>
            <param name="minNeighbors">Use 3 as default. Minimum number (minus 1) of neighbor rectangles that makes up an object. All the groups of a smaller number of rectangles than min_neighbors-1 are rejected. If min_neighbors is 0, the function does not any grouping at all and returns all the detected candidate rectangles, which may be useful if the user wants to apply a customized grouping procedure</param>
            <param name="flags">Mode of operation. Currently the only flag that may be specified is CV_HAAR_DO_CANNY_PRUNING. If it is set, the function uses Canny edge detector to reject some image regions that contain too few or too much edges and thus can not contain the searched object. The particular threshold values are tuned for face detection and in this case the pruning speeds up the processing</param>
            <param name="minSize">Use Size.Empty as default. Minimum window size. By default, it is set to the size of samples the classifier has been trained on (~20x20 for face detection). </param>
            <returns>Rectangular regions in the given image that are likely to contain objects the cascade has been trained for</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFindContours(System.IntPtr,System.IntPtr,System.IntPtr@,System.Int32,Emgu.CV.CvEnum.RETR_TYPE,Emgu.CV.CvEnum.CHAIN_APPROX_METHOD,System.Drawing.Point)">
            <summary>
            Retrieves contours from the binary image and returns the number of retrieved contours. The pointer first_contour is filled by the function. It will contain pointer to the first most outer contour or IntPtr.Zero if no contours is detected (if the image is completely black). Other contours may be reached from first_contour using h_next and v_next links. The sample in cvDrawContours discussion shows how to use contours for connected component detection. Contours can be also used for shape analysis and object recognition - see squares.c in OpenCV sample directory
            </summary>
            <param name="image">The source 8-bit single channel image. Non-zero pixels are treated as 1s, zero pixels remain 0s - that is image treated as binary. To get such a binary image from grayscale, one may use cvThreshold, cvAdaptiveThreshold or cvCanny. The function modifies the source image content</param>
            <param name="storage">Container of the retrieved contours</param>
            <param name="firstContour">Output parameter, will contain the pointer to the first outer contour</param>
            <param name="headerSize">Size of the sequence header, &gt;=sizeof(CvChain) if method=CV_CHAIN_CODE, and &gt;=sizeof(CvContour) otherwise</param>
            <param name="mode">Retrieval mode</param>
            <param name="method">Approximation method (for all the modes, except CV_RETR_RUNS, which uses built-in approximation). </param>
            <param name="offset">Offset, by which every contour point is shifted. This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvHoughCircles(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.HOUGH_TYPE,System.Double,System.Double,System.Double,System.Double,System.Int32,System.Int32)">
            <summary>
            Finds circles in grayscale image using some modification of Hough transform
            </summary>
            <param name="image">The input 8-bit single-channel grayscale image</param>
            <param name="circleStorage">The storage for the circles detected. It can be a memory storage (in this case a sequence of circles is created in the storage and returned by the function) or single row/single column matrix (CvMat*) of type CV_32FC3, to which the circles' parameters are written. The matrix header is modified by the function so its cols or rows will contain a number of lines detected. If circle_storage is a matrix and the actual number of lines exceeds the matrix size, the maximum possible number of circles is returned. Every circle is encoded as 3 floating-point numbers: center coordinates (x,y) and the radius</param>
            <param name="method">Currently, the only implemented method is CV_HOUGH_GRADIENT</param>
            <param name="dp">Resolution of the accumulator used to detect centers of the circles. For example, if it is 1, the accumulator will have the same resolution as the input image, if it is 2 - accumulator will have twice smaller width and height, etc</param>
            <param name="minDist">Minimum distance between centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed</param>
            <param name="param1">The first method-specific parameter. In case of CV_HOUGH_GRADIENT it is the higher threshold of the two passed to Canny edge detector (the lower one will be twice smaller). </param>
            <param name="param2">The second method-specific parameter. In case of CV_HOUGH_GRADIENT it is accumulator threshold at the center detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first</param>
            <param name="minRadius">Minimal radius of the circles to search for</param>
            <param name="maxRadius">Maximal radius of the circles to search for. By default the maximal radius is set to max(image_width, image_height). </param>
            <returns>Pointer to the sequence of circles</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCvtColor(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.COLOR_CONVERSION)">
            <summary>
            Converts input image from one color space to another. The function ignores colorModel and channelSeq fields of IplImage header, so the source image color space should be specified correctly (including order of the channels in case of RGB space, e.g. BGR means 24-bit format with B0 G0 R0 B1 G1 R1 ... layout, whereas RGB means 24-bit format with R0 G0 B0 R1 G1 B1 ... layout). 
            </summary>
            <param name="src">The source 8-bit (8u), 16-bit (16u) or single-precision floating-point (32f) image</param>
            <param name="dst">The destination image of the same data type as the source one. The number of channels may be different</param>
            <param name="code">Color conversion operation that can be specifed using CV_src_color_space2dst_color_space constants </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvHoughLines2(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.HOUGH_TYPE,System.Double,System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            The function cvHoughLines2 implements a few variants of Hough transform for line detection
            </summary>
            <param name="image">The input 8-bit single-channel binary image. In case of probabilistic method the image is modified by the function</param>
            <param name="lineStorage">The storage for the lines detected. It can be a memory storage (in this case a sequence of lines is created in the storage and returned by the function) or single row/single column matrix (CvMat*) of a particular type (see below) to which the lines' parameters are written. The matrix header is modified by the function so its cols or rows will contain a number of lines detected. If line_storage is a matrix and the actual number of lines exceeds the matrix size, the maximum possible number of lines is returned (in case of standard hough transform the lines are sorted by the accumulator value). </param>
            <param name="method">The Hough transform variant</param>
            <param name="rho">Distance resolution in pixel-related units</param>
            <param name="theta">Angle resolution measured in radians</param>
            <param name="threshold">Threshold parameter. A line is returned by the function if the corresponding accumulator value is greater than threshold</param>
            <param name="param1">The first method-dependent parameter:
            For classical Hough transform it is not used (0). 
            For probabilistic Hough transform it is the minimum line length. 
            For multi-scale Hough transform it is divisor for distance resolution rho. (The coarse distance resolution will be rho and the accurate resolution will be (rho / param1))
            </param>
            <param name="param2">The second method-dependent parameter:
            For classical Hough transform it is not used (0). 
            For probabilistic Hough transform it is the maximum gap between line segments lieing on the same line to treat them as the single line segment (i.e. to join them). 
            For multi-scale Hough transform it is divisor for angle resolution theta. (The coarse angle resolution will be theta and the accurate resolution will be (theta / param2)). 
            </param>
            <returns>Pointer to the decetected lines</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMoments(System.IntPtr,Emgu.CV.Structure.MCvMoments@,System.Int32)">
            <summary>
            Calculates spatial and central moments up to the third order and writes them to moments. The moments may be used then to calculate gravity center of the shape, its area, main axises and various shape characeteristics including 7 Hu invariants.
            </summary>
            <param name="arr">Image (1-channel or 3-channel with COI set) or polygon (CvSeq of points or a vector of points)</param>
            <param name="moments">Pointer to returned moment state structure</param>
            <param name="binary">(For images only) If the flag is non-zero, all the zero pixel values are treated as zeroes, all the others are treated as 1s</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGoodFeaturesToTrack(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32@,System.Double,System.Double,System.IntPtr,System.Int32,System.Int32,System.Double)">
            <summary>
            Finds corners with big eigenvalues in the image. 
            </summary>
            <remarks>
            The function first calculates the minimal eigenvalue for every source image pixel using cvCornerMinEigenVal function and stores them in eig_image. 
            Then it performs non-maxima suppression (only local maxima in 3x3 neighborhood remain). 
            The next step is rejecting the corners with the minimal eigenvalue less than quality_level*max(eigImage(x,y)). Finally, the function ensures that all the corners found are distanced enough one from another by considering the corners (the most strongest corners are considered first) and checking that the distance between the newly considered feature and the features considered earlier is larger than min_distance. So, the function removes the features than are too close to the stronger features.
            </remarks>
            <param name="image">The source 8-bit or floating-point 32-bit, single-channel image</param>
            <param name="eigImage">Temporary floating-point 32-bit image of the same size as image</param>
            <param name="tempImage">Another temporary image of the same size and same format as eig_image</param>
            <param name="corners">Output parameter. Detected corners</param>
            <param name="cornerCount">Output parameter. Number of detected corners</param>
            <param name="qualityLevel">Multiplier for the maxmin eigenvalue; specifies minimal accepted quality of image corners</param>
            <param name="minDistance">Limit, specifying minimum possible distance between returned corners; Euclidian distance is used</param>
            <param name="mask">Region of interest. The function selects points either in the specified region or in the whole image if the mask is IntPtr.Zero</param>
            <param name="blockSize">Size of the averaging block, passed to underlying cvCornerMinEigenVal or cvCornerHarris used by the function</param>
            <param name="useHarris">If nonzero, Harris operator (cvCornerHarris) is used instead of default cvCornerMinEigenVal.</param>
            <param name="k">Free parameter of Harris detector; used only if <paramref name="useHarris"/> != 0</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvExtractSURF(System.IntPtr,System.IntPtr,System.IntPtr@,System.IntPtr@,System.IntPtr,Emgu.CV.MCvSURFParams,System.Int32)">
            <summary>
            Finds robust features in the image. For each feature it returns its location, size, orientation and optionally the descriptor, basic or extended. The function can be used for object tracking and localization, image stitching etc
            </summary>
            <param name="image">The input 8-bit grayscale image</param>
            <param name="mask">The optional input 8-bit mask. The features are only found in the areas that contain more than 50% of non-zero mask pixels</param>
            <param name="keypoints">The output parameter; double pointer to the sequence of keypoints. This will be the sequence of MCvSURFPoint structures</param>
            <param name="descriptors">The optional output parameter; double pointer to the sequence of descriptors; Depending on the params.extended value, each element of the sequence will be either 64-element or 128-element floating-point (CV_32F) vector. If the parameter is IntPtr.Zero, the descriptors are not computed</param>
            <param name="storage">Memory storage where keypoints and descriptors will be stored</param>
            <param name="parameters">Various algorithm parameters put to the structure CvSURFParams</param>
            <param name="useProvidedKeyPoints">If 1, the provided key points are locations for computing SURF descriptors</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSURFParams(System.Double,System.Int32)">
            <summary>
            Create a CvSURFParams using the specific values
            </summary>
            <param name="hessianThreshold">      
            only features with keypoint.hessian larger than that are extracted.
            good default value is ~300-500 (can depend on the average local contrast and sharpness of the image).
            user can further filter out some features based on their hessian values and other characteristics
            </param>
            <param name="extended">      
            0 means basic descriptors (64 elements each),
            1 means extended descriptors (128 elements each)
            </param>
            <returns>The MCvSURFParams structure</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvExtractMSER(System.IntPtr,System.IntPtr,System.IntPtr@,System.IntPtr,Emgu.CV.Structure.MCvMSERParams)">
            <summary>
            Extracts the contours of Maximally Stable Extremal Regions
            </summary>
            <param name="img">The image where MSER will be extracted</param>
            <param name="mask">The mask for region of interest</param>
            <param name="contours">The contours where MSER will be stored</param>
            <param name="storage">Memory storage</param>
            <param name="parameters">MSER parameters</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvProjectPoints2(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Computes projections of 3D points to the image plane given intrinsic and extrinsic camera parameters. Optionally, the function computes jacobians - matrices of partial derivatives of image points as functions of all the input parameters w.r.t. the particular parameters, intrinsic and/or extrinsic. The jacobians are used during the global optimization in cvCalibrateCamera2 and cvFindExtrinsicCameraParams2. The function itself is also used to compute back-projection error for with current intrinsic and extrinsic parameters.
            Note, that with intrinsic and/or extrinsic parameters set to special values, the function can be used to compute just extrinsic transformation or just intrinsic transformation (i.e. distortion of a sparse set of points). 
            </summary>
            <param name="objectPoints">The array of object points, 3xN or Nx3, where N is the number of points in the view</param>
            <param name="rotationVector">The rotation vector, 1x3 or 3x1</param>
            <param name="translationVector">The translation vector, 1x3 or 3x1</param>
            <param name="intrinsicMatrix">The camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1]. </param>
            <param name="distortionCoeffs">The vector of distortion coefficients, 4x1 or 1x4 [k1, k2, p1, p2]. If it is IntPtr.Zero, all distortion coefficients are considered 0's</param>
            <param name="imagePoints">The output array of image points, 2xN or Nx2, where N is the total number of points in the view</param>
            <param name="dpdrot">Optional Nx3 matrix of derivatives of image points with respect to components of the rotation vector</param>
            <param name="dpdt">Optional Nx3 matrix of derivatives of image points w.r.t. components of the translation vector</param>
            <param name="dpdf">Optional Nx2 matrix of derivatives of image points w.r.t. fx and fy</param>
            <param name="dpdc">Optional Nx2 matrix of derivatives of image points w.r.t. cx and cy</param>
            <param name="dpddist">Optional Nx4 matrix of derivatives of image points w.r.t. distortion coefficients</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFindHomography(System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.HOMOGRAPHY_METHOD,System.Double,System.IntPtr)">
            <summary>
            Finds perspective transformation H=||hij|| between the source and the destination planes
            </summary>
            <param name="srcPoints">Point coordinates in the original plane, 2xN, Nx2, 3xN or Nx3 array (the latter two are for representation in homogenious coordinates), where N is the number of points. </param>
            <param name="dstPoints">Point coordinates in the destination plane, 2xN, Nx2, 3xN or Nx3 array (the latter two are for representation in homogenious coordinates) </param>
            <param name="homography">Output 3x3 homography matrix. Homography matrix is determined up to a scale, thus it is normalized to make h33=1</param>
            <param name="method">The type of the method</param>
            <param name="ransacReprojThreshold">The maximum allowed reprojection error to treat a point pair as an inlier. The parameter is only used in RANSAC-based homography estimation. E.g. if dst_points coordinates are measured in pixels with pixel-accurate precision, it makes sense to set this parameter somewhere in the range ~1..3</param>
            <param name="mask">The optional output mask set by a robust method (RANSAC or LMEDS). </param>
            <returns>1 if the homography matrix is found, 0 otherwise.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalibrateCamera2(System.IntPtr,System.IntPtr,System.IntPtr,System.Drawing.Size,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.CALIB_TYPE)">
            <summary>
            Estimates intrinsic camera parameters and extrinsic parameters for each of the views
            </summary>
            <param name="objectPoints">The joint matrix of object points, 3xN or Nx3, where N is the total number of points in all views</param>
            <param name="imagePoints">The joint matrix of corresponding image points, 2xN or Nx2, where N is the total number of points in all views</param>
            <param name="pointCounts">Vector containing numbers of points in each particular view, 1xM or Mx1, where M is the number of a scene views</param>
            <param name="imageSize">Size of the image, used only to initialize intrinsic camera matrix</param>
            <param name="intrinsicMatrix">The output camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1]. If CV_CALIB_USE_INTRINSIC_GUESS and/or CV_CALIB_FIX_ASPECT_RATION are specified, some or all of fx, fy, cx, cy must be initialized</param>
            <param name="distortionCoeffs">The output 4x1 or 1x4 vector of distortion coefficients [k1, k2, p1, p2]</param>
            <param name="rotationVectors">The output 3xM or Mx3 array of rotation vectors (compact representation of rotation matrices, see cvRodrigues2). </param>
            <param name="translationVectors">The output 3xM or Mx3 array of translation vectors</param>
            <param name="flags">Different flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalibrationMatrixValues(System.IntPtr,System.Int32,System.Int32,System.Double,System.Double,System.Double@,System.Double@,System.Double@,Emgu.CV.Structure.MCvPoint2D64f@,System.Double@)">
            <summary>
            Computes various useful camera (sensor/lens) characteristics using the computed camera calibration matrix, image frame resolution in pixels and the physical aperture size
            </summary>
            <param name="calibMatr">The matrix of intrinsic parameters</param>
            <param name="imgWidth">Image width in pixels</param>
            <param name="imgHeight">Image height in pixels</param>
            <param name="apertureWidth">Aperture width in realworld units (optional input parameter). Set it to 0 if not used</param>
            <param name="apertureHeight">Aperture width in realworld units (optional input parameter). Set it to 0 if not used</param>
            <param name="fovx">Field of view angle in x direction in degrees</param>
            <param name="fovy">Field of view angle in y direction in degrees </param>
            <param name="focalLength">Focal length in realworld units </param>
            <param name="principalPoint">The principal point in realworld units </param>
            <param name="pixelAspectRatio">The pixel aspect ratio ~ fy/f</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFindExtrinsicCameraParams2(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Estimates extrinsic camera parameters using known intrinsic parameters and and extrinsic parameters for each view. The coordinates of 3D object points and their correspondent 2D projections must be specified. This function also minimizes back-projection error
            </summary>
            <param name="objectPoints">The array of object points, 3xN or Nx3, where N is the number of points in the view</param>
            <param name="imagePoints">The array of corresponding image points, 2xN or Nx2, where N is the number of points in the view</param>
            <param name="intrinsicMatrix">The camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1]. </param>
            <param name="distortionCoeffs">The vector of distortion coefficients, 4x1 or 1x4 [k1, k2, p1, p2]. If it is IntPtr.Zero, all distortion coefficients are considered 0's.</param>
            <param name="rotationVector">The output 3x1 or 1x3 rotation vector (compact representation of a rotation matrix, see cvRodrigues2). </param>
            <param name="translationVector">The output 3x1 or 1x3 translation vector</param>
            <param name="useExtrinsicGuess">Use the input rotation and translation parameters as a guess</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvStereoCalibrate(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Drawing.Size,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.Structure.MCvTermCriteria,Emgu.CV.CvEnum.CALIB_TYPE)">
            <summary>
            Estimates transformation between the 2 cameras making a stereo pair. If we have a stereo camera, where the relative position and orientatation of the 2 cameras is fixed, and if we computed poses of an object relative to the fist camera and to the second camera, (R1, T1) and (R2, T2), respectively (that can be done with cvFindExtrinsicCameraParams2), obviously, those poses will relate to each other, i.e. given (R1, T1) it should be possible to compute (R2, T2) - we only need to know the position and orientation of the 2nd camera relative to the 1st camera. That's what the described function does. It computes (R, T) such that:
            R2=R*R1,
            T2=R*T1 + T
            </summary>
            <param name="objectPoints">The joint matrix of object points, 3xN or Nx3, where N is the total number of points in all views</param>
            <param name="imagePoints1">The joint matrix of corresponding image points in the views from the 1st camera, 2xN or Nx2, where N is the total number of points in all views</param>
            <param name="imagePoints2">The joint matrix of corresponding image points in the views from the 2nd camera, 2xN or Nx2, where N is the total number of points in all views</param>
            <param name="pointCounts">Vector containing numbers of points in each view, 1xM or Mx1, where M is the number of views</param>
            <param name="cameraMatrix1">The input/output camera matrices [fxk 0 cxk; 0 fyk cyk; 0 0 1]. If CV_CALIB_USE_INTRINSIC_GUESS or CV_CALIB_FIX_ASPECT_RATIO are specified, some or all of the elements of the matrices must be initialized</param>
            <param name="distCoeffs1">The input/output vectors of distortion coefficients for each camera, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="cameraMatrix2">The input/output camera matrices [fxk 0 cxk; 0 fyk cyk; 0 0 1]. If CV_CALIB_USE_INTRINSIC_GUESS or CV_CALIB_FIX_ASPECT_RATIO are specified, some or all of the elements of the matrices must be initialized</param>
            <param name="distCoeffs2">The input/output vectors of distortion coefficients for each camera, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="imageSize">Size of the image, used only to initialize intrinsic camera matrix</param>
            <param name="R">The rotation matrix between the 1st and the 2nd cameras' coordinate systems </param>
            <param name="T">The translation vector between the cameras' coordinate systems</param>
            <param name="E">The optional output essential matrix</param>
            <param name="F">The optional output fundamental matrix </param>
            <param name="termCrit">Termination criteria for the iterative optimiziation algorithm</param>
            <param name="flags">The calibration flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvStereoRectifyUncalibrated(System.IntPtr,System.IntPtr,System.IntPtr,System.Drawing.Size,System.IntPtr,System.IntPtr,System.Double)">
            <summary>
            computes the rectification transformations without knowing intrinsic parameters of the cameras and their relative position in space, hence the suffix "Uncalibrated". Another related difference from cvStereoRectify is that the function outputs not the rectification transformations in the object (3D) space, but the planar perspective transformations, encoded by the homography matrices H1 and H2. The function implements the following algorithm [Hartley99]. 
            </summary>
            <remarks>
            Note that while the algorithm does not need to know the intrinsic parameters of the cameras, it heavily depends on the epipolar geometry. Therefore, if the camera lenses have significant distortion, it would better be corrected before computing the fundamental matrix and calling this function. For example, distortion coefficients can be estimated for each head of stereo camera separately by using cvCalibrateCamera2 and then the images can be corrected using cvUndistort2
            </remarks>
            <param name="points1">The array of 2D points</param>
            <param name="points2">The array of 2D points</param>
            <param name="F">Fundamental matrix. It can be computed using the same set of point pairs points1 and points2 using cvFindFundamentalMat</param>
            <param name="imageSize">Size of the image</param>
            <param name="H1">The rectification homography matrices for the first images</param>
            <param name="H2">The rectification homography matrices for the second images</param>
            <param name="threshold">If the parameter is greater than zero, then all the point pairs that do not comply the epipolar geometry well enough (that is, the points for which fabs(points2[i]T*F*points1[i])>threshold) are rejected prior to computing the homographies</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvStereoRectify(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Drawing.Size,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.STEREO_RECTIFY_TYPE)">
            <summary>
            computes the rotation matrices for each camera that (virtually) make both camera image planes the same plane. Consequently, that makes all the epipolar lines parallel and thus simplifies the dense stereo correspondence problem. On input the function takes the matrices computed by cvStereoCalibrate and on output it gives 2 rotation matrices and also 2 projection matrices in the new coordinates. The function is normally called after cvStereoCalibrate that computes both camera matrices, the distortion coefficients, R and T
            </summary>
            <param name="cameraMatrix1">The camera matrices [fx_k 0 cx_k; 0 fy_k cy_k; 0 0 1]</param>
            <param name="cameraMatrix2">The camera matrices [fx_k 0 cx_k; 0 fy_k cy_k; 0 0 1]</param>
            <param name="distCoeffs1">The vectors of distortion coefficients for first camera, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="distCoeffs2">The vectors of distortion coefficients for second camera, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="imageSize">Size of the image used for stereo calibration</param>
            <param name="R">The rotation matrix between the 1st and the 2nd cameras' coordinate systems</param>
            <param name="T">The translation vector between the cameras' coordinate systems</param>
            <param name="R1">3x3 Rectification transforms (rotation matrices) for the first camera</param>
            <param name="R2">3x3 Rectification transforms (rotation matrices) for the second camera</param>
            <param name="P1">3x4 Projection matrices in the new (rectified) coordinate systems</param>
            <param name="P2">3x4 Projection matrices in the new (rectified) coordinate systems</param>
            <param name="Q">The optional output disparity-to-depth mapping matrix, 4x4, see cvReprojectImageTo3D. </param>
            <param name="flags">The operation flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvUndistort2(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Transforms the image to compensate radial and tangential lens distortion. The camera matrix and distortion parameters can be determined using cvCalibrateCamera2. For every pixel in the output image the function computes coordinates of the corresponding location in the input image using the formulae in the section beginning. Then, the pixel value is computed using bilinear interpolation. If the resolution of images is different from what was used at the calibration stage, fx, fy, cx and cy need to be adjusted appropriately, while the distortion coefficients remain the same.
            </summary>
            <param name="src">The input (distorted) image</param>
            <param name="dst">The output (corrected) image</param>
            <param name="intrinsicMatrix">The camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1].</param>
            <param name="distortionCoeffs">The vector of distortion coefficients, 4x1 or 1x4 [k1, k2, p1, p2].</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInitUndistortMap(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Pre-computes the undistortion map - coordinates of the corresponding pixel in the distorted image for every pixel in the corrected image. Then, the map (together with input and output images) can be passed to cvRemap function. 
            </summary>
            <param name="intrinsicMatrix">The camera matrix (A) [fx 0 cx; 0 fy cy; 0 0 1]</param>
            <param name="distortionCoeffs">The vector of distortion coefficients, 4x1 or 1x4 [k1, k2, p1, p2]. </param>
            <param name="mapx">The output array of x-coordinates of the map</param>
            <param name="mapy">The output array of y-coordinates of the map</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInitUndistortRectifyMap(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            This function is an extended version of cvInitUndistortMap. That is, in addition to the correction of lens distortion, the function can also apply arbitrary perspective transformation R and finally it can scale and shift the image according to the new camera matrix
            </summary>
            <param name="cameraMatrix">The camera matrix A=[fx 0 cx; 0 fy cy; 0 0 1]</param>
            <param name="distCoeffs">The vector of distortion coefficients, 4x1, 1x4, 5x1 or 1x5</param>
            <param name="R">The rectification transformation in object space (3x3 matrix). R1 or R2, computed by cvStereoRectify can be passed here. If the parameter is IntPtr.Zero, the identity matrix is used</param>
            <param name="newCameraMatrix">The new camera matrix A'=[fx' 0 cx'; 0 fy' cy'; 0 0 1]</param>
            <param name="mapx">The output array of x-coordinates of the map</param>
            <param name="mapy">The output array of y-coordinates of the map</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvUndistortPoints(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Similar to cvInitUndistortRectifyMap and is opposite to it at the same time. 
            The functions are similar in that they both are used to correct lens distortion and to perform the optional perspective (rectification) transformation. 
            They are opposite because the function cvInitUndistortRectifyMap does actually perform the reverse transformation in order to initialize the maps properly, while this function does the forward transformation. 
            </summary>
            <param name="src">The observed point coordinates</param>
            <param name="dst">The ideal point coordinates, after undistortion and reverse perspective transformation. </param>
            <param name="camera_matrix">The camera matrix A=[fx 0 cx; 0 fy cy; 0 0 1]</param>
            <param name="dist_coeffs">The vector of distortion coefficients, 4x1, 1x4, 5x1 or 1x5. </param>
            <param name="R">The rectification transformation in object space (3x3 matrix). R1 or R2, computed by cvStereoRectify can be passed here. If the parameter is IntPtr.Zero, the identity matrix is used.</param>
            <param name="P">The new camera matrix (3x3) or the new projection matrix (3x4). P1 or P2, computed by cvStereoRectify can be passed here. If the parameter is IntPtr.Zero, the identity matrix is used.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFindChessboardCorners(System.IntPtr,System.Drawing.Size,System.Single[0:,0:],System.Int32@,Emgu.CV.CvEnum.CALIB_CB_TYPE)">
            <summary>
            Attempts to determine whether the input image is a view of the chessboard pattern and locate internal chessboard corners
            </summary>
            <param name="image">Source chessboard view; it must be 8-bit grayscale or color image</param>
            <param name="patternSize">The number of inner corners per chessboard row and column</param>
            <param name="corners">The output array of corners detected</param>
            <param name="cornerCount">The output corner counter. If it is not IntPtr.Zero, the function stores there the number of corners found</param>
            <param name="flags">Various operation flags</param>
            <returns>Non-zero value if all the corners have been found and they have been placed in a certain order (row by row, left to right in every row), otherwise, if the function fails to find all the corners or reorder them, it returns 0</returns>
            <remarks>The coordinates detected are approximate, and to determine their position more accurately, the user may use the function cvFindCornerSubPix</remarks>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFindChessboardCorners(System.IntPtr,System.Drawing.Size,System.IntPtr,System.Int32@,Emgu.CV.CvEnum.CALIB_CB_TYPE)">
            <summary>
            Attempts to determine whether the input image is a view of the chessboard pattern and locate internal chessboard corners
            </summary>
            <param name="image">Source chessboard view; it must be 8-bit grayscale or color image</param>
            <param name="patternSize">The number of inner corners per chessboard row and column</param>
            <param name="corners">Pointer to the output array of corners(PointF) detected</param>
            <param name="cornerCount">The output corner counter. If it is not IntPtr.Zero, the function stores there the number of corners found</param>
            <param name="flags">Various operation flags</param>
            <returns>Non-zero value if all the corners have been found and they have been placed in a certain order (row by row, left to right in every row), otherwise, if the function fails to find all the corners or reorder them, it returns 0</returns>
            <remarks>The coordinates detected are approximate, and to determine their position more accurately, the user may use the function cvFindCornerSubPix</remarks>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvDrawChessboardCorners(System.IntPtr,System.Drawing.Size,System.Single[0:,0:],System.Int32,System.Int32)">
            <summary>
            Draws the individual chessboard corners detected (as red circles) in case if the board was not found (pattern_was_found=0) or the colored corners connected with lines when the board was found (pattern_was_found != 0). 
            </summary>
            <param name="image">The destination image; it must be 8-bit color image</param>
            <param name="patternSize">The number of inner corners per chessboard row and column</param>
            <param name="corners">The array of corners detected</param>
            <param name="count">The number of corners</param>
            <param name="patternWasFound">Indicates whether the complete board was found (!=0) or not (=0). One may just pass the return value cvFindChessboardCorners here. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvDrawChessboardCorners(System.IntPtr,System.Drawing.Size,System.Drawing.PointF[],System.Int32,System.Int32)">
            <summary>
            Draws the individual chessboard corners detected (as red circles) in case if the board was not found (pattern_was_found=0) or the colored corners connected with lines when the board was found (pattern_was_found != 0). 
            </summary>
            <param name="image">The destination image; it must be 8-bit color image</param>
            <param name="patternSize">The number of inner corners per chessboard row and column</param>
            <param name="corners">The array of corners detected</param>
            <param name="count">The number of corners</param>
            <param name="patternWasFound">Indicates whether the complete board was found (!=0) or not (=0). One may just pass the return value cvFindChessboardCorners here. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFindFundamentalMat(System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.CV_FM,System.Double,System.Double,System.IntPtr)">
            <summary>
            Calculates fundamental matrix using one of four methods listed above and returns the number of fundamental matrices found (1 or 3) and 0, if no matrix is found. 
            </summary>
            <param name="points1">Array of the first image points of 2xN, Nx2, 3xN or Nx3 size (where N is number of points). Multi-channel 1xN or Nx1 array is also acceptable. The point coordinates should be floating-point (single or double precision) </param>
            <param name="points2">Array of the second image points of the same size and format as points1</param>
            <param name="fundamentalMatrix">The output fundamental matrix or matrices. The size should be 3x3 or 9x3 (7-point method may return up to 3 matrices).</param>
            <param name="method">Method for computing the fundamental matrix </param>
            <param name="param1">Use 3.0 for default. The parameter is used for RANSAC method only. It is the maximum distance from point to epipolar line in pixels, beyond which the point is considered an outlier and is not used for computing the final fundamental matrix. Usually it is set somewhere from 1 to 3. </param>
            <param name="param2">Use 0.99 for default. The parameter is used for RANSAC or LMedS methods only. It denotes the desirable level of confidence of the fundamental matrix estimate. </param>
            <param name="status">The optional pointer to output array of N elements, every element of which is set to 0 for outliers and to 1 for the "inliers", i.e. points that comply well with the estimated epipolar geometry. The array is computed only in RANSAC and LMedS methods. For other methods it is set to all 1?.</param>
            <returns>the number of fundamental matrices found (1 or 3) and 0, if no matrix is found. </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvComputeCorrespondEpilines(System.IntPtr,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            For every point in one of the two images of stereo-pair the function cvComputeCorrespondEpilines finds equation of a line that contains the corresponding point (i.e. projection of the same 3D point) in the other image. Each line is encoded by a vector of 3 elements l=[a,b,c]^T, so that: 
            l^T*[x, y, 1]^T=0, or
            a*x + b*y + c = 0
            From the fundamental matrix definition (see cvFindFundamentalMatrix discussion), line l2 for a point p1 in the first image (which_image=1) can be computed as: 
            l2=F*p1 and the line l1 for a point p2 in the second image (which_image=1) can be computed as: 
            l1=F^T*p2Line coefficients are defined up to a scale. They are normalized (a2+b2=1) are stored into correspondent_lines
            </summary>
            <param name="points">The input points. 2xN, Nx2, 3xN or Nx3 array (where N number of points). Multi-channel 1xN or Nx1 array is also acceptable.</param>
            <param name="whichImage">Index of the image (1 or 2) that contains the points</param>
            <param name="fundamentalMatrix">Fundamental matrix </param>
            <param name="correspondentLines">Computed epilines, 3xN or Nx3 array </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvConvertPointsHomogeneous(System.IntPtr,System.IntPtr)">
            <summary>
            Converts 2D or 3D points from/to homogenious coordinates, or simply copies or transposes the array. In case if the input array dimensionality is larger than the output, each point coordinates are divided by the last coordinate
            </summary>
            <param name="src">The input point array, 2xN, Nx2, 3xN, Nx3, 4xN or Nx4 (where N is the number of points). Multi-channel 1xN or Nx1 array is also acceptable</param>
            <param name="dst">The output point array, must contain the same number of points as the input; The dimensionality must be the same, 1 less or 1 more than the input, and also within 2..4.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateStereoBMState(Emgu.CV.CvEnum.STEREO_BM_TYPE,System.Int32)">
            <summary>
            Creates the stereo correspondence structure and initializes it. It is possible to override any of the parameters at any time between the calls to cvFindStereoCorrespondenceBM
            </summary>
            <param name="type">ID of one of the pre-defined parameter sets. Any of the parameters can be overridden after creating the structure.</param>
            <param name="numberOfDisparities">The number of disparities. If the parameter is 0, it is taken from the preset, otherwise the supplied value overrides the one from preset. </param>
            <returns>Pointer to the stereo correspondece structure</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseStereoBMState(System.IntPtr@)">
            <summary>
            Releases the stereo correspondence structure and all the associated internal buffers
            </summary>
            <param name="state">The state to be released</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFindStereoCorrespondenceBM(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            computes disparity map for the input rectified stereo pair.
            </summary>
            <param name="left">The left single-channel, 8-bit image</param>
            <param name="right">The right image of the same size and the same type</param>
            <param name="disparity">The output single-channel 16-bit signed disparity map of the same size as input images. Its elements will be the computed disparities, multiplied by 16 and rounded to integer's</param>
            <param name="state">Stereo correspondence structure</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFindStereoCorrespondenceBM(System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.Structure.MCvStereoBMState@)">
            <summary>
            Computes disparity map for the input rectified stereo pair.
            </summary>
            <param name="left">The left single-channel, 8-bit image</param>
            <param name="right">The right image of the same size and the same type</param>
            <param name="disparity">The output single-channel 16-bit signed disparity map of the same size as input images. Its elements will be the computed disparities, multiplied by 16 and rounded to integer's</param>
            <param name="state">Stereo correspondence structure</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateStereoGCState(System.Int32,System.Int32)">
            <summary>
            Creates the stereo correspondence structure and initializes it. 
            </summary>
            <param name="numberOfDisparities">The number of disparities. The disparity search range will be state.minDisparity &lt;= disparity &lt; state.minDisparity + state.numberOfDisparities</param>
            <param name="maxIters">Maximum number of iterations. On each iteration all possible (or reasonable) alpha-expansions are tried. The algorithm may terminate earlier if it could not find an alpha-expansion that decreases the overall cost function value</param>
            <returns>The initialized stereo correspondence structure</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseStereoGCState(System.IntPtr@)">
            <summary>
            Releases the stereo correspondence structure and all the associated internal buffers
            </summary>
            <param name="state">A reference to the pointer of StereoGCState structure</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFindStereoCorrespondenceGC(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Computes disparity maps for the input rectified stereo pair
            </summary>
            <param name="left">The left single-channel, 8-bit image</param>
            <param name="right">The right image of the same size and the same type</param>
            <param name="dispLeft">The optional output single-channel 16-bit signed left disparity map of the same size as input images.</param>
            <param name="dispRight">The optional output single-channel 16-bit signed right disparity map of the same size as input images</param>
            <param name="state">Stereo correspondence structure</param>
            <param name="useDisparityGuess">If the parameter is not zero, the algorithm will start with pre-defined disparity maps. Both dispLeft and dispRight should be valid disparity maps. Otherwise, the function starts with blank disparity maps (all pixels are marked as occlusions)</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFindStereoCorrespondenceGC(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.Structure.MCvStereoGCState@,System.Int32)">
            <summary>
            Computes disparity maps for the input rectified stereo pair
            </summary>
            <param name="left">The left single-channel, 8-bit image</param>
            <param name="right">The right image of the same size and the same type</param>
            <param name="dispLeft">The optional output single-channel 16-bit signed left disparity map of the same size as input images.</param>
            <param name="dispRight">The optional output single-channel 16-bit signed right disparity map of the same size as input images</param>
            <param name="state">Stereo correspondence structure</param>
            <param name="useDisparityGuess">If the parameter is not zero, the algorithm will start with pre-defined disparity maps. Both dispLeft and dispRight should be valid disparity maps. Otherwise, the function starts with blank disparity maps (all pixels are marked as occlusions)</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReprojectImageTo3D(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Transforms 1-channel disparity map to 3-channel image, a 3D surface.
            </summary>
            <param name="disparity">Disparity map</param>
            <param name="image3D">3-channel, 16-bit integer or 32-bit floating-point image - the output map of 3D points</param>
            <param name="Q">The reprojection 4x4 matrix, can be arbitrary, e.g. the one, computed by cvStereoRectify</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMeanShift(System.IntPtr,System.Drawing.Rectangle,Emgu.CV.Structure.MCvTermCriteria,Emgu.CV.Structure.MCvConnectedComp@)">
            <summary>
            Iterates to find the object center given its back projection and initial position of search window. The iterations are made until the search window center moves by less than the given value and/or until the function has done the maximum number of iterations. 
            </summary>
            <param name="probImage">Back projection of object histogram</param>
            <param name="window">Initial search window</param>
            <param name="criteria">Criteria applied to determine when the window search should be finished. </param>
            <param name="comp">Resultant structure that contains converged search window coordinates (comp->rect field) and sum of all pixels inside the window (comp->area field). </param>
            <returns>the number of iterations made</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCamShift(System.IntPtr,System.Drawing.Rectangle,Emgu.CV.Structure.MCvTermCriteria,Emgu.CV.Structure.MCvConnectedComp@,Emgu.CV.Structure.MCvBox2D@)">
            <summary>
            Implements CAMSHIFT object tracking algrorithm ([Bradski98]). First, it finds an object center using cvMeanShift and, after that, calculates the object size and orientation. 
            </summary>
            <param name="probImage">Back projection of object histogram </param>
            <param name="window">Initial search window</param>
            <param name="criteria">Criteria applied to determine when the window search should be finished</param>
            <param name="comp">Resultant structure that contains converged search window coordinates (comp->rect field) and sum of all pixels inside the window (comp->area field).</param>
            <param name="box">Circumscribed box for the object. If not IntPtr.Zero, contains object size and orientation</param>
            <returns>number of iterations made within cvMeanShift</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMatchTemplate(System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.TM_TYPE)">
            <summary>
            This function is similiar to cvCalcBackProjectPatch. It slids through image, compares overlapped patches of size wxh with templ using the specified method and stores the comparison results to result
            </summary>
            <param name="image">Image where the search is running. It should be 8-bit or 32-bit floating-point</param>
            <param name="templ">Searched template; must be not greater than the source image and the same data type as the image</param>
            <param name="result">A map of comparison results; single-channel 32-bit floating-point. If image is WxH and templ is wxh then result must be W-w+1xH-h+1.</param>
            <param name="method">Specifies the way the template must be compared with image regions </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMatchShapes(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.CONTOURS_MATCH_TYPE,System.Double)">
            <summary>
            Compares two shapes. The 3 implemented methods all use Hu moments
            </summary>
            <param name="object1">First contour or grayscale image</param>
            <param name="object2">Second contour or grayscale image</param>
            <param name="method">Comparison method</param>
            <param name="parameter">Method-specific parameter (is not used now)</param>
            <returns>The result of the comparison</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSnakeImage(System.IntPtr,System.IntPtr,System.Int32,System.Single[],System.Single[],System.Single[],System.Int32,System.Drawing.Size,Emgu.CV.Structure.MCvTermCriteria,System.Int32)">
            <summary>
            Updates snake in order to minimize its total energy that is a sum of internal energy that depends on contour shape (the smoother contour is, the smaller internal energy is) and external energy that depends on the energy field and reaches minimum at the local energy extremums that correspond to the image edges in case of image gradient.
            </summary>
            <param name="image">The source image or external energy field</param>
            <param name="points">Seq points (snake). </param>
            <param name="length">Number of points in the contour</param>
            <param name="alpha">Weight[s] of continuity energy, single float or array of length floats, one per each contour point</param>
            <param name="beta">Weight[s] of curvature energy, similar to alpha</param>
            <param name="gamma">Weight[s] of image energy, similar to alpha</param>
            <param name="coeffUsage">Variant of usage of the previous three parameters: 
            CV_VALUE indicates that each of alpha, beta, gamma is a pointer to a single value to be used for all points; 
            CV_ARRAY indicates that each of alpha, beta, gamma is a pointer to an array of coefficients different for all the points of the snake. All the arrays must have the size equal to the contour size.
            </param>
            <param name="win">Size of neighborhood of every point used to search the minimum, both win.width and win.height must be odd</param>
            <param name="criteria">Termination criteria</param>
            <param name="calcGradient">
            Gradient flag. If != 0, the function calculates gradient magnitude for every image pixel and consideres it as the energy field, 
            otherwise the input image itself is considered
            </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSnakeImage(System.IntPtr,System.Drawing.Point[],System.Int32,System.Single[],System.Single[],System.Single[],System.Int32,System.Drawing.Size,Emgu.CV.Structure.MCvTermCriteria,System.Int32)">
            <summary>
            Updates snake in order to minimize its total energy that is a sum of internal energy that depends on contour shape (the smoother contour is, the smaller internal energy is) and external energy that depends on the energy field and reaches minimum at the local energy extremums that correspond to the image edges in case of image gradient.
            </summary>
            <param name="image">The source image or external energy field</param>
            <param name="points">Seq points (snake). </param>
            <param name="length">Number of points in the contour</param>
            <param name="alpha">Weight[s] of continuity energy, single float or array of length floats, one per each contour point</param>
            <param name="beta">Weight[s] of curvature energy, similar to alpha</param>
            <param name="gamma">Weight[s] of image energy, similar to alpha</param>
            <param name="coeffUsage">Variant of usage of the previous three parameters: 
            CV_VALUE indicates that each of alpha, beta, gamma is a pointer to a single value to be used for all points; 
            CV_ARRAY indicates that each of alpha, beta, gamma is a pointer to an array of coefficients different for all the points of the snake. All the arrays must have the size equal to the contour size.
            </param>
            <param name="win">Size of neighborhood of every point used to search the minimum, both win.width and win.height must be odd</param>
            <param name="criteria">Termination criteria</param>
            <param name="calcGradient">
            Gradient flag. If != 0, the function calculates gradient magnitude for every image pixel and consideres it as the energy field, 
            otherwise the input image itself is considered
            </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSnakeImage(System.IntPtr,System.IntPtr,System.Int32,System.Single[],System.Single[],System.Single[],System.Int32,System.Drawing.Size,Emgu.CV.Structure.MCvTermCriteria,System.Boolean)">
            <summary>
            Updates snake in order to minimize its total energy that is a sum of internal energy that depends on contour shape (the smoother contour is, the smaller internal energy is) and external energy that depends on the energy field and reaches minimum at the local energy extremums that correspond to the image edges in case of image gradient.
            </summary>
            <param name="image">The source image or external energy field</param>
            <param name="points">Seq points (snake). </param>
            <param name="length">Number of points in the contour</param>
            <param name="alpha">Weight[s] of continuity energy, single float or array of length floats, one per each contour point</param>
            <param name="beta">Weight[s] of curvature energy, similar to alpha</param>
            <param name="gamma">Weight[s] of image energy, similar to alpha</param>
            <param name="coeffUsage">Variant of usage of the previous three parameters: 
            CV_VALUE indicates that each of alpha, beta, gamma is a pointer to a single value to be used for all points; 
            CV_ARRAY indicates that each of alpha, beta, gamma is a pointer to an array of coefficients different for all the points of the snake. All the arrays must have the size equal to the contour size.
            </param>
            <param name="win">Size of neighborhood of every point used to search the minimum, both win.width and win.height must be odd</param>
            <param name="criteria">Termination criteria</param>
            <param name="calcGradient">
            Gradient flag. If true, the function calculates gradient magnitude for every image pixel and consideres it as the energy field, 
            otherwise the input image itself is considered
            </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateStructuringElementEx(System.Int32,System.Int32,System.Int32,System.Int32,Emgu.CV.CvEnum.CV_ELEMENT_SHAPE,System.IntPtr)">
            <summary>
            Creates an structuring element.
            </summary>
            <param name="cols">Number of columns in the structuring element.</param>
            <param name="rows">Number of rows in the structuring element.</param>
            <param name="anchorX">Relative horizontal offset of the anchor point.</param>
            <param name="anchorY">Relative vertical offset of the anchor point.</param>
            <param name="shape">Shape of the structuring element.</param>
            <param name="values">
            Pointer to the structuring element data, representing row-by-row scanning of the element matrix.
            Non-zero values indicate points that belong to the element.
            If the pointer is IntPtr.Zero, then all values are considered non-zero, that is, the element is of a rectangular shape.
            This parameter is considered only if the shape is CV_SHAPE_CUSTOM.
            </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseStructuringElement(System.IntPtr@)">
            <summary>
            Releases the structuring element.
            </summary>
            <param name="ppElement">Pointer to the deallocated structuring element.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMorphologyEx(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.CV_MORPH_OP,System.Int32)">
            <summary>
            Performs advanced morphological transformations.
            </summary>
            <param name="src">Source image.</param>
            <param name="dst">Destination image.</param>
            <param name="temp">
            Temporary image, required in some cases.
            The temporary image temp is required for morphological gradient and, in case of in-place operation, for "top hat" and "black hat".
            </param>
            <param name="element">Structuring element.</param>
            <param name="operation">Type of morphological operation.</param>
            <param name="iterations">Number of times erosion and dilation are applied.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateHist(System.Int32,System.Int32[],Emgu.CV.CvEnum.HIST_TYPE,System.IntPtr[],System.Int32)">
            <summary>
            Creates a histogram of the specified size and returns the pointer to the created histogram. If the array ranges is 0, the histogram bin ranges must be specified later via The function cvSetHistBinRanges, though cvCalcHist and cvCalcBackProject may process 8-bit images without setting bin ranges, they assume equally spaced in 0..255 bins
            </summary>
            <param name="dims">Number of histogram dimensions</param>
            <param name="sizes">Array of histogram dimension sizes</param>
            <param name="type">Histogram representation format: CV_HIST_ARRAY means that histogram data is represented as an multi-dimensional dense array CvMatND; CV_HIST_SPARSE means that histogram data is represented as a multi-dimensional sparse array CvSparseMat</param>
            <param name="ranges">Array of ranges for histogram bins. Its meaning depends on the uniform parameter value. The ranges are used for when histogram is calculated or backprojected to determine, which histogram bin corresponds to which value/tuple of values from the input image[s]. </param>
            <param name="uniform">
            Uniformity flag; 
            if != 0, the histogram has evenly spaced bins and for every 0&lt;=i&lt;cDims ranges[i] is array of two numbers: lower and upper boundaries for the i-th histogram dimension. 
            The whole range [lower,upper] is split then into dims[i] equal parts to determine i-th input tuple value ranges for every histogram bin. 
            And if uniform == 0, then i-th element of ranges array contains dims[i]+1 elements: lower0, upper0, lower1, upper1 == lower2, ..., upperdims[i]-1, where lowerj and upperj are lower and upper boundaries of i-th input tuple value for j-th bin, respectively. 
            In either case, the input values that are beyond the specified range for a histogram bin, are not counted by cvCalcHist and filled with 0 by cvCalcBackProject</param>
            <returns>A pointer to the histogram</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetMinMaxHistValue(System.IntPtr,System.Single@,System.Single@,System.Int32[],System.Int32[])">
            <summary>
            Finds the minimum and maximum histogram bins and their positions
            </summary>
            <remarks>
            Among several extremums with the same value the ones with minimum index (in lexicographical order). 
            In case of several maximums or minimums the earliest in lexicographical order extrema locations are returned.
            </remarks>
            <param name="hist">Histogram</param>
            <param name="minValue">Pointer to the minimum value of the histogram </param>
            <param name="maxValue">Pointer to the maximum value of the histogram </param>
            <param name="minIdx">Pointer to the array of coordinates for minimum </param>
            <param name="maxIdx">Pointer to the array of coordinates for maximum </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvNormalizeHist(System.IntPtr,System.Double)">
            <summary>
            Normalizes the histogram bins by scaling them, such that the sum of the bins becomes equal to factor
            </summary>
            <param name="hist">Pointer to the histogram</param>
            <param name="factor">Normalization factor</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvThreshHist(System.IntPtr,System.Double)">
            <summary>
            Clears histogram bins that are below the specified threshold
            </summary>
            <param name="hist">Pointer to the histogram</param>
            <param name="threshold">Threshold level</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvClearHist(System.IntPtr)">
            <summary>
            Sets all histogram bins to 0 in case of dense histogram and removes all histogram bins in case of sparse array
            </summary>
            <param name="hist">Histogram</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMakeHistHeaderForArray(System.Int32,System.Int32[],System.IntPtr,System.IntPtr,System.IntPtr[],System.Int32)">
            <summary>
            initializes the histogram, which header and bins are allocated by user. No cvReleaseHist need to be called afterwards. Only dense histograms can be initialized this way. 
            </summary>
            <param name="dims">Number of histogram dimensions</param>
            <param name="sizes">Array of histogram dimension sizes</param>
            <param name="hist">Pointer to the histogram</param>
            <param name="data">The underline memory storage (pointer to array of float)</param>
            <param name="ranges">Array of ranges for histogram bins. Its meaning depends on the uniform parameter value. The ranges are used for when histogram is calculated or backprojected to determine, which histogram bin corresponds to which value/tuple of values from the input image[s]. </param>
            <param name="uniform">
            Uniformity flag; 
            if true, the histogram has evenly spaced bins and for every 0&lt;=i&lt;cDims ranges[i] is array of two numbers: lower and upper boundaries for the i-th histogram dimension. 
            The whole range [lower,upper] is split then into dims[i] equal parts to determine i-th input tuple value ranges for every histogram bin. 
            And if uniform=false, then i-th element of ranges array contains dims[i]+1 elements: lower0, upper0, lower1, upper1 == lower2, ..., upperdims[i]-1, where lowerj and upperj are lower and upper boundaries of i-th input tuple value for j-th bin, respectively. 
            In either case, the input values that are beyond the specified range for a histogram bin, are not counted by cvCalcHist and filled with 0 by cvCalcBackProject
            </param>
            <returns>Pointer to the histogram</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateHist(System.Int32,System.Int32[],Emgu.CV.CvEnum.HIST_TYPE,System.IntPtr[],System.Boolean)">
            <summary>
            Creates a histogram of the specified size and returns the pointer to the created histogram. If the array ranges is 0, the histogram bin ranges must be specified later via The function cvSetHistBinRanges, though cvCalcHist and cvCalcBackProject may process 8-bit images without setting bin ranges, they assume equally spaced in 0..255 bins
            </summary>
            <param name="dims">Number of histogram dimensions</param>
            <param name="sizes">Array of histogram dimension sizes</param>
            <param name="type">Histogram representation format: CV_HIST_ARRAY means that histogram data is represented as an multi-dimensional dense array CvMatND; CV_HIST_SPARSE means that histogram data is represented as a multi-dimensional sparse array CvSparseMat</param>
            <param name="ranges">Array of ranges for histogram bins. Its meaning depends on the uniform parameter value. The ranges are used for when histogram is calculated or backprojected to determine, which histogram bin corresponds to which value/tuple of values from the input image[s]. </param>
            <param name="uniform">
            Uniformity flag; 
            if true, the histogram has evenly spaced bins and for every 0&lt;=i&lt;cDims ranges[i] is array of two numbers: lower and upper boundaries for the i-th histogram dimension. 
            The whole range [lower,upper] is split then into dims[i] equal parts to determine i-th input tuple value ranges for every histogram bin. 
            And if uniform=false, then i-th element of ranges array contains dims[i]+1 elements: lower0, upper0, lower1, upper1 == lower2, ..., upperdims[i]-1, where lowerj and upperj are lower and upper boundaries of i-th input tuple value for j-th bin, respectively. 
            In either case, the input values that are beyond the specified range for a histogram bin, are not counted by cvCalcHist and filled with 0 by cvCalcBackProject
            </param>
            <returns>A pointer to the histogram</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcArrHist(System.IntPtr[],System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            Calculates the histogram of one or more single-channel images. The elements of a tuple that is used to increment a histogram bin are taken at the same location from the corresponding input images.
            </summary>
            <param name="image">Source images (though, you may pass CvMat** as well), all are of the same size and type</param>
            <param name="hist">Pointer to the histogram</param>
            <param name="accumulate">Accumulation flag. If it is set, the histogram is not cleared in the beginning. This feature allows user to compute a single histogram from several images, or to update the histogram online</param>
            <param name="mask">The operation mask, determines what pixels of the source images are counted</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcArrHist(System.IntPtr[],System.IntPtr,System.Boolean,System.IntPtr)">
            <summary>
            Calculates the histogram of one or more single-channel images. The elements of a tuple that is used to increment a histogram bin are taken at the same location from the corresponding input images.
            </summary>
            <param name="image">Source images (though, you may pass CvMat** as well), all are of the same size and type</param>
            <param name="hist">Pointer to the histogram</param>
            <param name="accumulate">Accumulation flag. If it is set, the histogram is not cleared in the beginning. This feature allows user to compute a single histogram from several images, or to update the histogram online</param>
            <param name="mask">The operation mask, determines what pixels of the source images are counted</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCopyHist(System.IntPtr,System.IntPtr@)">
            <summary>
            Makes a copy of the histogram. If the second histogram pointer *dst is NULL, a new histogram of the same size as src is created. Otherwise, both histograms must have equal types and sizes. Then the function copies the source histogram bins values to destination histogram and sets the same bin values ranges as in src.
            </summary>
            <param name="src">The source histogram</param>
            <param name="dst">The destination histogram</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCompareHist(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.HISTOGRAM_COMP_METHOD)">
            <summary>
            Compares two dense histograms
            </summary>
            <param name="hist1">The first dense histogram. </param>
            <param name="hist2">The second dense histogram.</param>
            <param name="method">Comparison method</param>
            <returns>Result of the comparison</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcHist(System.IntPtr[],System.IntPtr,System.Boolean,System.IntPtr)">
            <summary>
            Calculates the histogram of one or more single-channel images. The elements of a tuple that is used to increment a histogram bin are taken at the same location from the corresponding input images.
            </summary>
            <param name="image">Source images (though, you may pass CvMat** as well), all are of the same size and type</param>
            <param name="hist">Pointer to the histogram</param>
            <param name="accumulate">Accumulation flag. If it is set, the histogram is not cleared in the beginning. This feature allows user to compute a single histogram from several images, or to update the histogram online</param>
            <param name="mask">The operation mask, determines what pixels of the source images are counted</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcArrBackProject(System.IntPtr[],System.IntPtr,System.IntPtr)">
            <summary>
            Calculates the back project of the histogram. 
            For each tuple of pixels at the same position of all input single-channel images the function puts the value of the histogram bin, corresponding to the tuple, to the destination image. 
            In terms of statistics, the value of each output image pixel is probability of the observed tuple given the distribution (histogram). 
            </summary>
            <example>
            To find a red object in the picture, one may do the following: 
            1. Calculate a hue histogram for the red object assuming the image contains only this object. The histogram is likely to have a strong maximum, corresponding to red color. 
            2. Calculate back projection of a hue plane of input image where the object is searched, using the histogram. Threshold the image. 
            3. Find connected components in the resulting picture and choose the right component using some additional criteria, for example, the largest connected component. 
            That is the approximate algorithm of Camshift color object tracker, except for the 3rd step, instead of which CAMSHIFT algorithm is used to locate the object on the back projection given the previous object position. 
            </example>
            <param name="image">Source images (though you may pass CvMat** as well), all are of the same size and type </param>
            <param name="backProject">Destination back projection image of the same type as the source images</param>
            <param name="hist">Histogram</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvEqualizeHist(System.IntPtr,System.IntPtr)">
            <summary>
            The algorithm normalizes brightness and increases contrast of the image
            </summary>
            <param name="src">The input 8-bit single-channel image</param>
            <param name="dst">The output image of the same size and the same data type as src</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcBackProject(System.IntPtr[],System.IntPtr,System.IntPtr)">
            <summary>
            Calculates the back project of the histogram. 
            For each tuple of pixels at the same position of all input single-channel images the function puts the value of the histogram bin, corresponding to the tuple, to the destination image. 
            In terms of statistics, the value of each output image pixel is probability of the observed tuple given the distribution (histogram). 
            </summary>
            <example>
            To find a red object in the picture, one may do the following: 
            1. Calculate a hue histogram for the red object assuming the image contains only this object. The histogram is likely to have a strong maximum, corresponding to red color. 
            2. Calculate back projection of a hue plane of input image where the object is searched, using the histogram. Threshold the image. 
            3. Find connected components in the resulting picture and choose the right component using some additional criteria, for example, the largest connected component. 
            That is the approximate algorithm of Camshift color object tracker, except for the 3rd step, instead of which CAMSHIFT algorithm is used to locate the object on the back projection given the previous object position. 
            </example>
            <param name="image">Source images (though you may pass CvMat** as well), all are of the same size and type </param>
            <param name="backProject">Destination back projection image of the same type as the source images</param>
            <param name="hist">Histogram</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcBackProjectPatch(System.IntPtr[],System.IntPtr,System.Drawing.Size,System.IntPtr,Emgu.CV.CvEnum.HISTOGRAM_COMP_METHOD,System.Double)">
             <summary>
             Compares histogram, computed over each possible rectangular patch of the specified size in the input images, and stores the results to the output map dst.
             </summary>
             <remarks>In pseudo-code the operation may be written as:
            for (x,y) in images (until (x+patch_size.width-1,y+patch_size.height-1) is inside the images) do
                compute histogram over the ROI (x,y,x+patch_size.width,y+patch_size.height) in images
                   (see cvCalcHist)
                normalize the histogram using the factor
                   (see cvNormalizeHist)
                compare the normalized histogram with input histogram hist using the specified method
                   (see cvCompareHist)
                store the result to dst(x,y)
            end for
            </remarks>
             <param name="images">Source images (though, you may pass CvMat** as well), all of the same size</param>
             <param name="dst">Destination image.</param>
             <param name="patchSize">Size of patch slid though the source images. </param>
             <param name="hist">Histogram </param>
             <param name="method">Comparison methof</param>
             <param name="factor">Normalization factor for histograms, will affect normalization scale of destination image, pass 1. if unsure.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcProbDensity(System.IntPtr,System.IntPtr,System.IntPtr,System.Double)">
            <summary>
            calculates the object probability density from the two histograms as:
            dist_hist(I)=0,      if hist1(I)==0;
            dist_hist(I)=scale,  if hist1(I)!=0 &amp;&amp; hist2(I)&gt;hist1(I);
            dist_hist(I)=hist2(I)*scale/hist1(I), if hist1(I)!=0 &amp;&amp; hist2(I)&lt;=hist1(I)
            </summary>
            <param name="hist1">First histogram (the divisor)</param>
            <param name="hist2">Second histogram.</param>
            <param name="dstHist">Destination histogram. </param>
            <param name="scale">Scale factor for the destination histogram.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseHist(System.IntPtr@)">
            <summary>
            Releases the histogram (header and the data). 
            The pointer to histogram is cleared by the function. 
            If *hist pointer is already NULL, the function does nothing.
            </summary>
            <param name="hist">Double pointer to the released histogram</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcOpticalFlowLK(System.IntPtr,System.IntPtr,System.Drawing.Size,System.IntPtr,System.IntPtr)">
            <summary>
            Computes flow for every pixel of the first input image using Lucas &amp; Kanade algorithm
            </summary>
            <param name="prev">First image, 8-bit, single-channel.</param>
            <param name="curr">Second image, 8-bit, single-channel.</param>
            <param name="winSize">Size of the averaging window used for grouping pixels. </param>
            <param name="velx">Horizontal component of the optical flow of the same size as input images, 32-bit floating-point, single-channel.</param>
            <param name="vely">Vertical component of the optical flow of the same size as input images, 32-bit floating-point, single-channel.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcOpticalFlowHS(System.IntPtr,System.IntPtr,System.Int32,System.IntPtr,System.IntPtr,System.Double,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Computes flow for every pixel of the first input image using Horn &amp; Schunck algorithm 
            </summary>
            <param name="prev">First image, 8-bit, single-channel</param>
            <param name="curr">Second image, 8-bit, single-channel</param>
            <param name="usePrevious">Uses previous (input) velocity field</param>
            <param name="velx">Horizontal component of the optical flow of the same size as input images, 32-bit floating-point, single-channel</param>
            <param name="vely">Vertical component of the optical flow of the same size as input images, 32-bit floating-point, single-channel</param>
            <param name="lambda">Lagrangian multiplier</param>
            <param name="criteria">Criteria of termination of velocity computing</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcOpticalFlowBM(System.IntPtr,System.IntPtr,System.Drawing.Size,System.Drawing.Size,System.Drawing.Size,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            Calculates optical flow for overlapped blocks block_size.width * block_size.height pixels each, thus the velocity fields are smaller than the original images. For every block in prev the functions tries to find a similar block in curr in some neighborhood of the original block or shifted by (velx(x0,y0),vely(x0,y0)) block as has been calculated by previous function call (if use_previous=1)
            </summary>
            <param name="prev">First image, 8-bit, single-channel.</param>
            <param name="curr">Second image, 8-bit, single-channel. </param>
            <param name="blockSize">Size of basic blocks that are compared.</param>
            <param name="shiftSize">Block coordinate increments. </param>
            <param name="maxRange">Size of the scanned neighborhood in pixels around block.</param>
            <param name="usePrevious">Uses previous (input) velocity field. </param>
            <param name="velx">Horizontal component of the optical flow of floor((prev->width - block_size.width)/shiftSize.width) x floor((prev->height - block_size.height)/shiftSize.height) size, 32-bit floating-point, single-channel. </param>
            <param name="vely">Vertical component of the optical flow of the same size velx, 32-bit floating-point, single-channel.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcOpticalFlowPyrLK(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Single[0:,0:],System.Single[0:,0:],System.Int32,System.Drawing.Size,System.Int32,System.Byte[],System.Single[],Emgu.CV.Structure.MCvTermCriteria,Emgu.CV.CvEnum.LKFLOW_TYPE)">
            <summary>
            Implements sparse iterative version of Lucas-Kanade optical flow in pyramids ([Bouguet00]). It calculates coordinates of the feature points on the current video frame given their coordinates on the previous frame. The function finds the coordinates with sub-pixel accuracy. 
            </summary>
            <remarks>Both parameters prev_pyr and curr_pyr comply with the following rules: if the image pointer is 0, the function allocates the buffer internally, calculates the pyramid, and releases the buffer after processing. Otherwise, the function calculates the pyramid and stores it in the buffer unless the flag CV_LKFLOW_PYR_A[B]_READY is set. The image should be large enough to fit the Gaussian pyramid data. After the function call both pyramids are calculated and the readiness flag for the corresponding image can be set in the next call (i.e., typically, for all the image pairs except the very first one CV_LKFLOW_PYR_A_READY is set). </remarks>
            <param name="prev">First frame, at time t. </param>
            <param name="curr">Second frame, at time t + dt .</param>
            <param name="prevPyr">Buffer for the pyramid for the first frame. If the pointer is not NULL , the buffer must have a sufficient size to store the pyramid from level 1 to level #level ; the total size of (image_width+8)*image_height/3 bytes is sufficient. </param>
            <param name="currPyr">Similar to prev_pyr, used for the second frame. </param>
            <param name="prevFeatures">Array of points for which the flow needs to be found. </param>
            <param name="currFeatures">Array of 2D points containing calculated new positions of input </param>
            <param name="count">Number of feature points.</param>
            <param name="winSize">Size of the search window of each pyramid level.</param>
            <param name="level">Maximal pyramid level number. If 0 , pyramids are not used (single level), if 1 , two levels are used, etc. </param>
            <param name="status">Array. Every element of the array is set to 1 if the flow for the corresponding feature has been found, 0 otherwise.</param>
            <param name="trackError">Array of double numbers containing difference between patches around the original and moved points. Optional parameter; can be NULL </param>
            <param name="criteria">Specifies when the iteration process of finding the flow for each point on each pyramid level should be stopped.</param>
            <param name="flags">Miscellaneous flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcOpticalFlowPyrLK(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Drawing.PointF[],System.Drawing.PointF[],System.Int32,System.Drawing.Size,System.Int32,System.Byte[],System.Single[],Emgu.CV.Structure.MCvTermCriteria,Emgu.CV.CvEnum.LKFLOW_TYPE)">
            <summary>
            Implements sparse iterative version of Lucas-Kanade optical flow in pyramids ([Bouguet00]). It calculates coordinates of the feature points on the current video frame given their coordinates on the previous frame. The function finds the coordinates with sub-pixel accuracy. 
            </summary>
            <remarks>Both parameters prev_pyr and curr_pyr comply with the following rules: if the image pointer is 0, the function allocates the buffer internally, calculates the pyramid, and releases the buffer after processing. Otherwise, the function calculates the pyramid and stores it in the buffer unless the flag CV_LKFLOW_PYR_A[B]_READY is set. The image should be large enough to fit the Gaussian pyramid data. After the function call both pyramids are calculated and the readiness flag for the corresponding image can be set in the next call (i.e., typically, for all the image pairs except the very first one CV_LKFLOW_PYR_A_READY is set). </remarks>
            <param name="prev">First frame, at time t. </param>
            <param name="curr">Second frame, at time t + dt .</param>
            <param name="prevPyr">Buffer for the pyramid for the first frame. If the pointer is not NULL , the buffer must have a sufficient size to store the pyramid from level 1 to level #level ; the total size of (image_width+8)*image_height/3 bytes is sufficient. </param>
            <param name="currPyr">Similar to prev_pyr, used for the second frame. </param>
            <param name="prevFeatures">Array of points for which the flow needs to be found. </param>
            <param name="currFeatures">Array of 2D points containing calculated new positions of input </param>
            <param name="count">Number of feature points.</param>
            <param name="winSize">Size of the search window of each pyramid level.</param>
            <param name="level">Maximal pyramid level number. If 0 , pyramids are not used (single level), if 1 , two levels are used, etc. </param>
            <param name="status">Array. Every element of the array is set to 1 if the flow for the corresponding feature has been found, 0 otherwise.</param>
            <param name="trackError">Array of double numbers containing difference between patches around the original and moved points. Optional parameter; can be NULL </param>
            <param name="criteria">Specifies when the iteration process of finding the flow for each point on each pyramid level should be stopped.</param>
            <param name="flags">Miscellaneous flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcOpticalFlowFarneback(System.IntPtr,System.IntPtr,System.IntPtr,System.Double,System.Int32,System.Int32,System.Int32,System.Int32,System.Double,Emgu.CV.CvEnum.OPTICALFLOW_FARNEBACK_FLAG)">
            <summary>
            Computes dense optical flow using Gunnar Farneback's algorithm
            </summary>
            <param name="prev0">The first 8-bit single-channel input image</param>
            <param name="next0">The second input image of the same size and the same type as prevImg</param>
            <param name="flow0">The computed flow image; will have the same size as prevImg and type CV 32FC2</param>
            <param name="pyrScale">Specifies the image scale (!1) to build the pyramids for each image. pyrScale=0.5 means the classical pyramid, where each next layer is twice smaller than the previous</param>
            <param name="levels">The number of pyramid layers, including the initial image. levels=1 means that no extra layers are created and only the original images are used</param>
            <param name="winSize">The averaging window size; The larger values increase the algorithm robustness to image noise and give more chances for fast motion detection, but yield more blurred motion field</param>
            <param name="iterations">The number of iterations the algorithm does at each pyramid level</param>
            <param name="polyN">Size of the pixel neighborhood used to find polynomial expansion in each pixel. The larger values mean that the image will be approximated with smoother surfaces, yielding more robust algorithm and more blurred motion field. Typically, poly n=5 or 7</param>
            <param name="polySigma">Standard deviation of the Gaussian that is used to smooth derivatives that are used as a basis for the polynomial expansion. For poly n=5 you can set poly sigma=1.1, for poly n=7 a good value would be poly sigma=1.5</param>
            <param name="flags">The operation flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetSpatialMoment(Emgu.CV.Structure.MCvMoments@,System.Int32,System.Int32)">
            <summary>
            Retrieves the spatial moment, which in case of image moments is defined as:
            M_{x_order,y_order}=sum_{x,y}(I(x,y) * x^{x_order} * y^{y_order})
            where I(x,y) is the intensity of the pixel (x, y). 
            </summary>
            <param name="moments">The moment state</param>
            <param name="xOrder">x order of the retrieved moment, xOrder &gt;= 0. </param>
            <param name="yOrder">y order of the retrieved moment, yOrder &gt;= 0 and xOrder + y_order &lt;= 3</param>
            <returns>The spatial moment</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetCentralMoment(Emgu.CV.Structure.MCvMoments@,System.Int32,System.Int32)">
            <summary>
            Retrieves the central moment, which in case of image moments is defined as:
            mu_{x_order,y_order}=sum_{x,y}(I(x,y)*(x-x_c)^{x_order} * (y-y_c)^{y_order}),
            where x_c=M10/M00, y_c=M01/M00 - coordinates of the gravity center
            </summary>
            <param name="moments">Reference to the moment state structure</param>
            <param name="xOrder">x order of the retrieved moment, xOrder &gt;= 0.</param>
            <param name="yOrder">y order of the retrieved moment, yOrder &gt;= 0 and xOrder + y_order &lt;= 3</param>
            <returns>The center moment</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetNormalizedCentralMoment(Emgu.CV.Structure.MCvMoments@,System.Int32,System.Int32)">
            <summary>
            Retrieves normalized central moment, which in case of image moments is defined as:
            eta_{x_order,y_order}=mu_{x_order,y_order} / M00^{(y_order+x_order)/2+1},
            where mu_{x_order,y_order} is the central moment
            </summary>
            <param name="moments">Reference to the moment state structure</param>
            <param name="xOrder">x order of the retrieved moment, xOrder &gt;= 0.</param>
            <param name="yOrder">y order of the retrieved moment, yOrder &gt;= 0 and xOrder + y_order &lt;= 3</param>
            <returns>The normalized center moment</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvAcc(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Adds the whole image or its selected region to accumulator sum
            </summary>
            <param name="image">Input image, 1- or 3-channel, 8-bit or 32-bit floating point. (each channel of multi-channel image is processed independently). </param>
            <param name="sum">Accumulator of the same number of channels as input image, 32-bit or 64-bit floating-point. </param>
            <param name="mask">Optional operation mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSquareAcc(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Adds the input image image or its selected region, raised to power 2, to the accumulator sqsum
            </summary>
            <param name="image">Input image, 1- or 3-channel, 8-bit or 32-bit floating point (each channel of multi-channel image is processed independently)</param>
            <param name="sqsum">Accumulator of the same number of channels as input image, 32-bit or 64-bit floating-point</param>
            <param name="mask">Optional operation mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMultiplyAcc(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Adds product of 2 images or thier selected regions to accumulator acc
            </summary>
            <param name="image1">First input image, 1- or 3-channel, 8-bit or 32-bit floating point (each channel of multi-channel image is processed independently)</param>
            <param name="image2">Second input image, the same format as the first one</param>
            <param name="acc">Accumulator of the same number of channels as input images, 32-bit or 64-bit floating-point</param>
            <param name="mask">Optional operation mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvRunningAvg(System.IntPtr,System.IntPtr,System.Double,System.IntPtr)">
            <summary>
            Calculates weighted sum of input image image and the accumulator acc so that acc becomes a running average of frame sequence:
            acc(x,y)=(1-<paramref name="alpha"/>) * acc(x,y) + <paramref name="alpha"/> * image(x,y) if mask(x,y)!=0
            where <paramref name="alpha"/> regulates update speed (how fast accumulator forgets about previous frames). 
            </summary>
            <param name="image">Input image, 1- or 3-channel, 8-bit or 32-bit floating point (each channel of multi-channel image is processed independently). </param>
            <param name="acc">Accumulator of the same number of channels as input image, 32-bit or 64-bit floating-point. </param>
            <param name="alpha">Weight of input image</param>
            <param name="mask">Optional operation mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvRodrigues2(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Converts a rotation vector to rotation matrix or vice versa. Rotation vector is a compact representation of rotation matrix. Direction of the rotation vector is the rotation axis and the length of the vector is the rotation angle around the axis. 
            </summary>
            <param name="src">The input rotation vector (3x1 or 1x3) or rotation matrix (3x3). </param>
            <param name="dst">The output rotation matrix (3x3) or rotation vector (3x1 or 1x3), respectively</param>
            <param name="jacobian">Optional output Jacobian matrix, 3x9 or 9x3 - partial derivatives of the output array components w.r.t the input array components</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetHuMoments(Emgu.CV.Structure.MCvMoments@,Emgu.CV.Structure.MCvHuMoments@)">
            <summary>
            Calculates seven Hu invariants
            </summary>
            <param name="moments">Pointer to the moment state structure</param>
            <param name="hu_moments">Pointer to Hu moments structure.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateKalman(System.Int32,System.Int32,System.Int32)">
            <summary>
            Allocates CvKalman and all its matrices and initializes them somehow. 
            </summary>
            <param name="dynamParams">dimensionality of the state vector</param>
            <param name="measureParams">dimensionality of the measurement vector </param>
            <param name="controlParams">dimensionality of the control vector </param>
            <returns>Pointer to the created Kalman filter</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvKalmanCorrect(System.IntPtr,System.IntPtr)">
            <summary>
            Adjusts stochastic model state on the basis of the given measurement of the model state.
            The function stores adjusted state at kalman->state_post and returns it on output
            </summary>
            <param name="kalman">Pointer to the structure to be updated</param>
            <param name="measurement">Pointer to the structure CvMat containing the measurement vector</param>
            <returns>The function stores adjusted state at kalman->state_post and returns it on output</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvKalmanCorrect(Emgu.CV.Structure.MCvKalman@,System.IntPtr)">
            <summary>
            Adjusts stochastic model state on the basis of the given measurement of the model state.
            The function stores adjusted state at kalman->state_post and returns it on output
            </summary>
            <param name="kalman">Pointer to the structure to be updated</param>
            <param name="measurement">Pointer to the structure CvMat containing the measurement vector</param>
            <returns>The function stores adjusted state at kalman->state_post and returns it on output</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvKalmanPredict(System.IntPtr,System.IntPtr)">
            <summary>
            Estimates the subsequent stochastic model state by its current state and stores it at kalman->state_pre
            The function returns the estimated state
            </summary>
            <param name="kalman">Kalman filter state</param>
            <param name="control">Control vector (uk), should be NULL iff there is no external control (controlParams=0). </param>
            <returns>the estimated state</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvKalmanPredict(Emgu.CV.Structure.MCvKalman@,System.IntPtr)">
            <summary>
            Estimates the subsequent stochastic model state by its current state and stores it at kalman->state_pre
            The function returns the estimated state
            </summary>
            <param name="kalman">Kalman filter state</param>
            <param name="control">Control vector (uk), should be NULL iff there is no external control (controlParams=0). </param>
            <returns>the estimated state</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseKalman(System.IntPtr@)">
            <summary>
            Releases the structure CvKalman and all underlying matrices
            </summary>
            <param name="kalman">reference of the pointer to the Kalman filter structure.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvUpdateMotionHistory(System.IntPtr,System.IntPtr,System.Double,System.Double)">
            <summary>
            Updates the motion history image as following:
            mhi(x,y)=timestamp  if silhouette(x,y)!=0
                    0          if silhouette(x,y)=0 and mhi(x,y)&lt;timestamp-duration
                    mhi(x,y)   otherwise
            That is, MHI pixels where motion occurs are set to the current timestamp, while the pixels where motion happened far ago are cleared. 
            </summary>
            <param name="silhouette">Silhouette mask that has non-zero pixels where the motion occurs. </param>
            <param name="mhi">Motion history image, that is updated by the function (single-channel, 32-bit floating-point) </param>
            <param name="timestamp">Current time in milliseconds or other units. </param>
            <param name="duration">Maximal duration of motion track in the same units as timestamp. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcMotionGradient(System.IntPtr,System.IntPtr,System.IntPtr,System.Double,System.Double,System.Int32)">
             <summary>
             Calculates the derivatives Dx and Dy of mhi and then calculates gradient orientation as:
            orientation(x,y)=arctan(Dy(x,y)/Dx(x,y))
            where both Dx(x,y)' and Dy(x,y)' signs are taken into account (as in cvCartToPolar function). After that mask is filled to indicate where the orientation is valid (see delta1 and delta2 description). 
             </summary>
             <param name="mhi">Motion history image</param>
             <param name="mask">Mask image; marks pixels where motion gradient data is correct. Output parameter.</param>
             <param name="orientation">Motion gradient orientation image; contains angles from 0 to ~360. </param>
             <param name="delta1">The function finds minimum (m(x,y)) and maximum (M(x,y)) mhi values over each pixel (x,y) neihborhood and assumes the gradient is valid only if min(delta1,delta2) &lt;= M(x,y)-m(x,y) &lt;= max(delta1,delta2). </param>
             <param name="delta2">The function finds minimum (m(x,y)) and maximum (M(x,y)) mhi values over each pixel (x,y) neihborhood and assumes the gradient is valid only if min(delta1,delta2) &lt;= M(x,y)-m(x,y) &lt;= max(delta1,delta2).</param>
             <param name="apertureSize">Aperture size of derivative operators used by the function: CV_SCHARR, 1, 3, 5 or 7 (see cvSobel). </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCornerHarris(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Double)">
            <summary>
            Runs the Harris edge detector on image. Similarly to cvCornerMinEigenVal and cvCornerEigenValsAndVecs, for each pixel it calculates 2x2 gradient covariation matrix M over block_size x block_size neighborhood. Then, it stores
            det(M) - k*trace(M)^2
            to the destination image. Corners in the image can be found as local maxima of the destination image.
            </summary>
            <param name="image">Input image</param>
            <param name="harrisResponce">Image to store the Harris detector responces. Should have the same size as image </param>
            <param name="blockSize">Neighborhood size </param>
            <param name="apertureSize">Aperture parameter for Sobel operator (see cvSobel). format. In the case of floating-point input format this parameter is the number of the fixed float filter used for differencing. </param>
            <param name="k">Harris detector free parameter.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFindCornerSubPix(System.IntPtr,System.Single[0:,0:],System.Int32,System.Drawing.Size,System.Drawing.Size,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Iterates to find the sub-pixel accurate location of corners, or radial saddle points
            </summary>
            <param name="image">Input image</param>
            <param name="corners">Initial coordinates of the input corners and refined coordinates on output</param>
            <param name="count">Number of corners</param>
            <param name="win">Half sizes of the search window. For example, if win=(5,5) then 5*2+1 x 5*2+1 = 11 x 11 search window is used</param>
            <param name="zeroZone">Half size of the dead region in the middle of the search zone over which the summation in formulae below is not done. It is used sometimes to avoid possible singularities of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such size</param>
            <param name="criteria">Criteria for termination of the iterative process of corner refinement. That is, the process of corner position refinement stops either after certain number of iteration or when a required accuracy is achieved. The criteria may specify either of or both the maximum number of iteration and the required accuracy</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFindCornerSubPix(System.IntPtr,System.Drawing.PointF[],System.Int32,System.Drawing.Size,System.Drawing.Size,Emgu.CV.Structure.MCvTermCriteria)">
            <summary>
            Iterates to find the sub-pixel accurate location of corners, or radial saddle points
            </summary>
            <param name="image">Input image</param>
            <param name="corners">Initial coordinates of the input corners and refined coordinates on output</param>
            <param name="count">Number of corners</param>
            <param name="win">Half sizes of the search window. For example, if win=(5,5) then 5*2+1 x 5*2+1 = 11 x 11 search window is used</param>
            <param name="zeroZone">Half size of the dead region in the middle of the search zone over which the summation in formulae below is not done. It is used sometimes to avoid possible singularities of the autocorrelation matrix. The value of (-1,-1) indicates that there is no such size</param>
            <param name="criteria">Criteria for termination of the iterative process of corner refinement. That is, the process of corner position refinement stops either after certain number of iteration or when a required accuracy is achieved. The criteria may specify either of or both the maximum number of iteration and the required accuracy</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvIntegral(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Calculates one or more integral images for the source image 
            Using these integral images, one may calculate sum, mean, standard deviation over arbitrary up-right or rotated rectangular region of the image in a constant time.
            It makes possible to do a fast blurring or fast block correlation with variable window size etc. In case of multi-channel images sums for each channel are accumulated independently. 
            </summary>
            <param name="image">The source image, WxH, 8-bit or floating-point (32f or 64f) image.</param>
            <param name="sum">The integral image, W+1xH+1, 32-bit integer or double precision floating-point (64f). </param>
            <param name="sqsum">The integral image for squared pixel values, W+1xH+1, double precision floating-point (64f). </param>
            <param name="tiltedSum">The integral for the image rotated by 45 degrees, W+1xH+1, the same data type as sum.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvDistTransform(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.DIST_TYPE,System.Int32,System.Single[],System.IntPtr)">
            <summary>
            Calculates distance to closest zero pixel for all non-zero pixels of source image
            </summary>
            <param name="src">Source 8-bit single-channel (binary) image.</param>
            <param name="dst">Output image with calculated distances (32-bit floating-point, single-channel). </param>
            <param name="distanceType">Type of distance</param>
            <param name="maskSize">Size of distance transform mask; can be 3 or 5.
            In case of CV_DIST_L1 or CV_DIST_C the parameter is forced to 3, because 3x3 mask gives the same result as 5x5 yet it is faster.</param>
            <param name="userMask">User-defined mask in case of user-defined distance.
            It consists of 2 numbers (horizontal/vertical shift cost, diagonal shift cost) in case of 3x3 mask
            and 3 numbers (horizontal/vertical shift cost, diagonal shift cost, knights move cost) in case of 5x5 mask.</param>
            <param name="labels">The optional output 2d array of labels of integer type and the same size as src and dst.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFloodFill(System.IntPtr,System.Drawing.Point,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvConnectedComp@,System.Int32,System.IntPtr)">
            <summary>
            Fills a connected component with given color.
            </summary>
            <param name="src">Input 1- or 3-channel, 8-bit or floating-point image. It is modified by the function unless CV_FLOODFILL_MASK_ONLY flag is set.</param>
            <param name="seedPoint">The starting point.</param>
            <param name="newVal">New value of repainted domain pixels.</param>
            <param name="loDiff">Maximal lower brightness/color difference
            between the currently observed pixel and one of its neighbor belong to the component
            or seed pixel to add the pixel to component.
            In case of 8-bit color images it is packed value.</param>
            <param name="upDiff">Maximal upper brightness/color difference
            between the currently observed pixel and one of its neighbor belong to the component
            or seed pixel to add the pixel to component.
            In case of 8-bit color images it is packed value.</param>
            <param name="comp">Pointer to structure the function fills with the information about the repainted domain.</param>
            <param name="flags">The operation flags.
            Lower bits contain connectivity value, 4 (by default) or 8, used within the function.
            Connectivity determines which neighbors of a pixel are considered.
            Upper bits can be 0 or combination of the following flags:
            CV_FLOODFILL_FIXED_RANGE - if set the difference between the current pixel and seed pixel is considered,
            otherwise difference between neighbor pixels is considered (the range is floating).
            CV_FLOODFILL_MASK_ONLY - if set, the function does not fill the image (new_val is ignored),
            but the fills mask (that must be non-NULL in this case). </param>
            <param name="mask">Operation mask,
            should be singe-channel 8-bit image, 2 pixels wider and 2 pixels taller than image.
            If not IntPtr.Zero, the function uses and updates the mask, so user takes responsibility of initializing mask content.
            Floodfilling can't go across non-zero pixels in the mask, for example, an edge detector output can be used as a mask to stop filling at edges.
            Or it is possible to use the same mask in multiple calls to the function to make sure the filled area do not overlap.
            Note: because mask is larger than the filled image, pixel in mask that corresponds to (x,y) pixel in image will have coordinates (x+1,y+1).</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFloodFill(System.IntPtr,System.Drawing.Point,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvConnectedComp@,Emgu.CV.CvEnum.CONNECTIVITY,Emgu.CV.CvEnum.FLOODFILL_FLAG,System.IntPtr)">
            <summary>
            Fills a connected component with given color.
            </summary>
            <param name="src">Input 1- or 3-channel, 8-bit or floating-point image. It is modified by the function unless CV_FLOODFILL_MASK_ONLY flag is set.</param>
            <param name="seedPoint">The starting point.</param>
            <param name="newVal">New value of repainted domain pixels.</param>
            <param name="loDiff">Maximal lower brightness/color difference
            between the currently observed pixel and one of its neighbor belong to the component
            or seed pixel to add the pixel to component.
            In case of 8-bit color images it is packed value.</param>
            <param name="upDiff">Maximal upper brightness/color difference
            between the currently observed pixel and one of its neighbor belong to the component
            or seed pixel to add the pixel to component.
            In case of 8-bit color images it is packed value.</param>
            <param name="comp">Pointer to structure the function fills with the information about the repainted domain.</param>
            <param name="mask">Operation mask,
            should be singe-channel 8-bit image, 2 pixels wider and 2 pixels taller than image.
            If not IntPtr.Zero, the function uses and updates the mask, so user takes responsibility of initializing mask content.
            Floodfilling can't go across non-zero pixels in the mask, for example, an edge detector output can be used as a mask to stop filling at edges.
            Or it is possible to use the same mask in multiple calls to the function to make sure the filled area do not overlap.
            Note: because mask is larger than the filled image, pixel in mask that corresponds to (x,y) pixel in image will have coordinates (x+1,y+1).</param>
            <param name="connectivity">The connectivity of flood fill</param>
            <param name="flags">The flood fill types</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcEMD2(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.DIST_TYPE,Emgu.CV.CvInvoke.CvDistanceFunction,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Computes earth mover distance and/or a lower boundary of the distance
            between the two weighted point configurations. One of the application
            desctibed in [RubnerSept98] is multi-dimensional histogram comparison
            for image retrieval. EMD is a transportation problem that is solved
            using some modification of simplex algorithm, thus the complexity is
            exponential in the worst case, though, it is much faster in average.
            In case of a real metric the lower boundary can be calculated even
            faster (using linear-time algorithm) and it can be used to determine
            roughly whether the two signatures are far enough so that they cannot
            relate to the same object.
            </summary>
            <param name="signature1">
            First signature, size1*dims+1 floating-point matrix. Each row stores the point weight followed by the point coordinates. The matrix is allowed to have a single column (weights only) if the user-defined cost matrix is used.
            </param>
            <param name="signature2">Second signature of the same format as signature1, though the number of rows may be different. The total weights may be different, in this case an extra "dummy" point is added to either signature1 or signature2. </param>
            <param name="distType">Metrics used; CV_DIST_L1, CV_DIST_L2, and CV_DIST_C stand for one of the standard metrics; CV_DIST_USER means that a user-defined function distance_func or pre-calculated cost_matrix is used. </param>
            <param name="distFunc">The user-defined distance function. It takes coordinates of two points and returns the distance between the points.</param>
            <param name="costMatrix">The user-defined size1*size2 cost matrix. At least one of cost_matrix and distance_func must be NULL. Also, if a cost matrix is used, lower boundary (see below) can not be calculated, because it needs a metric function.</param>
            <param name="flow">The resultant size1*size2 flow matrix: flow,,ij,, is a flow from i-th point of signature1 to j-th point of signature2</param>
            <param name="lowerBound">
            Optional input/output parameter: lower boundary of
            distance between the two signatures that is a distance between mass centers.
            The lower boundary may not be calculated if the user-defined cost matrix
            is used, the total weights of point configurations are not equal, or there
            is the signatures consist of weights only (i.e. the signature matrices have
            a single column). User must initialize *lower_bound. If the calculated
            distance between mass centers is greater or equal to *lower_bound
            (it means that the signatures are far enough) the function does not
            calculate EMD. In any case *lower_bound is set to the calculated
            distance between mass centers on return. Thus, if user wants to
            calculate both distance between mass centers and EMD, *lower_bound should
            be set to 0.
            </param>
            <param name="userParam">Pointer to optional data that is passed into the user-defined distance function. </param>
            <returns>"minimal work" distance between two weighted point configurations</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetStarKeypoints(System.IntPtr,System.IntPtr,Emgu.CV.StarDetector)">
            <summary>
            Retrieve the star keypoint location from the specific image
            </summary>
            <param name="img">The image to detect start keypoints</param>
            <param name="storage">The storage for the returned sequence</param>
            <param name="param">The star detector parameters</param>
            <returns>Pointer to the sequence of star keypoint locations</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvEigenDecomposite(System.IntPtr,System.IntPtr[],System.IntPtr)">
            <summary>
            Calculates all decomposition coefficients for the input object using the previously calculated eigen objects basis and the averaged object
            </summary>
            <param name="obj">Input object (Pointer to IplImage)</param>
            <param name="eigInput">Pointer to the array of IplImage input objects</param>
            <param name="avg">Averaged object (Pointer to IplImage)</param>
            <returns>Calculated coefficients; an output parameter</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvEigenDecomposite(System.IntPtr,System.Int32,System.IntPtr[],Emgu.CV.CvEnum.EIGOBJ_TYPE,System.IntPtr,System.IntPtr,System.Single[])">
            <summary>
            Calculates all decomposition coefficients for the input object using the previously calculated eigen objects basis and the averaged object
            </summary>
            <param name="obj">Input object (Pointer to IplImage)</param>
            <param name="eigenvecCount">Number of eigen objects</param>
            <param name="eigInput">Pointer either to the array of IplImage input objects or to the read callback function according to the value of the parameter <paramref name="ioFlags"/></param>
            <param name="ioFlags">Input/output flags</param>
            <param name="userData">Pointer to the structure that contains all necessary data for the callback functions</param>
            <param name="avg">Averaged object (Pointer to IplImage)</param>
            <param name="coeffs">Calculated coefficients; an output parameter</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcEigenObjects(System.IntPtr[],Emgu.CV.Structure.MCvTermCriteria@,System.IntPtr[],System.Single[],System.IntPtr)">
            <summary>
            Calculates orthonormal eigen basis and the averaged object for a group of the input objects.
            </summary>
            <param name="input">Pointer to the array of IplImage input objects </param>
            <param name="calcLimit">Criteria that determine when to stop calculation of eigen objects. Depending on the parameter calcLimit, calculations are finished either after first calcLimit.max_iter dominating eigen objects are retrieved or if the ratio of the current eigenvalue to the largest eigenvalue comes down to calcLimit.epsilon threshold. The value calcLimit -> type must be CV_TERMCRIT_NUMB, CV_TERMCRIT_EPS, or CV_TERMCRIT_NUMB | CV_TERMCRIT_EPS . The function returns the real values calcLimit->max_iter and calcLimit->epsilon</param>
            <param name="avg">Averaged object</param>
            <param name="eigVals">Pointer to the eigenvalues array in the descending order; may be NULL</param>
            <param name="eigVecs">Pointer either to the array of eigen objects</param>
            <returns>Pointer either to the array of eigen objects or to the write callback function</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcEigenObjects(System.Int32,System.IntPtr[],System.IntPtr[],Emgu.CV.CvEnum.EIGOBJ_TYPE,System.Int32,System.IntPtr,Emgu.CV.Structure.MCvTermCriteria@,System.IntPtr,System.Single[])">
            <summary>
            Calculates orthonormal eigen basis and the averaged object for a group of the input objects.
            </summary>
            <param name="nObjects">Number of source objects</param>
            <param name="input">Pointer either to the array of IplImage input objects or to the read callback function</param>
            <param name="output">Pointer either to the array of eigen objects or to the write callback function</param>
            <param name="ioFlags">Input/output flags</param>
            <param name="ioBufSize">Input/output buffer size in bytes. The size is zero, if unknown</param>
            <param name="userData">Pointer to the structure that contains all necessary data for the callback functions</param>
            <param name="calcLimit">Criteria that determine when to stop calculation of eigen objects. Depending on the parameter calcLimit, calculations are finished either after first calcLimit.max_iter dominating eigen objects are retrieved or if the ratio of the current eigenvalue to the largest eigenvalue comes down to calcLimit.epsilon threshold. The value calcLimit -> type must be CV_TERMCRIT_NUMB, CV_TERMCRIT_EPS, or CV_TERMCRIT_NUMB | CV_TERMCRIT_EPS . The function returns the real values calcLimit->max_iter and calcLimit->epsilon</param>
            <param name="avg">Averaged object</param>
            <param name="eigVals">Pointer to the eigenvalues array in the descending order; may be NULL</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvEigenProjection(System.IntPtr[],System.Single[],System.IntPtr,System.IntPtr)">
            <summary>
            Calculates an object projection to the eigen sub-space or, in other words, restores an object using previously calculated eigen objects basis, averaged object, and decomposition coefficients of the restored object. 
            </summary>
            <param name="inputVecs">Pointer to either an array of IplImage input objects or to a callback function, depending on io_flags</param>
            <param name="coeffs">Previously calculated decomposition coefficients</param>
            <param name="avg">Average vector</param>
            <param name="proj">Projection to the eigen sub-space</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvEigenProjection(System.IntPtr[],System.Int32,Emgu.CV.CvEnum.EIGOBJ_TYPE,System.IntPtr,System.Single[],System.IntPtr,System.IntPtr)">
            <summary>
            Calculates an object projection to the eigen sub-space or, in other words, restores an object using previously calculated eigen objects basis, averaged object, and decomposition coefficients of the restored object. Depending on io_flags parameter it may be used either in direct access or callback mode.
            </summary>
            <param name="inputVecs">Pointer to either an array of IplImage input objects or to a callback function, depending on io_flags</param>
            <param name="eigenvecCount">Number of eigenvectors</param>
            <param name="ioFlags">Input/output flags</param>
            <param name="userdata">Pointer to the structure that contains all necessary data for the callback functions</param>
            <param name="coeffs">Previously calculated decomposition coefficients</param>
            <param name="avg">Average vector</param>
            <param name="proj">Projection to the eigen sub-space</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateGaussianBGModel(System.IntPtr,System.IntPtr)">
            <summary>
            Create a Gaussian background model
            </summary>
            <param name="image">Background image</param>
            <param name="param">Parameters for the background model</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateFGDStatModel(System.IntPtr,System.IntPtr)">
            <summary>
            Create a background model
            </summary>
            <param name="image">Background image</param>
            <param name="param">Parameters for the background model</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateFGDStatModel(System.IntPtr,Emgu.CV.Structure.MCvFGDStatModelParams@)">
            <summary>
            Create a forground model
            </summary>
            <param name="firstFrame">The first frame</param>
            <param name="parameters">The forground statistic parameters</param>
            <returns>Pointer to the forground model</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFindStereoCorrespondence(System.IntPtr,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Calculates disparity for stereo-pair 
            </summary>
            <param name="leftImage">Left image of stereo pair, rectified grayscale 8-bit image</param>
            <param name="rightImage">Right image of stereo pair, rectified grayscale 8-bit image</param>
            <param name="mode">Algorithm used to find a disparity</param>
            <param name="depthImage">Destination depth image, grayscale 8-bit image that codes the scaled disparity, so that the zero disparity (corresponding to the points that are very far from the cameras) maps to 0, maximum disparity maps to 255.</param>
            <param name="maxDisparity">Maximum possible disparity. The closer the objects to the cameras, the larger value should be specified here. Too big values slow down the process significantly</param>
            <param name="param1">constant occlusion penalty</param>
            <param name="param2">constant match reward</param>
            <param name="param3">defines a highly reliable region (set of contiguous pixels whose reliability is at least param3)</param>
            <param name="param4">defines a moderately reliable region</param>
            <param name="param5">defines a slightly reliable region</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateConDensation(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates CvConDensation structure and returns pointer to the structure
            </summary>
            <param name="dynamParams">Dimension of the state vector</param>
            <param name="measureParams">Dimension of the measurement vector</param>
            <param name="sampleCount">Number of samples</param>
            <returns>Pointer to the CvConDensation structure</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseConDensation(System.IntPtr@)">
            <summary>
            Releases the structure CvConDensation (see cvConDensation) and frees all memory previously allocated for the structure. 
            </summary>
            <param name="condens">Pointer to the CvConDensation structure</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvConDensInitSampleSet(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Fills the samples arrays in the structure CvConDensation with values within specified ranges. 
            </summary>
            <param name="condens">Pointer to a structure to be initialized</param>
            <param name="lowerBound">Vector of the lower boundary for each dimension</param>
            <param name="upperBound">Vector of the upper boundary for each dimension</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvConDensUpdateByTime(System.IntPtr)">
            <summary>
            Estimates the subsequent stochastic model state from its current state
            </summary>
            <param name="condens">Pointer to the structure to be updated</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcPGH(System.IntPtr,System.IntPtr)">
            <summary>
            Calculates 2D pair-wise geometrical histogram (PGH), described in [Iivarinen97], for the contour. The algorithm considers every pair of the contour edges. The angle between the edges and the minimum/maximum distances are determined for every pair. To do this each of the edges in turn is taken as the base, while the function loops through all the other edges. When the base edge and any other edge are considered, the minimum and maximum distances from the points on the non-base edge and line of the base edge are selected. The angle between the edges defines the row of the histogram in which all the bins that correspond to the distance between the calculated minimum and maximum distances are incremented (that is, the histogram is transposed relatively to [Iivarninen97] definition). The histogram can be used for contour matching
            </summary>
            <param name="contour">Input contour. Currently, only integer point coordinates are allowed</param>
            <param name="hist">Calculated histogram; must be two-dimensional</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.icvSubdiv2DCheck(System.IntPtr)">
            <summary>
            Checks planar subdivision for correctness. It is not an absolute check, but it verifies some relations between quad-edges
            </summary>
            <param name="subdiv">Pointer to the MCvSubdiv2D</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateBGCodeBookModel">
            <summary>
            Create a BG code book model
            </summary>
            <returns>Poionter to BG code book model</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvBGCodeBookUpdate(System.IntPtr,System.IntPtr,System.Drawing.Rectangle,System.IntPtr)">
            <summary>
            Update the BG code book model
            </summary>
            <param name="model">Pointer to the BGCodeBookModel</param>
            <param name="image">The image for update</param>
            <param name="roi">The update roi, use Rectangle.Empty for the whole image</param>
            <param name="mask">Can be IntPtr.Zero if not needed. The update mask. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvBGCodeBookDiff(System.IntPtr,System.IntPtr,System.IntPtr,System.Drawing.Rectangle)">
            <summary>
            
            </summary>
            <param name="model">Pointer to the BGCodeBookModel</param>
            <param name="image">The image to find diff</param>
            <param name="fgmask">The returned forground mask</param>
            <param name="roi">The region of interest for the diff. Use Rectangle.Empty for the whole image</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvBGCodeBookClearStale(System.IntPtr,System.Int32,System.Drawing.Rectangle,System.IntPtr)">
            <summary>
            
            </summary>
            <param name="model"></param>
            <param name="staleThresh"></param>
            <param name="roi"></param>
            <param name="mask"></param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseBGCodeBookModel(System.IntPtr@)">
            <summary>
            Release the BG code book model
            </summary>
            <param name="model">The BG code book model to be released</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvCreateFGDetectorBase(Emgu.CV.CvEnum.FORGROUND_DETECTOR_TYPE,System.IntPtr)">
            <summary>
            Create a simple forground detector
            </summary>
            <param name="type">The type of the detector</param>
            <param name="param">Pointer to the parameters of the detector</param>
            <returns>Pointer the to forground detector</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvFGDetectorGetMask(System.IntPtr)">
            <summary>
            Get the forground mask from the forground detector
            </summary>
            <param name="detector">The forground detector</param>
            <returns>The forground mask</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvFGDetectorProcess(System.IntPtr,System.IntPtr)">
            <summary>
            Update the FGDetector with new image
            </summary>
            <param name="detector">The forground detector</param>
            <param name="image">The image which will be used to update the FGDetector</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvCreateFGDetectorBase(Emgu.CV.CvEnum.FORGROUND_DETECTOR_TYPE,Emgu.CV.Structure.MCvFGDStatModelParams@)">
            <summary>
            Create a simple forground detector
            </summary>
            <param name="type">The type of the detector</param>
            <param name="param">The parameters of the detector</param>
            <returns>Pointer the to forground detector</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvFGDetectorRelease(System.IntPtr)">
            <summary>
            Release the forground detector
            </summary>
            <param name="detector">The forground detector to be released</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvBlobSeqCreate(System.Int32)">
            <summary>
            Create a BlobSeq
            </summary>
            <param name="blobSize">The size of the blob in bytes</param>
            <returns>Pointer to the BlobSeq</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvBlobSeqRelease(System.IntPtr)">
            <summary>
            Release the blob sequence
            </summary>
            <param name="blobSeq">The BlobSeq to be released</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvBlobSeqGetBlob(System.IntPtr,System.Int32)">
            <summary>
            Get the specific blob from the blob sequence
            </summary>
            <param name="blobSeq">the blob sequence</param>
            <param name="blobIndex">the index of the blob to be retrieved</param>
            <returns>Pointer to the specific blob</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvBlobSeqGetBlobByID(System.IntPtr,System.Int32)">
            <summary>
            Get the specific blob from the blob sequence
            </summary>
            <param name="blobSeq">the blob sequence</param>
            <param name="blobIndex">the index of the blob to be retrieved</param>
            <returns>Pointer to the specific blob</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvBlobSeqGetBlobNum(System.IntPtr)">
            <summary>
            Get the number of blob in the blob sequence
            </summary>
            <param name="blobSeq">The blob sequence</param>
            <returns>The number of blob in the blob sequence</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvBlobDetectorRelease(System.IntPtr)">
            <summary>
            Release the blob detector
            </summary>
            <param name="detector">the detector to be released</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvBlobDetectorDetectNewBlob(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Detect new blobs.
            </summary>
            <param name="detector">The blob detector</param>
            <param name="img">The image</param>
            <param name="imgFG">The forground mask</param>
            <param name="newBlobList">The new blob list</param>
            <param name="oldBlobList">The old blob list</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvCreateBlobDetectorSimple">
            <summary>
            Get a simple blob detector 
            </summary>
            <returns>Pointer to the blob detector</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvCreateBlobDetectorCC">
            <summary>
            Get a CC blob detector 
            </summary>
            <returns>Pointer to the blob detector</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvCreateBlobTrackerCC">
            <summary>
            Simple blob tracker based on connected component tracking
            </summary>
            <returns>Pointer to the blob tracker</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvCreateBlobTrackerCCMSPF">
            <summary>
            Connected component tracking and mean-shift particle filter collion-resolver
            </summary>
            <returns>Pointer to the blob tracker</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvCreateBlobTrackerMSFG">
            <summary>
            Blob tracker that integrates meanshift and connected components
            </summary>
            <returns>Pointer to the blob tracker</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvCreateBlobTrackerMSFGS">
            <summary>
            Blob tracker that integrates meanshift and connected components:
            </summary>
            <returns>Pointer to the blob tracker</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvCreateBlobTrackerMS">
            <summary>
            Meanshift without connected-components
            </summary>
            <returns>Pointer to the blob tracker</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvCreateBlobTrackerMSPF">
            <summary>
            Particle filtering via Bhattacharya coefficient, which
            is roughly the dot-product of two probability densities.
            </summary>
            <remarks>See: Real-Time Tracking of Non-Rigid Objects using Mean Shift Comanicius, Ramesh, Meer, 2000, 8p</remarks>
            <returns>Pointer to the blob tracker</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvBlobTrackerRealease(System.IntPtr)">
            <summary>
            Release the blob tracker
            </summary>
            <param name="tracker">The tracker to be released</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvBlobTrackerGetBlobNum(System.IntPtr)">
            <summary>
            Return number of currently tracked blobs
            </summary>
            <param name="tracker">The tracker</param>
            <returns>Number of currently tracked blobs</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvBlobTrackerGetBlob(System.IntPtr,System.Int32)">
            <summary>
            Return pointer to specified by index blob
            </summary>
            <param name="tracker">The tracker</param>
            <param name="blobIndex">The index of the blob</param>
            <returns>Pointer to the blob with the specific index</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvBlobTrackerGetBlobByID(System.IntPtr,System.Int32)">
            <summary>
            Return pointer to specified by index blob
            </summary>
            <param name="tracker">The tracker</param>
            <param name="blobId">The id of the blob</param>
            <returns>Pointer to the blob with specific id</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvBlobTrackerDelBlob(System.IntPtr,System.Int32)">
            <summary>
            Delete blob by its index
            </summary>
            <param name="tracker">The tracker</param>
            <param name="blobIndex">The index of the blob</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvBlobTrackerAddBlob(System.IntPtr,Emgu.CV.Structure.MCvBlob@,System.IntPtr,System.IntPtr)">
            <summary>
            Add new blob to track it and assign to this blob personal ID
            </summary>
            <param name="tracker">The tracker</param>
            <param name="blob">pointer to structure with blob parameters (ID is ignored)</param>
            <param name="currentImage">current image</param>
            <param name="currentForgroundMask">current foreground mask</param>
            <returns>Pointer to new added blob</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvCreateModuleBlobTrackPostProcKalman">
            <summary>
            Returns a Kalman blob tracking post process module
            </summary>
            <returns>Pointer to the tracking module</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvCreateModuleBlobTrackPostProcTimeAverRect">
            <summary>
            Returns a TimeAverRect blob tracking post process module
            </summary>
            <returns>Pointer to the tracking module</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvCreateModuleBlobTrackPostProcTimeAverExp">
            <summary>
            Returns a TimeAverExp blob tracking post process module
            </summary>
            <returns>Pointer to the tracking module</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvBlobTrackPostProcRelease(System.IntPtr)">
            <summary>
            Release the blob tracking post process module
            </summary>
            <param name="postProc">The post process module to be released</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvCreateBlobTrackerAuto1(Emgu.CV.Structure.MCvBlobTrackerAutoParam1@)">
            <summary>
            Create blob tracker auto ver1
            </summary>
            <param name="param">The parameters for the tracker</param>
            <returns>Pointer to the blob tracker auto</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvBlobTrackerAutoRelease(System.IntPtr)">
            <summary>
            Release the blob tracker auto
            </summary>
            <param name="tracker">The tracker to be released</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvBlobTrackerAutoGetBlob(System.IntPtr,System.Int32)">
            <summary>
            Get the blob of specific index from the auto blob tracker
            </summary>
            <param name="tracker">The auto blob tracker</param>
            <param name="index">The index of the blob</param>
            <returns>Pointer to the the blob</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvBlobTrackerAutoGetBlobByID(System.IntPtr,System.Int32)">
            <summary>
            Get the blob of specific id from the auto blob tracker
            </summary>
            <param name="tracker">The auto blob tracker</param>
            <param name="blobID">The id of the blob</param>
            <returns>Pointer to the blob of specific ID</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvBlobTrackerAutoGetBlobNum(System.IntPtr)">
            <summary>
            Get the number of blobs in the auto blob tracker 
            </summary>
            <param name="tracker">The auto blob tracker</param>
            <returns>The number of blobs</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvBlobTrackerAutoProcess(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Process a image frame
            </summary>
            <param name="tracker">The auto blob tracker</param>
            <param name="pImg">The frame to process</param>
            <param name="pMask">The forground mask, can be IntPtr.Zero if not needed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvBlobTrackerAutoGetFGMask(System.IntPtr)">
            <summary>
            Get the forground mask
            </summary>
            <param name="tracker">The auto blob tracker</param>
            <returns>Pointer to the forground mask</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvFASTKeyPoints(System.IntPtr,System.IntPtr,System.Int32,System.Boolean)">
            <summary>
            Extract FAST keypoints
            </summary>
            <param name="image">The image to extract keypoint from</param>
            <param name="KeyPointSeq">The pre-allocated sequence of MKeyPoints where the result will be stored</param>
            <param name="threshold"></param>
            <param name="nonmaxSupression">Indicates if nonmaximum supression should be used</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvGrabCut(System.IntPtr,System.IntPtr,System.Drawing.Rectangle@,System.IntPtr,System.IntPtr,System.Int32,Emgu.CV.CvEnum.GRABCUT_INIT_TYPE)">
            <summary>
            The grab cut algorithm for segmentation
            </summary>
            <param name="img">The image to be segmented</param>
            <param name="mask">The mask to initialize segmentation</param>
            <param name="rect">The rectangle to initialize the segmentation</param>
            <param name="bgdModel">The background model</param>
            <param name="fgdModel">The forground model</param>
            <param name="iterCount">The number of iternations</param>
            <param name="type">The initilization type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetModuleInfo(System.IntPtr,System.IntPtr@,System.IntPtr@)">
            <summary>
            Returns information about one of or all of the registered modules
            </summary>
            <param name="moduleName">Name of the module of interest, or IntPtr.Zero, which means all the modules.</param>
            <param name="version">Information about the module(s), including version</param>
            <param name="loadedAddonPlugins">The list of names and versions of the optimized plugins that CXCORE was able to find and load</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetMemoryManager(Emgu.CV.CvInvoke.CvAllocFunc,Emgu.CV.CvInvoke.CvFreeFunc,System.IntPtr)">
            <summary>
            The function cvSetMemoryManager sets user-defined memory managment functions (substitutors for malloc and free) that will be called by cvAlloc, cvFree and higher-level functions (e.g. cvCreateImage)
            </summary>
            <param name="allocFunc">Allocation function</param>
            <param name="freeFunc">Deallocation function</param>
            <param name="userdata">User data that is transparetly passed to the custom functions</param>
        </member>
        <member name="F:Emgu.CV.CvInvoke.CvErrorHandlerThrowException">
            <summary>
            The default Exception callback to handle Error thrown by OpenCV
            </summary>
        </member>
        <member name="F:Emgu.CV.CvInvoke.CvErrorHandlerIgnoreError">
            <summary>
            An error handler which will ignore any error and continute
            </summary>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvIgnoreErrorErrorHandler(System.Int32,System.String,System.String,System.String,System.Int32,System.IntPtr)">
            <summary>
            A custome error handler for opencv
            </summary>
            <param name="status">The numeric code for error status</param>
            <param name="funcName">The source file name where error is encountered</param>
            <param name="errMsg">A description of the error</param>
            <param name="fileName">The source file name where error is encountered</param>
            <param name="line">The line number in the souce where error is encountered</param>
            <param name="userData">Arbitrary pointer that is transparetly passed to the error handler.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CvErrorHandler(System.Int32,System.String,System.String,System.String,System.Int32,System.IntPtr)">
            <summary>
            A custome error handler for opencv
            </summary>
            <param name="status">The numeric code for error status</param>
            <param name="funcName">The source file name where error is encountered</param>
            <param name="errMsg">A description of the error</param>
            <param name="fileName">The source file name where error is encountered</param>
            <param name="line">The line number in the souce where error is encountered</param>
            <param name="userData">Arbitrary pointer that is transparetly passed to the error handler.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvRedirectError(Emgu.CV.CvInvoke.CvErrorCallback,System.IntPtr,System.IntPtr)">
            <summary>
            Sets a new error handler that can be one of standard handlers or a custom handler that has the certain interface. The handler takes the same parameters as cvError function. If the handler returns non-zero value, the program is terminated, otherwise, it continues. The error handler may check the current error mode with cvGetErrMode to make a decision.
            </summary>
            <param name="errorHandler">The new error handler</param>
            <param name="userdata">Arbitrary pointer that is transparetly passed to the error handler.</param>
            <param name="prevUserdata">Pointer to the previously assigned user data pointer.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvRedirectError(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Sets a new error handler that can be one of standard handlers or a custom handler that has the certain interface. The handler takes the same parameters as cvError function. If the handler returns non-zero value, the program is terminated, otherwise, it continues. The error handler may check the current error mode with cvGetErrMode to make a decision.
            </summary>
            <param name="errorHandler">Pointer to the new error handler</param>
            <param name="userdata">Arbitrary pointer that is transparetly passed to the error handler.</param>
            <param name="prevUserdata">Pointer to the previously assigned user data pointer.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetErrMode(System.Int32)">
            <summary>
            Sets the specified error mode.
            </summary>
            <param name="errorMode">The error mode</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetErrMode">
            <summary>
            Returns the current error mode
            </summary>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetErrStatus">
            <summary>
            Returns the current error status - the value set with the last cvSetErrStatus call. Note, that in Leaf mode the program terminates immediately after error occured, so to always get control after the function call, one should call cvSetErrMode and set Parent or Silent error mode.
            </summary>
            <returns>the current error status</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetErrStatus(Emgu.CV.CvEnum.ERROR_CODES)">
            <summary>
            Sets the error status to the specified value. Mostly, the function is used to reset the error status (set to it CV_StsOk) to recover after error. In other cases it is more natural to call cvError or CV_ERROR.
            </summary>
            <param name="code">The error status.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateSeq(System.Int32,System.Int32,System.Int32,System.IntPtr)">
            <summary>
            Creates a sequence and returns the pointer to it. The function allocates the sequence header in the storage block as one continuous chunk and sets the structure fields flags, elem_size, header_size and storage to passed values, sets delta_elems to the default value (that may be reassigned using cvSetSeqBlockSize function), and clears other header fields, including the space after the first sizeof(CvSeq) bytes
            </summary>
            <param name="seqFlags">Flags of the created sequence. If the sequence is not passed to any function working with a specific type of sequences, the sequence value may be set to 0, otherwise the appropriate type must be selected from the list of predefined sequence types</param>
            <param name="headerSize">Size of the sequence header; must be greater or equal to sizeof(CvSeq). If a specific type or its extension is indicated, this type must fit the base type header</param>
            <param name="elemSize">Size of the sequence elements in bytes. The size must be consistent with the sequence type. For example, for a sequence of points to be created, the element type CV_SEQ_ELTYPE_POINT should be specified and the parameter elem_size must be equal to sizeof(CvPoint). </param>
            <param name="storage">Sequence location.</param>
            <returns>A pointer to the sequence</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSeqPush(System.IntPtr,System.IntPtr)">
            <summary>
            Adds an element to the end of sequence and retuns pointer to the allocated element. If the input element is NULL, the function simply allocates a space for one more element.
            </summary>
            <param name="seq">Sequence</param>
            <param name="element">Added element</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSeqPushFront(System.IntPtr,System.IntPtr)">
            <summary>
            Adds an element to the front of sequence and retuns pointer to the allocated element. If the input element is NULL, the function simply allocates a space for one more element.
            </summary>
            <param name="seq">Sequence</param>
            <param name="element">Added element</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSeqPop(System.IntPtr,System.IntPtr)">
            <summary>
            Removes element from sequence end.
            </summary>
            <param name="seq">Sequence</param>
            <param name="element">If the pointer is not zero, the function copies the removed element to this location</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSeqPopFront(System.IntPtr,System.IntPtr)">
            <summary>
            Removes element from sequence beginning.
            </summary>
            <param name="seq">Sequence</param>
            <param name="element">If the pointer is not zero, the function copies the removed element to this location</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSeqRemove(System.IntPtr,System.Int32)">
            <summary>
            Removes element from sequence middle
            </summary>
            <param name="seq">Sequence</param>
            <param name="index">Index of removed element</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSeqInsert(System.IntPtr,System.Int32,System.IntPtr)">
            <summary>
            Shifts the sequence elements from the inserted position to the nearest end of the sequence and copies the element content there if the pointer is not IntPtr.Zero
            </summary>
            <param name="seq">Sequence</param>
            <param name="beforeIndex">Index before which the element is inserted. Inserting before 0 (the minimal allowed value of the parameter) is equal to cvSeqPushFront and inserting before seq->total (the maximal allowed value of the parameter) is equal to cvSeqPush</param>
            <param name="element">Inserted element</param>
            <returns>Pointer to the inserted element</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSeqPushMulti(System.IntPtr,System.IntPtr,System.Int32,Emgu.CV.CvEnum.BACK_OR_FRONT)">
            <summary>
            Adds several elements to either end of the sequence. The elements are added to the sequence in the same order as they are arranged in the input array but they can fall into different sequence blocks.
            </summary>
            <param name="seq">Sequence</param>
            <param name="elements">Added elements</param>
            <param name="count">Number of elements to push</param>
            <param name="backOrFront">
            If != 0, the elements are added to the beginning of sequence;
            Otherwise the elements are added to the end of sequence </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSeqPopMulti(System.IntPtr,System.IntPtr,System.Int32,Emgu.CV.CvEnum.BACK_OR_FRONT)">
            <summary>
            Removes several elements from either end of the sequence. If the number of the elements to be removed exceeds the total number of elements in the sequence, the function removes as many elements as possible
            </summary>
            <param name="seq">Sequence</param>
            <param name="elements">Removed elements</param>
            <param name="count">Number of elements to remove</param>
            <param name="backOrFront">
            If != 0, the elements are added to the beginning of sequence;
            Otherwise the elements are added to the end of sequence </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvChangeSeqBlock(Emgu.CV.Structure.MCvSeqReader@,System.Int32)">
            <summary>
            
            </summary>
            <param name="reader"></param>
            <param name="direction"></param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CV_NEXT_SEQ_ELEM(System.Int32,Emgu.CV.Structure.MCvSeqReader@)">
            <summary>
            Move to the next element in the sequence
            </summary>
            <param name="elemSize">the size of the element</param>
            <param name="reader">the sequence reader</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CV_READ_SEQ_ELEM``1(Emgu.CV.Structure.MCvSeqReader@)">
            <summary>
            forward reading the sequence reader
            </summary>
            <typeparam name="T">The type of structure to be read</typeparam>
            <param name="reader">The sequence reader</param>
            <returns>The read object</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.CV_IS_SET_ELEM(System.IntPtr)">
            <summary>
            Determined whether the specified node is occupied or not
            </summary>
            <param name="ptr">Pointer to the node</param>
            <returns>true if the specified node is occupied</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvStartReadSeq(System.IntPtr,Emgu.CV.Structure.MCvSeqReader@,System.Boolean)">
            <summary>
            Initializes the reader state
            </summary>
            <param name="seq">Sequence</param>
            <param name="reader">Reader state; initialized by the function</param>
            <param name="reverse">Determines the direction of the sequence traversal. If reverse is 0, the reader is positioned at the first sequence element, otherwise it is positioned at the last element.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetSeqElem(System.IntPtr,System.Int32)">
            <summary>
            Finds the element with the given index in the sequence and returns the pointer to it. If the element is not found, the function returns 0. The function supports negative indices, where -1 stands for the last sequence element, -2 stands for the one before last, etc. If the sequence is most likely to consist of a single sequence block or the desired element is likely to be located in the first block, then the macro CV_GET_SEQ_ELEM( elemType, seq, index ) should be used, where the parameter elemType is the type of sequence elements ( CvPoint for example), the parameter seq is a sequence, and the parameter index is the index of the desired element. The macro checks first whether the desired element belongs to the first block of the sequence and returns it if it does, otherwise the macro calls the main function GetSeqElem. Negative indices always cause the cvGetSeqElem call. The function has O(1) time complexity assuming that number of blocks is much smaller than the number of elements.
            </summary>
            <param name="seq">Sequence</param>
            <param name="index">Index of element</param>
            <returns>the pointer to the element with the given index in the sequence</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvClearSeq(System.IntPtr)">
            <summary>
            Removes all elements from the sequence. The function does not return the memory to the storage, but this memory is reused later when new elements are added to the sequence. This function time complexity is O(1). 
            </summary>
            <param name="seq">Sequence</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReshape(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            initializes CvMat header so that it points to the same data as the original array but has different shape - different number of channels, different number of rows or both
            </summary>
            <param name="arr">Input array</param>
            <param name="header">Output header to be filled</param>
            <param name="new_cn">New number of channels. new_cn = 0 means that number of channels remains unchanged</param>
            <param name="new_rows">New number of rows. new_rows = 0 means that number of rows remains unchanged unless it needs to be changed according to new_cn value. destination array to be changed</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvRepeat(System.IntPtr,System.IntPtr)">
            <summary>
            Fills the destination array with source array tiled:
            dst(i,j)=src(i mod rows(src), j mod cols(src))So the destination array may be as larger as well as smaller than the source array
            </summary>
            <param name="src">Source array, image or matrix</param>
            <param name="dst">Destination array, image or matrix</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMerge(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            This function is the opposite to cvSplit. If the destination array has N channels then if the first N input channels are not IntPtr.Zero, all they are copied to the destination array, otherwise if only a single source channel of the first N is not IntPtr.Zero, this particular channel is copied into the destination array, otherwise an error is raised. Rest of source channels (beyond the first N) must always be IntPtr.Zero. For IplImage cvCopy with COI set can be also used to insert a single channel into the image. 
            </summary>
            <param name="src0">Input channels.</param>
            <param name="src1">Input channels.</param>
            <param name="src2">Input channels.</param>
            <param name="src3">Input channels.</param>
            <param name="dst">Destination array. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMixChannels(System.IntPtr[],System.Int32,System.IntPtr[],System.Int32,System.Int32[],System.Int32)">
            <summary>
            The function cvMixChannels is a generalized form of cvSplit and cvMerge and some forms of cvCvtColor. It can be used to change the order of the planes, add/remove alpha channel, extract or insert a single plane or multiple planes etc.
            </summary>
            <param name="src">The array of input arrays.</param>
            <param name="srcCount">The number of input arrays</param>
            <param name="dst">The array of output arrays</param>
            <param name="dstCount">The number of output arrays</param>
            <param name="fromTo">The array of pairs of indices of the planes copied. from_to[k*2] is the 0-based index of the input plane, and from_to[k*2+1] is the index of the output plane, where the continuous numbering of the planes over all the input and over all the output arrays is used. When from_to[k*2] is negative, the corresponding output plane is filled with 0's.</param>
            <param name="pairCount">The number of pairs in from_to, or the number of the planes copied</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMixChannels(System.IntPtr[],System.IntPtr[],System.Int32[])">
            <summary>
            The function cvMixChannels is a generalized form of cvSplit and cvMerge and some forms of cvCvtColor. It can be used to change the order of the planes, add/remove alpha channel, extract or insert a single plane or multiple planes etc.
            </summary>
            <param name="src">The array of input arrays.</param>
            <param name="dst">The array of output arrays</param>
            <param name="fromTo">The array of pairs of indices of the planes copied. from_to[k*2] is the 0-based index of the input plane, and from_to[k*2+1] is the index of the output plane, where the continuous numbering of the planes over all the input and over all the output arrays is used. When from_to[k*2] is negative, the corresponding output plane is filled with 0's.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvRandShuffle(System.IntPtr,System.IntPtr,System.Double)">
            <summary>
            Shuffles the matrix by swapping randomly chosen pairs of the matrix elements on each iteration (where each element may contain several components in case of multi-channel arrays)
            </summary>
            <param name="mat">The input/output matrix. It is shuffled in-place. </param>
            <param name="rng">Pointer to MCvRNG radom number generator. Use IntPtr.Zero if not sure</param>
            <param name="iterFactor">The relative parameter that characterizes intensity of the shuffling performed. The number of iterations (i.e. pairs swapped) is round(iter_factor*rows(mat)*cols(mat)), so iter_factor=0 means that no shuffling is done, iter_factor=1 means that the function swaps rows(mat)*cols(mat) random pairs etc</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCvtPlaneToPix(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            This function is the opposite to cvSplit. If the destination array has N channels then if the first N input channels are not IntPtr.Zero, all they are copied to the destination array, otherwise if only a single source channel of the first N is not IntPtr.Zero, this particular channel is copied into the destination array, otherwise an error is raised. Rest of source channels (beyond the first N) must always be IntPtr.Zero. For IplImage cvCopy with COI set can be also used to insert a single channel into the image. 
            </summary>
            <param name="src0">Input channels.</param>
            <param name="src1">Input channels.</param>
            <param name="src2">Input channels.</param>
            <param name="src3">Input channels.</param>
            <param name="dst">Destination array. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvNot(System.IntPtr,System.IntPtr)">
            <summary>
            Inverses every bit of every array element:
            </summary>
            <param name="src">The source array</param>
            <param name="des">The destination array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMax(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Calculates per-element maximum of two arrays:
            dst(I)=max(src1(I), src2(I))
            All the arrays must have a single channel, the same data type and the same size (or ROI size).
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array. </param>
            <param name="dst">The destination array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMaxS(System.IntPtr,System.Double,System.IntPtr)">
            <summary>
            <para>Calculates per-element maximum of array and scalar:</para>
            <para>dst(I)=max(src(I), value)</para>
            <para>All the arrays must have a single channel, the same data type and the same size (or ROI size).</para>
            </summary>
            <param name="src">The first source array</param>
            <param name="value">The scalar value</param>
            <param name="dst">The destination array. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCountNonZero(System.IntPtr)">
            <summary>
            Returns the number of non-zero elements in arr:
            result = sumI arr(I)!=0
            In case of IplImage both ROI and COI are supported.
            </summary>
            <param name="arr">The image</param>
            <returns>the number of non-zero elements in image</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMin(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Calculates per-element minimum of two arrays:
            dst(I)=min(src1(I),src2(I))
            All the arrays must have a single channel, the same data type and the same size (or ROI size).
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMinS(System.IntPtr,System.Double,System.IntPtr)">
            <summary>
            Calculates minimum of array and scalar:
            dst(I)=min(src(I), value)
            All the arrays must have a single channel, the same data type and the same size (or ROI size).
            </summary>
            <param name="src">The first source array</param>
            <param name="value">The scalar value</param>
            <param name="dst">The destination array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvAdd(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Adds one array to another one:
            dst(I)=src1(I)+src2(I) if mask(I)!=0All the arrays must have the same type, except the mask, and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array.</param>
            <param name="src2">The second source array.</param>
            <param name="dst">The destination array.</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvAddS(System.IntPtr,Emgu.CV.Structure.MCvScalar,System.IntPtr,System.IntPtr)">
            <summary>
            Adds scalar <paramref name="value"/> to every element in the source array src1 and stores the result in dst
            dst(I)=src(I)+value if mask(I)!=0
            All the arrays must have the same type, except the mask, and the same size (or ROI size)
            </summary>
            <param name="src">The source array.</param>
            <param name="value">Added scalar.</param>
            <param name="dst">The destination array.</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSub(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Subtracts one array from another one:
            dst(I)=src1(I)-src2(I) if mask(I)!=0
            All the arrays must have the same type, except the mask, and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSubS(System.IntPtr,Emgu.CV.Structure.MCvScalar,System.IntPtr,System.IntPtr)">
            <summary>
            Subtracts a scalar from every element of the source array:
            dst(I)=src(I)-value if mask(I)!=0
            All the arrays must have the same type, except the mask, and the same size (or ROI size)
            </summary>
            <param name="src">The source array</param>
            <param name="value">Subtracted scalar</param>
            <param name="dst">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSubRS(System.IntPtr,Emgu.CV.Structure.MCvScalar,System.IntPtr,System.IntPtr)">
            <summary>
            Subtracts every element of source array from a scalar:
            dst(I)=value-src(I) if mask(I)!=0
            All the arrays must have the same type, except the mask, and the same size (or ROI size)
            </summary>
            <param name="src">The source array</param>
            <param name="value">Subtracted scalar</param>
            <param name="dst">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvDiv(System.IntPtr,System.IntPtr,System.IntPtr,System.Double)">
            <summary>
            Divides one array by another:
            dst(I)=scale * src1(I)/src2(I), if src1!=IntPtr.Zero;
            dst(I)=scale/src2(I),      if src1==IntPtr.Zero;
            All the arrays must have the same type, and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array. If the pointer is IntPtr.Zero, the array is assumed to be all 1s. </param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="scale">Optional scale factor </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMul(System.IntPtr,System.IntPtr,System.IntPtr,System.Double)">
            <summary>
            Calculates per-element product of two arrays:
            dst(I)=scale*src1(I)*src2(I)
            All the arrays must have the same type, and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array. </param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="scale">Optional scale factor</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvAnd(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Calculates per-element bit-wise logical conjunction of two arrays:
            dst(I)=src1(I) &amp; src2(I) if mask(I)!=0
            In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvAndS(System.IntPtr,Emgu.CV.Structure.MCvScalar,System.IntPtr,System.IntPtr)">
            <summary>
            Calculates per-element bit-wise conjunction of array and scalar:
            dst(I)=src(I)&amp;value if mask(I)!=0
            Prior to the actual operation the scalar is converted to the same type as the arrays. In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </summary>
            <param name="src">The source array</param>
            <param name="value">Scalar to use in the operation</param>
            <param name="dst">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvOr(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Calculates per-element bit-wise disjunction of two arrays:
            dst(I)=src1(I)|src2(I)
            In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvOrS(System.IntPtr,Emgu.CV.Structure.MCvScalar,System.IntPtr,System.IntPtr)">
            <summary>
            Calculates per-element bit-wise disjunction of array and scalar:
            dst(I)=src(I)|value if mask(I)!=0
            Prior to the actual operation the scalar is converted to the same type as the arrays. In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </summary>
            <param name="src">The source array</param>
            <param name="value">Scalar to use in the operation</param>
            <param name="dst">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvXor(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Calculates per-element bit-wise logical conjunction of two arrays:
            dst(I)=src1(I)^src2(I) if mask(I)!=0
            In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
            <param name="mask">mask, 8-bit single channel array; specifies elements of destination array to be changed.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvXorS(System.IntPtr,Emgu.CV.Structure.MCvScalar,System.IntPtr,System.IntPtr)">
            <summary>
            Calculates per-element bit-wise conjunction of array and scalar:
            dst(I)=src(I)^value if mask(I)!=0
            Prior to the actual operation the scalar is converted to the same type as the arrays. In the case of floating-point arrays their bit representations are used for the operation. All the arrays must have the same type, except the mask, and the same size
            </summary>
            <param name="src">The source array</param>
            <param name="value">Scalar to use in the operation</param>
            <param name="dst">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCopy(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Copies selected elements from input array to output array:
            dst(I)=src(I) if mask(I)!=0. 
            If any of the passed arrays is of IplImage type, then its ROI and COI fields are used. Both arrays must have the same type, the same number of dimensions and the same size. The function can also copy sparse arrays (mask is not supported in this case).
            </summary>
            <param name="src">The source array</param>
            <param name="des">The destination array</param>
            <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSet(System.IntPtr,Emgu.CV.Structure.MCvScalar,System.IntPtr)">
             <summary>
             Copies scalar value to every selected element of the destination array:
            arr(I)=value if mask(I)!=0
            If array arr is of IplImage type, then is ROI used, but COI must not be set
             </summary>
             <param name="arr">The destination array</param>
             <param name="value">Fill value</param>
             <param name="mask">Operation mask, 8-bit single channel array; specifies elements of destination array to be changed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetZero(System.IntPtr)">
            <summary>
            Clears the array. In case of dense arrays (CvMat, CvMatND or IplImage) cvZero(array) is equivalent to cvSet(array,cvScalarAll(0),0), in case of sparse arrays all the elements are removed
            </summary>
            <param name="arr">array to be cleared</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvZero(System.IntPtr)">
            <summary>
            Clears the array. In case of dense arrays (CvMat, CvMatND or IplImage) cvZero(array) is equivalent to cvSet(array,cvScalarAll(0),0), in case of sparse arrays all the elements are removed
            </summary>
            <param name="arr">array to be cleared</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetIdentity(System.IntPtr,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Initializes scaled identity matrix:
            arr(i,j)=value if i=j,
            0 otherwise
            </summary>
            <param name="mat">The matrix to initialize (not necesserily square).</param>
            <param name="value">The value to assign to the diagonal elements.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvRange(System.IntPtr,System.Double,System.Double)">
            <summary>
            Initializes the matrix as following:
            arr(i,j)=(end-start)*(i*cols(arr)+j)/(cols(arr)*rows(arr))
            </summary>
            <param name="mat">The matrix to initialize. It should be single-channel 32-bit, integer or floating-point</param>
            <param name="start">The lower inclusive boundary of the range</param>
            <param name="end">The upper exclusive boundary of the range</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCartToPolar(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Calculates either magnitude, angle, or both of every 2d vector (x(I),y(I)):
            magnitude(I)=sqrt( x(I)2+y(I)2 ),
            angle(I)=atan( y(I)/x(I) )
            The angles are calculated with ~0.1 degree accuracy. For (0,0) point the angle is set to 0
            </summary>
            <param name="x">The array of x-coordinates </param>
            <param name="y">The array of y-coordinates</param>
            <param name="magnitude">The destination array of magnitudes, may be set to IntPtr.Zero if it is not needed </param>
            <param name="angle">The destination array of angles, may be set to IntPtr.Zero if it is not needed. The angles are measured in radians (0..2?) or in degrees (0..360?). </param>
            <param name="angleInDegrees">The flag indicating whether the angles are measured in radians or in degrees</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCartToPolar(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Boolean)">
            <summary>
            Calculates either magnitude, angle, or both of every 2d vector (x(I),y(I)):
            magnitude(I)=sqrt( x(I)2+y(I)2 ),
            angle(I)=atan( y(I)/x(I) )
            The angles are calculated with ~0.1 degree accuracy. For (0,0) point the angle is set to 0
            </summary>
            <param name="x">The array of x-coordinates </param>
            <param name="y">The array of y-coordinates</param>
            <param name="magnitude">The destination array of magnitudes, may be set to IntPtr.Zero if it is not needed </param>
            <param name="angle">The destination array of angles, may be set to IntPtr.Zero if it is not needed. The angles are measured in radians (0..2?) or in degrees (0..360?). </param>
            <param name="angleInDegrees">The flag indicating whether the angles are measured in radians or in degrees</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvPolarToCart(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Calculates either x-coodinate, y-coordinate or both of every vector magnitude(I)* exp(angle(I)*j), j=sqrt(-1):
            x(I)=magnitude(I)*cos(angle(I)),
            y(I)=magnitude(I)*sin(angle(I))
            </summary>
            <param name="magnitude">The array of magnitudes. If it is IntPtr.Zero, the magnitudes are assumed all 1's</param>
            <param name="angle">The array of angles, whether in radians or degrees</param>
            <param name="x">The destination array of x-coordinates, may be set to IntPtr.Zero if it is not needed</param>
            <param name="y">The destination array of y-coordinates, mau be set to IntPtr.Zero if it is not needed</param>
            <param name="angleInDegrees">The flag indicating whether the angles are measured in radians or in degrees</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvPolarToCart(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.Boolean)">
            <summary>
            Calculates either x-coodinate, y-coordinate or both of every vector magnitude(I)* exp(angle(I)*j), j=sqrt(-1):
            x(I)=magnitude(I)*cos(angle(I)),
            y(I)=magnitude(I)*sin(angle(I))
            </summary>
            <param name="magnitude">The array of magnitudes. If it is IntPtr.Zero, the magnitudes are assumed all 1's</param>
            <param name="angle">The array of angles, whether in radians or degrees</param>
            <param name="x">The destination array of x-coordinates, may be set to IntPtr.Zero if it is not needed</param>
            <param name="y">The destination array of y-coordinates, mau be set to IntPtr.Zero if it is not needed</param>
            <param name="angleInDegrees">The flag indicating whether the angles are measured in radians or in degrees</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvPow(System.IntPtr,System.IntPtr,System.Double)">
            <summary>
            Raises every element of input array to p:
            dst(I)=src(I)p, if p is integer
            dst(I)=abs(src(I))p, otherwise
            That is, for non-integer power exponent the absolute values of input array elements are used. However, it is possible to get true values for negative values using some extra operations, as the following sample, computing cube root of array elements, shows:
            CvSize size = cvGetSize(src);
            CvMat* mask = cvCreateMat( size.height, size.width, CV_8UC1 );
            cvCmpS( src, 0, mask, CV_CMP_LT ); /* find negative elements */
            cvPow( src, dst, 1./3 );
            cvSubRS( dst, cvScalarAll(0), dst, mask ); /* negate the results of negative inputs */
            cvReleaseMat( &amp;mask );
            For some values of power, such as integer values, 0.5 and -0.5, specialized faster algorithms are used.
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array, should be the same type as the source</param>
            <param name="power">The exponent of power</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvExp(System.IntPtr,System.IntPtr)">
            <summary>
            Calculates exponent of every element of input array:
            dst(I)=exp(src(I))
            Maximum relative error is 7e-6. Currently, the function converts denormalized values to zeros on output
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array, it should have double type or the same type as the source</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvLog(System.IntPtr,System.IntPtr)">
            <summary>
            Calculates natural logarithm of absolute value of every element of input array:
            dst(I)=log(abs(src(I))), src(I)!=0
            dst(I)=C,  src(I)=0
            Where C is large negative number (-700 in the current implementation)
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array, it should have double type or the same type as the source</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSolveCubic(System.IntPtr,System.IntPtr)">
            <summary>
            finds real roots of a cubic equation:
            coeffs[0]*x^3 + coeffs[1]*x^2 + coeffs[2]*x + coeffs[3] = 0
            (if coeffs is 4-element vector)
            or
            x^3 + coeffs[0]*x^2 + coeffs[1]*x + coeffs[2] = 0
            (if coeffs is 3-element vector)
            </summary>
            <param name="coeffs">The equation coefficients, array of 3 or 4 elements</param>
            <param name="roots">The output array of real roots. Should have 3 elements. Padded with zeros if there is only one root</param>
            <returns>the number of real roots found</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSolvePoly(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Finds all real and complex roots of any degree polynomial with real coefficients
            </summary>
            <param name="coeffs">The (degree + 1)-length array of equation coefficients (CV_32FC1 or CV_64FC1)</param>
            <param name="roots">The degree-length output array of real or complex roots (CV_32FC2 or CV_64FC2)</param>
            <param name="maxiter">The maximum number of iterations</param>
            <param name="fig">The required figures of precision required</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvDFT(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.CV_DXT,System.Int32)">
            <summary>
            Performs forward or inverse transform of 1D or 2D floating-point array
            In case of real (single-channel) data, the packed format, borrowed from IPL, is used to to represent a result of forward Fourier transform or input for inverse Fourier transform
            </summary>
            <param name="src">Source array, real or complex</param>
            <param name="dst">Destination array of the same size and same type as the source</param>
            <param name="flags">Transformation flags</param>
            <param name="nonzeroRows">Number of nonzero rows to in the source array (in case of forward 2d transform), or a number of rows of interest in the destination array (in case of inverse 2d transform). If the value is negative, zero, or greater than the total number of rows, it is ignored. The parameter can be used to speed up 2d convolution/correlation when computing them via DFT. See the sample below</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetOptimalDFTSize(System.Int32)">
            <summary>
            Returns the minimum number N that is greater to equal to size0, such that DFT of a vector of size N can be computed fast. In the current implementation N=2^p x 3^q x 5^r for some p, q, r. 
            </summary>
            <param name="size0">Vector size</param>
            <returns>The minimum number N that is greater to equal to size0, such that DFT of a vector of size N can be computed fast. In the current implementation N=2^p x 3^q x 5^r for some p, q, r. </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMulSpectrums(System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.MUL_SPECTRUMS_TYPE)">
            <summary>
            Performs per-element multiplication of the two CCS-packed or complex matrices that are results of real or complex Fourier transform. 
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array of the same type and the same size of the sources</param>
            <param name="flags"></param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvDCT(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.CV_DCT_TYPE)">
            <summary>
            Performs forward or inverse transform of 1D or 2D floating-point array
            </summary>
            <param name="src">Source array, real 1D or 2D array</param>
            <param name="dst">Destination array of the same size and same type as the source</param>
            <param name="flags">Transformation flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvClipLine(System.Drawing.Size,System.Drawing.Point@,System.Drawing.Point@)">
            <summary>
            Calculates a part of the line segment which is entirely in the image. It returns 0 if the line segment is completely outside the image and 1 otherwise.
            </summary>
            <param name="imgSize">Size of the image</param>
            <param name="pt1">First ending point of the line segment. It is modified by the function</param>
            <param name="pt2">Second ending point of the line segment. It is modified by the function.</param>
            <returns>It returns 0 if the line segment is completely outside the image and 1 otherwise.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvAbsDiff(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Calculates absolute difference between two arrays.
            dst(I)c = abs(src1(I)c - src2(I)c).
            All the arrays must have the same data type and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array</param>
            <param name="src2">The second source array</param>
            <param name="dst">The destination array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvAbsDiffS(System.IntPtr,System.IntPtr,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Calculates absolute difference between array and scalar
            </summary>
            <param name="src">The source array</param>
            <param name="dst">The destination array</param>
            <param name="value">The scalar</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvAddWeighted(System.IntPtr,System.Double,System.IntPtr,System.Double,System.Double,System.IntPtr)">
            <summary>
            Calculated weighted sum of two arrays as following:
            dst(I)=src1(I)*alpha+src2(I)*beta+gamma
            All the arrays must have the same type and the same size (or ROI size)
            </summary>
            <param name="src1">The first source array.</param>
            <param name="alpha">Weight of the first array elements.</param>
            <param name="src2">The second source array. </param>
            <param name="beta">Weight of the second array elements.</param>
            <param name="gamma">Scalar, added to each sum. </param>
            <param name="dst">The destination array.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInRangeS(System.IntPtr,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar,System.IntPtr)">
            <summary>
            Does the range check for every element of the input array:
            dst(I)=lower0 &lt;= src(I)0 &lt; upper0
            for a single-channel array,
            dst(I)=lower0 &lt;= src(I)0 &lt; upper0 &amp;&amp;
                lower1 &lt;= src(I)1 &lt; upper1
            for a two-channel array etc.
            dst(I) is set to 0xff (all '1'-bits) if src(I) is within the range and 0 otherwise. All the arrays must have the same size (or ROI size)
            </summary>
            <param name="src">The first source array</param>
            <param name="lower">The inclusive lower boundary</param>
            <param name="upper">The exclusive upper boundary</param>
            <param name="dst">The destination array, must have 8u or 8s type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInRange(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Performs range check for every element of the input array:
            dst(I)=lower(I)_0 &lt;= src(I)_0 &lt; upper(I)_0
            For single-channel arrays,
            dst(I)=lower(I)_0 &lt;= src(I)_0 &lt; upper(I)_0 &amp;&amp;
            lower(I)_1 &lt;= src(I)_1 &lt; upper(I)_1
            For two-channel arrays etc.
            dst(I) is set to 0xff (all '1'-bits) if src(I) is within the range and 0 otherwise. All the arrays must have the same type, except the destination, and the same size (or ROI size)
            </summary>
            <param name="src">The source image</param>
            <param name="lower">The lower values stored in an image of same type &amp; size as <paramref name="src"/></param>
            <param name="upper">The upper values stored in an image of same type &amp; size as <paramref name="src"/></param>
            <param name="dst">The resulting mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvNorm(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.NORM_TYPE,System.IntPtr)">
            <summary>
            Returns the calculated norm. The multiple-channel array are treated as single-channel, that is, the results for all channels are combined. 
            </summary>
            <param name="arr1">The first source image</param>
            <param name="arr2">The second source image. If it is IntPtr.Zero, the absolute norm of arr1 is calculated, otherwise absolute or relative norm of arr1-arr2 is calculated</param>
            <param name="normType">Type of norm</param>
            <param name="mask">The optional operation mask</param>
            <returns>The calculated norm</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateImage(System.Drawing.Size,Emgu.CV.CvEnum.IPL_DEPTH,System.Int32)">
            <summary>
            Creates the header and allocates data. 
            </summary>
            <param name="size">Image width and height.</param>
            <param name="depth">Bit depth of image elements</param>
            <param name="channels">
            Number of channels per element(pixel). Can be 1, 2, 3 or 4. The channels are interleaved, for example the usual data layout of a color image is:
            b0 g0 r0 b1 g1 r1 ...
            </param>
            <returns>A pointer to IplImage </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateImageHeader(System.Drawing.Size,Emgu.CV.CvEnum.IPL_DEPTH,System.Int32)">
            <summary>
            Allocates, initializes, and returns the structure IplImage.
            </summary>
            <param name="size">Image width and height.</param>
            <param name="depth">Bit depth of image elements</param>
            <param name="channels">
            Number of channels per element(pixel). Can be 1, 2, 3 or 4. The channels are interleaved, for example the usual data layout of a color image is:
            b0 g0 r0 b1 g1 r1 ...
            </param>
            <returns> The structure IplImage</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInitImageHeader(System.IntPtr,System.Drawing.Size,Emgu.CV.CvEnum.IPL_DEPTH,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes the image header structure, pointer to which is passed by the user, and returns the pointer.
            </summary>
            <param name="image">Image header to initialize.</param>
            <param name="size">Image width and height.</param>
            <param name="depth">Image depth </param>
            <param name="channels">Number of channels </param>
            <param name="origin">IPL_ORIGIN_TL or IPL_ORIGIN_BL.</param>
            <param name="align">Alignment for image rows, typically 4 or 8 bytes.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetData(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Assigns user data to the array header.
            </summary>
            <param name="arr">Array header.</param>
            <param name="data">User data.</param>
            <param name="step">Full row length in bytes.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseImageHeader(System.IntPtr@)">
            <summary>
            Releases the header.
            </summary>
            <param name="image">Pointer to the deallocated header.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInitMatHeader(System.IntPtr,System.Int32,System.Int32,Emgu.CV.CvEnum.MAT_DEPTH,System.IntPtr,System.Int32)">
            <summary>
            Initializes already allocated CvMat structure. It can be used to process raw data with OpenCV matrix functions.
            </summary>
            <param name="mat">Pointer to the matrix header to be initialized.</param>
            <param name="rows">Number of rows in the matrix.</param>
            <param name="cols">Number of columns in the matrix.</param>
            <param name="type">Type of the matrix elements.</param>
            <param name="data">Optional data pointer assigned to the matrix header</param>
            <param name="step">Full row width in bytes of the data assigned. By default, the minimal possible step is used, i.e., no gaps is assumed between subsequent rows of the matrix.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInitMatHeader(System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32)">
            <summary>
            Initializes already allocated CvMat structure. It can be used to process raw data with OpenCV matrix functions.
            </summary>
            <param name="mat">Pointer to the matrix header to be initialized.</param>
            <param name="rows">Number of rows in the matrix.</param>
            <param name="cols">Number of columns in the matrix.</param>
            <param name="type">Type of the matrix elements.</param>
            <param name="data">Optional data pointer assigned to the matrix header</param>
            <param name="step">Full row width in bytes of the data assigned. By default, the minimal possible step is used, i.e., no gaps is assumed between subsequent rows of the matrix.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetImageCOI(System.IntPtr,System.Int32)">
            <summary>
            Sets the channel of interest to a given value. Value 0 means that all channels are selected, 1 means that the first channel is selected etc. If ROI is NULL and coi != 0, ROI is allocated.
            </summary>
            <param name="image">Image header</param>
            <param name="coi">Channel of interest starting from 1. If 0, the COI is unset.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetImageCOI(System.IntPtr)">
            <summary>
            Returns channel of interest of the image (it returns 0 if all the channels are selected).
            </summary>
            <param name="image">Image header. </param>
            <returns>channel of interest of the image (it returns 0 if all the channels are selected)</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvResetImageROI(System.IntPtr)">
            <summary>
            Releases image ROI. After that the whole image is considered selected.
            </summary>
            <param name="image">Image header</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetImageROI(System.IntPtr,System.Drawing.Rectangle)">
            <summary>
            Sets the image ROI to a given rectangle. If ROI is NULL and the value of the parameter rect is not equal to the whole image, ROI is allocated. 
            </summary>
            <param name="image">Image header.</param>
            <param name="rect">ROI rectangle.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetImageROI(System.IntPtr)">
            <summary>
            Returns channel of interest of the image (it returns 0 if all the channels are selected).
            </summary>
            <param name="image">Image header.</param>
            <returns>channel of interest of the image (it returns 0 if all the channels are selected)</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateMat(System.Int32,System.Int32,Emgu.CV.CvEnum.MAT_DEPTH)">
            <summary>
            Allocates header for the new matrix and underlying data, and returns a pointer to the created matrix. Matrices are stored row by row. All the rows are aligned by 4 bytes. 
            </summary>
            <param name="rows">Number of rows in the matrix.</param>
            <param name="cols">Number of columns in the matrix.</param>
            <param name="type">Type of the matrix elements.</param>
            <returns>A pointer to the created matrix</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMat(System.Int32,System.Int32,Emgu.CV.CvEnum.MAT_DEPTH,System.IntPtr)">
            <summary>
            A fast inline substitution for cvInitMatHeader. Namely, it is equivalent to:
                CvMat mat;
                cvInitMatHeader( &amp;mat, rows, cols, type, data, CV_AUTOSTEP );
            </summary>
            <param name="rows">Number of rows in the matrix.</param>
            <param name="cols">Number of columns in the matrix.</param>
            <param name="type">Type of the matrix elements (see CreateMat).</param>
            <param name="data">Optional data pointer assigned to the matrix header.</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInitMatNDHeader(System.IntPtr,System.Int32,System.Int32[],Emgu.CV.CvEnum.MAT_DEPTH,System.IntPtr)">
            <summary>
            Initializes CvMatND structure allocated by the user
            </summary>
            <param name="mat">Pointer to the array header to be initialized</param>
            <param name="dims">Number of array dimensions</param>
            <param name="sizes">Array of dimension sizes</param>
            <param name="type">Type of array elements</param>
            <param name="data">Optional data pointer assigned to the matrix header</param>
            <returns>Pointer to the array header</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseMat(System.IntPtr@)">
            <summary>
            Decrements the matrix data reference counter and releases matrix header
            </summary>
            <param name="mat">Double pointer to the matrix.</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateSparseMat(System.Int32,System.IntPtr,Emgu.CV.CvEnum.MAT_DEPTH)">
            <summary>
            The function allocates a multi-dimensional sparse array. Initially the array contain no elements, that is Get or GetReal returns zero for every index
            </summary>
            <param name="dims">Number of array dimensions</param>
            <param name="sizes">Array of dimension sizes</param>
            <param name="type">Type of array elements</param>
            <returns>Pointer to the array header</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseSparseMat(System.IntPtr@)">
            <summary>
            The function releases the sparse array and clears the array pointer upon exit.
            </summary>
            <param name="mat">Reference of the pointer to the array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateMemStorage(System.Int32)">
            <summary>
            Creates a memory storage and returns pointer to it. Initially the storage is empty. All fields of the header, except the block_size, are set to 0.
            </summary>
            <param name="blockSize"></param>
            <returns>Size of the storage blocks in bytes. If it is 0, the block size is set to default value - currently it is 64K. </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateChildMemStorage(System.IntPtr)">
            <summary>
            Creates a child memory storage that is similar to simple memory storage except for the differences in the memory allocation/deallocation mechanism. When a child storage needs a new block to add to the block list, it tries to get this block from the parent. The first unoccupied parent block available is taken and excluded from the parent block list. If no blocks are available, the parent either allocates a block or borrows one from its own parent, if any. In other words, the chain, or a more complex structure, of memory storages where every storage is a child/parent of another is possible. When a child storage is released or even cleared, it returns all blocks to the parent. In other aspects, the child storage is the same as the simple storage.
            </summary>
            <param name="parent">Parent memory storage</param>
            <returns>ChildMemStorage</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvClearMemStorage(System.IntPtr)">
            <summary>
            Resets the top (free space boundary) of the storage to the very beginning. This function does not deallocate any memory. If the storage has a parent, the function returns all blocks to the parent.
            </summary>
            <param name="storage">Memory storage</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseMemStorage(System.IntPtr@)">
            <summary>
            Deallocates all storage memory blocks or returns them to the parent, if any. Then it deallocates the storage header and clears the pointer to the storage. All children of the storage must be released before the parent is released.
            </summary>
            <param name="storage">Pointer to the released storage</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke._cvLoad(System.String,System.IntPtr,System.String,System.IntPtr)">
            <summary>
            Loads object from file. It provides a simple interface to cvRead. After object is loaded, the file storage is closed and all the temporary buffers are deleted. Thus, to load a dynamic structure, such as sequence, contour or graph, one should pass a valid destination memory storage to the function.
            </summary>
            <param name="fileName">File name</param>
            <param name="memstorage">Memory storage for dynamic structures, such as CvSeq or CvGraph. It is not used for matrices or images</param>
            <param name="name">Optional object name. If it is IntPtr.Zero, the first top-level object in the storage will be loaded</param>
            <param name="realName">Optional output parameter that will contain name of the loaded object (useful if name=IntPtr.Zero). </param>
            <returns>Loaded object from file</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvLoad(System.String,System.IntPtr,System.String,System.IntPtr)">
            <summary>
            Loads object from file. It provides a simple interface to cvRead. After object is loaded, the file storage is closed and all the temporary buffers are deleted. Thus, to load a dynamic structure, such as sequence, contour or graph, one should pass a valid destination memory storage to the function.
            </summary>
            <param name="fileName">File name</param>
            <param name="memstorage">Memory storage for dynamic structures, such as CvSeq or CvGraph. It is not used for matrices or images</param>
            <param name="name">Optional object name. If it is NULL, the first top-level object in the storage will be loaded</param>
            <param name="realName">Optional output parameter that will contain name of the loaded object (useful if name=NULL). </param>
            <returns>Loaded object from file</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSeqSlice(System.IntPtr,Emgu.CV.Structure.MCvSlice,System.IntPtr,System.Int32)">
            <summary>
            Creates a sequence that represents the specified slice of the input sequence. The new sequence either shares the elements with the original sequence or has own copy of the elements. So if one needs to process a part of sequence but the processing function does not have a slice parameter, the required sub-sequence may be extracted using this function.
            </summary>
            <param name="seq">Sequence</param>
            <param name="slice">The part of the sequence to extract</param>
            <param name="storage">The destination storage to keep the new sequence header and the copied data if any. If it is IntPtr.Zero, the function uses the storage containing the input sequence.</param>
            <param name="copyData">The flag that indicates whether to copy the elements of the extracted slice (copy_data!=0) or not (copy_data=0)</param>
            <returns>A pointer to CvSeq</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSeqSlice(System.IntPtr,Emgu.CV.Structure.MCvSlice,System.IntPtr,System.Boolean)">
            <summary>
            Creates a sequence that represents the specified slice of the input sequence. The new sequence either shares the elements with the original sequence or has own copy of the elements. So if one needs to process a part of sequence but the processing function does not have a slice parameter, the required sub-sequence may be extracted using this function.
            </summary>
            <param name="seq">Sequence</param>
            <param name="slice">The part of the sequence to extract</param>
            <param name="storage">The destination storage to keep the new sequence header and the copied data if any. If it is IntPtr.Zero, the function uses the storage containing the input sequence.</param>
            <param name="copyData">The flag that indicates whether to copy the elements of the extracted slice (copyData == true) or not (copyData=false)</param>
            <returns>A pointer to CvSeq</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetReal1D(System.IntPtr,System.Int32,System.Double)">
            <summary>
            Assign the new value to the particular element of single-channel array
            </summary>
            <param name="arr">Input array</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <param name="value">The assigned value </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetReal2D(System.IntPtr,System.Int32,System.Int32,System.Double)">
            <summary>
            Assign the new value to the particular element of single-channel array
            </summary>
            <param name="arr">Input array</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <param name="idx1">The second zero-based component of the element index </param>
            <param name="value">The assigned value </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetReal3D(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Double)">
            <summary>
            Assign the new value to the particular element of single-channel array
            </summary>
            <param name="arr">Input array</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <param name="idx1">The second zero-based component of the element index </param>
            <param name="idx2">The third zero-based component of the element index </param>
            <param name="value">The assigned value </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetRealND(System.IntPtr,System.Int32[],System.Double)">
            <summary>
            Assign the new value to the particular element of single-channel array
            </summary>
            <param name="arr">Input array</param>
            <param name="idx">Array of the element indices </param>
            <param name="value">The assigned value </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvClearND(System.IntPtr,System.Int32[])">
            <summary>
            clears (sets to zero) the particular element of dense array or deletes the element of sparse array. If the element does not exists, the function does nothing
            </summary>
            <param name="arr">Input array</param>
            <param name="idx">Array of the element indices </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSet2D(System.IntPtr,System.Int32,System.Int32,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Assign the new value to the particular element of array
            </summary>
            <param name="arr">Input array. </param>
            <param name="idx0">The first zero-based component of the element index</param>
            <param name="idx1">The second zero-based component of the element index</param>
            <param name="value">The assigned value</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFlip(System.IntPtr,System.IntPtr,System.Int32)">
             <summary>
             Flips the array in one of different 3 ways (row and column indices are 0-based):
             dst(i,j)=src(rows(src)-i-1,j) if flip_mode = 0
             dst(i,j)=src(i,cols(src1)-j-1) if flip_mode &gt; 0
             dst(i,j)=src(rows(src)-i-1,cols(src)-j-1) if flip_mode &lt; 0
             </summary>
             <param name="src">Source array.</param>
             <param name="dst">Destination array.</param>
             <param name="flipMode">
             Specifies how to flip the array.
             flip_mode = 0 means flipping around x-axis, 
             flip_mode &gt; 0 (e.g. 1) means flipping around y-axis and 
             flip_mode &lt; 0 (e.g. -1) means flipping around both axises. 
            </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvLine(System.IntPtr,System.Drawing.Point,System.Drawing.Point,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LINE_TYPE,System.Int32)">
            <summary>
            Draws the line segment between pt1 and pt2 points in the image. The line is clipped by the image or ROI rectangle. For non-antialiased lines with integer coordinates the 8-connected or 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased lines are drawn using Gaussian filtering.
            </summary>
            <param name="img">The image</param>
            <param name="pt1">First point of the line segment</param>
            <param name="pt2">Second point of the line segment</param>
            <param name="color">Line color</param>
            <param name="thickness">Line thickness. </param>
            <param name="lineType">Type of the line:
            8 (or 0) - 8-connected line.
            4 - 4-connected line.
            CV_AA - antialiased line. 
            </param>
            <param name="shift">Number of fractional bits in the point coordinates</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvPolyLine(System.IntPtr,System.IntPtr[],System.Int32[],System.Int32,System.Int32,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LINE_TYPE,System.Int32)">
            <summary>
            Draws a single or multiple polygonal curves
            </summary>
            <param name="img">Image</param>
            <param name="pts">Array of pointers to polylines</param>
            <param name="npts">Array of polyline vertex counters</param>
            <param name="contours">Number of polyline contours</param>
            <param name="isClosed">
            Indicates whether the polylines must be drawn closed. 
            If !=0, the function draws the line from the last vertex of every contour to the first vertex.
            </param>
            <param name="color">Polyline color</param>
            <param name="thickness">Thickness of the polyline edges</param>
            <param name="lineType">Type of the line segments, see cvLine description</param>
            <param name="shift">Number of fractional bits in the vertex coordinates</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvPolyLine(System.IntPtr,System.IntPtr[],System.Int32[],System.Int32,System.Boolean,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LINE_TYPE,System.Int32)">
            <summary>
            Draws a single or multiple polygonal curves
            </summary>
            <param name="img">Image</param>
            <param name="pts">Array of pointers to polylines</param>
            <param name="npts">Array of polyline vertex counters</param>
            <param name="contours">Number of polyline contours</param>
            <param name="isClosed">
            Indicates whether the polylines must be drawn closed. 
            If true, the function draws the line from the last vertex of every contour to the first vertex.
            </param>
            <param name="color">Polyline color</param>
            <param name="thickness">Thickness of the polyline edges</param>
            <param name="lineType">Type of the line segments, see cvLine description</param>
            <param name="shift">Number of fractional bits in the vertex coordinates</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvRectangle(System.IntPtr,System.Drawing.Point,System.Drawing.Point,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LINE_TYPE,System.Int32)">
            <summary>
            Draws a rectangle with two opposite corners pt1 and pt2
            </summary>
            <param name="img">Image</param>
            <param name="pt1">One of the rectangle vertices</param>
            <param name="pt2">Opposite rectangle vertex</param>
            <param name="color">Line color </param>
            <param name="thickness">Thickness of lines that make up the rectangle. Negative values make the function to draw a filled rectangle.</param>
            <param name="lineType">Type of the line</param>
            <param name="shift">Number of fractional bits in the point coordinates</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetSubRect(System.IntPtr,System.IntPtr,System.Drawing.Rectangle)">
            <summary>
            Returns header, corresponding to a specified rectangle of the input array. In other words, it allows the user to treat a rectangular part of input array as a stand-alone array. ROI is taken into account by the function so the sub-array of ROI is actually extracted.
            </summary>
            <param name="arr">Input array</param>
            <param name="submat">Pointer to the resultant sub-array header.</param>
            <param name="rect">Zero-based coordinates of the rectangle of interest.</param>
            <returns>the resultant sub-array header</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetRows(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Return the header, corresponding to a specified row span of the input array
            </summary>
            <param name="arr">Input array</param>
            <param name="submat">Pointer to the prelocated memory of resulting sub-array header</param>
            <param name="startRow">Zero-based index of the starting row (inclusive) of the span</param>
            <param name="endRow">Zero-based index of the ending row (exclusive) of the span</param>
            <param name="deltaRow">Index step in the row span. That is, the function extracts every delta_row-th row from start_row and up to (but not including) end_row</param>
            <returns>The header, corresponding to a specified row span of the input array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetRow(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Return the header, corresponding to a specified row of the input array
            </summary>
            <param name="arr">Input array</param>
            <param name="submat">Pointer to the prelocate memory of the resulting sub-array header</param>
            <param name="row">Zero-based index of the selected row</param>
            <returns>The header, corresponding to a specified row of the input array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetCols(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Return the header, corresponding to a specified col span of the input array
            </summary>
            <param name="arr">Input array</param>
            <param name="submat">Pointer to the prelocated mempry of the resulting sub-array header</param>
            <param name="startCol">Zero-based index of the selected column</param>
            <param name="endCol">Zero-based index of the ending column (exclusive) of the span</param>
            <returns>The header, corresponding to a specified col span of the input array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetCol(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Return the header, corresponding to a specified column of the input array
            </summary>
            <param name="arr">Input array</param>
            <param name="submat">Pointer to the prelocate memory of the resulting sub-array header</param>
            <param name="col">Zero-based index of the selected column</param>
            <returns>The header, corresponding to a specified column of the input array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetDiag(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            returns the header, corresponding to a specified diagonal of the input array
            </summary>
            <param name="arr">Input array</param>
            <param name="submat">Pointer to the resulting sub-array header</param>
            <param name="diag">Array diagonal. Zero corresponds to the main diagonal, -1 corresponds to the diagonal above the main etc., 1 corresponds to the diagonal below the main etc</param>
            <returns>Pointer to the resulting sub-array header</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetSize(System.IntPtr)">
            <summary>
            Returns number of rows (CvSize::height) and number of columns (CvSize::width) of the input matrix or image. In case of image the size of ROI is returned.
            </summary>
            <param name="arr">array header</param>
            <returns>number of rows (CvSize::height) and number of columns (CvSize::width) of the input matrix or image. In case of image the size of ROI is returned.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCircle(System.IntPtr,System.Drawing.Point,System.Int32,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LINE_TYPE,System.Int32)">
            <summary>
            Draws a simple or filled circle with given center and radius. The circle is clipped by ROI rectangle.
            </summary>
            <param name="img">Image where the circle is drawn</param>
            <param name="center">Center of the circle</param>
            <param name="radius">Radius of the circle.</param>
            <param name="color">Color of the circle</param>
            <param name="thickness">Thickness of the circle outline if positive, otherwise indicates that a filled circle has to be drawn</param>
            <param name="lineType">Type of the circle boundary</param>
            <param name="shift">Number of fractional bits in the center coordinates and radius value</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSplit(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Divides a multi-channel array into separate single-channel arrays. Two modes are available for the operation. If the source array has N channels then if the first N destination channels are not IntPtr.Zero, all they are extracted from the source array, otherwise if only a single destination channel of the first N is not IntPtr.Zero, this particular channel is extracted, otherwise an error is raised. Rest of destination channels (beyond the first N) must always be IntPtr.Zero. For IplImage cvCopy with COI set can be also used to extract a single channel from the image
            </summary>
            <param name="src">Source array</param>
            <param name="dst0">Destination channels</param>
            <param name="dst1">Destination channels</param>
            <param name="dst2">Destination channels</param>
            <param name="dst3">Destination channels</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCvtPixToPlane(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Divides a multi-channel array into separate single-channel arrays. Two modes are available for the operation. If the source array has N channels then if the first N destination channels are not IntPtr.Zero, all they are extracted from the source array, otherwise if only a single destination channel of the first N is not IntPtr.Zero, this particular channel is extracted, otherwise an error is raised. Rest of destination channels (beyond the first N) must always be IntPtr.Zero. For IplImage cvCopy with COI set can be also used to extract a single channel from the image
            </summary>
            <param name="src">Source array</param>
            <param name="dst0">Destination channels</param>
            <param name="dst1">Destination channels</param>
            <param name="dst2">Destination channels</param>
            <param name="dst3">Destination channels</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvEllipse(System.IntPtr,System.Drawing.Point,System.Drawing.Size,System.Double,System.Double,System.Double,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LINE_TYPE,System.Int32)">
            <summary>
            Draws a simple or thick elliptic arc or fills an ellipse sector. The arc is clipped by ROI rectangle. A piecewise-linear approximation is used for antialiased arcs and thick arcs. All the angles are given in degrees.
            </summary>
            <param name="img">Image</param>
            <param name="center">Center of the ellipse</param>
            <param name="axes">Length of the ellipse axes</param>
            <param name="angle">Rotation angle</param>
            <param name="startAngle">Starting angle of the elliptic arc</param>
            <param name="endAngle">Ending angle of the elliptic arc</param>
            <param name="color">Ellipse color</param>
            <param name="thickness">Thickness of the ellipse arc</param>
            <param name="lineType">Type of the ellipse boundary</param>
            <param name="shift">Number of fractional bits in the center coordinates and axes' values</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvEllipseBox(System.IntPtr,Emgu.CV.Structure.MCvBox2D,Emgu.CV.Structure.MCvScalar,System.Int32,Emgu.CV.CvEnum.LINE_TYPE,System.Int32)">
            <summary>
            Draws a simple or thick elliptic arc or fills an ellipse sector. The arc is clipped by ROI rectangle. A piecewise-linear approximation is used for antialiased arcs and thick arcs. All the angles are given in degrees.
            </summary>
            <param name="img">Image</param>
            <param name="box">The box the define the ellipse area</param>
            <param name="color">Ellipse color</param>
            <param name="thickness">Thickness of the ellipse arc</param>
            <param name="lineType">Type of the ellipse boundary</param>
            <param name="shift">Number of fractional bits in the center coordinates and axes' values</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvLUT(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Fills the destination array with values from the look-up table. Indices of the entries are taken from the source array. That is, the function processes each element of src as following:
            dst(I)=lut[src(I)+DELTA]
            where DELTA=0 if src has depth CV_8U, and DELTA=128 if src has depth CV_8S
            </summary>
            <param name="src">Source array of 8-bit elements</param>
            <param name="dst">Destination array of arbitrary depth and of the same number of channels as the source array</param>
            <param name="lut">Look-up table of 256 elements; should have the same depth as the destination array. In case of multi-channel source and destination arrays, the table should either have a single-channel (in this case the same table is used for all channels), or the same number of channels as the source/destination array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvConvertScale(System.IntPtr,System.IntPtr,System.Double,System.Double)">
            <summary>
            This function has several different purposes and thus has several synonyms. It copies one array to another with optional scaling, which is performed first, and/or optional type conversion, performed after:
            dst(I)=src(I)*scale + (shift,shift,...)
            All the channels of multi-channel arrays are processed independently.
            The type conversion is done with rounding and saturation, that is if a result of scaling + conversion can not be represented exactly by a value of destination array element type, it is set to the nearest representable value on the real axis.
            In case of scale=1, shift=0 no prescaling is done. This is a specially optimized case and it has the appropriate cvConvert synonym. If source and destination array types have equal types, this is also a special case that can be used to scale and shift a matrix or an image and that fits to cvScale synonym.
            </summary>
            <param name="src">Source array</param>
            <param name="dst">Destination array</param>
            <param name="scale">Scale factor</param>
            <param name="shift">Value added to the scaled source array elements</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCvtScale(System.IntPtr,System.IntPtr,System.Double,System.Double)">
            <summary>
            This function has several different purposes and thus has several synonyms. It copies one array to another with optional scaling, which is performed first, and/or optional type conversion, performed after:
            dst(I)=src(I)*scale + (shift,shift,...)
            All the channels of multi-channel arrays are processed independently.
            The type conversion is done with rounding and saturation, that is if a result of scaling + conversion can not be represented exactly by a value of destination array element type, it is set to the nearest representable value on the real axis.
            In case of scale=1, shift=0 no prescaling is done. This is a specially optimized case and it has the appropriate cvConvert synonym. If source and destination array types have equal types, this is also a special case that can be used to scale and shift a matrix or an image and that fits to cvScale synonym.
            </summary>
            <param name="src">Source array</param>
            <param name="dst">Destination array</param>
            <param name="scale">Scale factor</param>
            <param name="shift">Value added to the scaled source array elements</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvConvert(System.IntPtr,System.IntPtr)">
            <summary>
            Same as cvConvertScale(src, dest, 1, 0);
            </summary>
            <param name="src">Source array</param>
            <param name="dest">Destination array</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvConvertScaleAbs(System.IntPtr,System.IntPtr,System.Double,System.Double)">
            <summary>
            Similar to cvCvtScale but it stores absolute values of the conversion results:
            dst(I)=abs(src(I)*scale + (shift,shift,...))
            The function supports only destination arrays of 8u (8-bit unsigned integers) type, for other types the function can be emulated by combination of cvConvertScale and cvAbs functions.
            </summary>
            <param name="src">Source array</param>
            <param name="dst">Destination array (should have 8u depth). </param>
            <param name="scale">ScaleAbs factor</param>
            <param name="shift">Value added to the scaled source array elements</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvAvg(System.IntPtr,System.IntPtr)">
             <summary>
             Calculates the average value M of array elements, independently for each channel:
            N = sumI mask(I)!=0
            Mc = 1/N * sumI,mask(I)!=0 arr(I)c
            If the array is IplImage and COI is set, the function processes the selected channel only and stores the average to the first scalar component (S0).
             </summary>
             <param name="arr">The array</param>
             <param name="mask">The optional operation mask</param>
             <returns>average (mean) of array elements</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvAvgSdv(System.IntPtr,Emgu.CV.Structure.MCvScalar@,Emgu.CV.Structure.MCvScalar@,System.IntPtr)">
            <summary>
            The function cvAvgSdv calculates the average value and standard deviation of array elements, independently for each channel
            </summary>
            <remarks>If the array is IplImage and COI is set, the function processes the selected channel only and stores the average and standard deviation to the first compoenents of output scalars (M0 and S0).</remarks>
            <param name="arr">The array</param>
            <param name="mean">Pointer to the mean value</param>
            <param name="stdDev">Pointer to the standard deviation</param>
            <param name="mask">The optional operation mask</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSum(System.IntPtr)">
            <summary>
            Calculates sum S of array elements, independently for each channel
            Sc = sumI arr(I)c
            If the array is IplImage and COI is set, the function processes the selected channel only and stores the sum to the first scalar component (S0).
            </summary>
            <param name="arr">The array</param>
            <returns>The sum of arary elements</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReduce(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.REDUCE_DIMENSION,Emgu.CV.CvEnum.REDUCE_TYPE)">
            <summary>
            Reduces matrix to a vector by treating the matrix rows/columns as a set of 1D vectors and performing the specified operation on the vectors until a single row/column is obtained. 
            </summary>
            <remarks>
            The function can be used to compute horizontal and vertical projections of an raster image. 
            In case of CV_REDUCE_SUM and CV_REDUCE_AVG the output may have a larger element bit-depth to preserve accuracy. 
            And multi-channel arrays are also supported in these two reduction modes
            </remarks>
            <param name="src">The input matrix</param>
            <param name="dst">The output single-row/single-column vector that accumulates somehow all the matrix rows/columns</param>
            <param name="dim">The dimension index along which the matrix is reduce.</param>
            <param name="type">The reduction operation type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseImage(System.IntPtr@)">
            <summary>
            Releases the header and the image data.
            </summary>
            <param name="image">Double pointer to the header of the deallocated image</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvDrawContours(System.IntPtr,System.IntPtr,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar,System.Int32,System.Int32,Emgu.CV.CvEnum.LINE_TYPE,System.Drawing.Point)">
            <summary>
            Draws contour outlines in the image if thickness &gt;=0 or fills area bounded by the contours if thickness&lt;0.
            </summary>
            <param name="img">Image where the contours are to be drawn. Like in any other drawing function, the contours are clipped with the ROI</param>
            <param name="contour">Pointer to the first contour</param>
            <param name="externalColor">Color of the external contours</param>
            <param name="holeColor">Color of internal contours </param>
            <param name="maxLevel">Maximal level for drawn contours. If 0, only contour is drawn. If 1, the contour and all contours after it on the same level are drawn. If 2, all contours after and all contours one level below the contours are drawn, etc. If the value is negative, the function does not draw the contours following after contour but draws child contours of contour up to abs(maxLevel)-1 level. </param>
            <param name="thickness">Thickness of lines the contours are drawn with. If it is negative the contour interiors are drawn</param>
            <param name="lineType">Type of the contour segments</param>
            <param name="offset">Shift all the point coordinates by the specified value. It is useful in case if the contours retrived in some image ROI and then the ROI offset needs to be taken into account during the rendering. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvFillConvexPoly(System.IntPtr,System.Drawing.Point[],System.Int32,Emgu.CV.Structure.MCvScalar,Emgu.CV.CvEnum.LINE_TYPE,System.Int32)">
            <summary>
            Fills convex polygon interior. This function is much faster than The function cvFillPoly and can fill not only the convex polygons but any monotonic polygon, i.e. a polygon whose contour intersects every horizontal line (scan line) twice at the most
            </summary>
            <param name="img">Image</param>
            <param name="pts">Array of pointers to a single polygon</param>
            <param name="npts">Polygon vertex counter</param>
            <param name="color">Polygon color</param>
            <param name="lineType">Type of the polygon boundaries</param>
            <param name="shift">Number of fractional bits in the vertex coordinates</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInitFont(Emgu.CV.Structure.MCvFont@,Emgu.CV.CvEnum.FONT,System.Double,System.Double,System.Double,System.Int32,Emgu.CV.CvEnum.LINE_TYPE)">
            <summary>
            Initializes the font structure that can be passed to text rendering functions
            </summary>
            <param name="font">Pointer to the font structure initialized by the function</param>
            <param name="fontFace">Font name identifier. Only a subset of Hershey fonts are supported now</param>
            <param name="hscale">Horizontal scale. If equal to 1.0f, the characters have the original width depending on the font type. If equal to 0.5f, the characters are of half the original width</param>
            <param name="vscale">Vertical scale. If equal to 1.0f, the characters have the original height depending on the font type. If equal to 0.5f, the characters are of half the original height</param>
            <param name="shear">Approximate tangent of the character slope relative to the vertical line. Zero value means a non-italic font, 1.0f means 45 slope, etc. thickness Thickness of lines composing letters outlines. The function cvLine is used for drawing letters</param>
            <param name="thickness">Thickness of the text strokes</param>
            <param name="lineType">Type of the strokes</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvPutText(System.IntPtr,System.String,System.Drawing.Point,Emgu.CV.Structure.MCvFont@,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Renders the text in the image with the specified font and color. The printed text is clipped by ROI rectangle. Symbols that do not belong to the specified font are replaced with the rectangle symbol.
            </summary>
            <param name="img">Input image</param>
            <param name="text">String to print</param>
            <param name="org">Coordinates of the bottom-left corner of the first letter</param>
            <param name="font">Pointer to the font structure</param>
            <param name="color">Text color</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetTextSize(System.String,Emgu.CV.Structure.MCvFont@,System.Drawing.Size@,System.Int32@)">
            <summary>
            Calculates the binding rectangle for the given text string when a specified font is used
            </summary>
            <param name="textString">Input string</param>
            <param name="font">The font structure</param>
            <param name="textSize">Resultant size of the text string. Height of the text does not include the height of character parts that are below the baseline</param>
            <param name="baseline">y-coordinate of the baseline relatively to the bottom-most text point</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCvtSeqToArray(System.IntPtr,System.IntPtr,Emgu.CV.Structure.MCvSlice)">
            <summary>
            Copies the entire sequence or subsequence to the specified buffer and returns the pointer to the buffer
            </summary>
            <param name="seq">Sequence</param>
            <param name="elements">Pointer to the destination array that must be large enough. It should be a pointer to data, not a matrix header</param>
            <param name="slice">The sequence part to copy to the array</param>
            <returns>the pointer to the buffer</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMakeSeqHeaderForArray(System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            Initializes sequence header for array. The sequence header as well as the sequence block are allocated by the user (for example, on stack). No data is copied by the function. The resultant sequence will consists of a single block and have IntPtr.Zero storage pointer, thus, it is possible to read its elements, but the attempts to add elements to the sequence will raise an error in most cases
            </summary>
            <param name="seqType">Type of the created sequence</param>
            <param name="headerSize">Size of the header of the sequence. Parameter sequence must point to the structure of that size or greater size.</param>
            <param name="elemSize">Size of the sequence element</param>
            <param name="elements">Elements that will form a sequence</param>
            <param name="total">Total number of elements in the sequence. The number of array elements must be equal to the value of this parameter</param>
            <param name="seq">Pointer to the local variable that is used as the sequence header. </param>
            <param name="block">Pointer to the local variable that is the header of the single sequence block. </param>
            <returns>Pointer to the local variable that is used as the sequence header</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMinMaxLoc(System.IntPtr,System.Double@,System.Double@,System.Drawing.Point@,System.Drawing.Point@,System.IntPtr)">
            <summary>
            Finds minimum and maximum element values and their positions. The extremums are searched over the whole array, selected ROI (in case of IplImage) or, if mask is not IntPtr.Zero, in the specified array region. If the array has more than one channel, it must be IplImage with COI set. In case if multi-dimensional arrays min_loc->x and max_loc->x will contain raw (linear) positions of the extremums
            </summary>
            <param name="arr">The source array, single-channel or multi-channel with COI set</param>
            <param name="minVal">Pointer to returned minimum value</param>
            <param name="maxVal">Pointer to returned maximum value</param>
            <param name="minLoc">Pointer to returned minimum location</param>
            <param name="maxLoc">Pointer to returned maximum location</param>
            <param name="mask">The optional mask that is used to select a subarray</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGet1D(System.IntPtr,System.Int32)">
            <summary>
            Return the particular array element
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index</param>
            <returns>the particular array element</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGet2D(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Return the particular array element
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index</param>
            <param name="idx1">The second zero-based component of the element index</param>
            <returns>the particular array element</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGet3D(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Return the particular array element
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index</param>
            <param name="idx1">The second zero-based component of the element index</param>
            <param name="idx2">The third zero-based component of the element index</param>
            <returns>the particular array element</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetReal1D(System.IntPtr,System.Int32)">
            <summary>
            Return the particular element of single-channel array. If the array has multiple channels, runtime error is raised. Note that cvGet*D function can be used safely for both single-channel and multiple-channel arrays though they are a bit slower.
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <returns>the particular element of single-channel array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetReal2D(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Return the particular element of single-channel array. If the array has multiple channels, runtime error is raised. Note that cvGet*D function can be used safely for both single-channel and multiple-channel arrays though they are a bit slower.
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <param name="idx1">The second zero-based component of the element index</param>
            <returns>the particular element of single-channel array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetReal3D(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Return the particular element of single-channel array. If the array has multiple channels, runtime error is raised. Note that cvGet*D function can be used safely for both single-channel and multiple-channel arrays though they are a bit slower.
            </summary>
            <param name="arr">Input array. Must have a single channel</param>
            <param name="idx0">The first zero-based component of the element index </param>
            <param name="idx1">The second zero-based component of the element index</param>
            <param name="idx2">The third zero-based component of the element index </param>
            <returns>the particular element of single-channel array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvQueryHistValue_1D(System.IntPtr,System.Int32)">
            <summary>
            Return the value of the specified bin of 1D histogram. In case of sparse histogram the function returns 0, if the bin is not present in the histogram, and no new bin is created. 
            </summary>
            <param name="hist">Histogram</param>
            <param name="idx0">Indices of the bin</param>
            <returns>the value of the specified bin of 1D histogram</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvQueryHistValue_2D(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Return the value of the specified bin of 2D histogram. In case of sparse histogram the function returns 0, if the bin is not present in the histogram, and no new bin is created. 
            </summary>
            <param name="hist">Histogram</param>
            <param name="idx0">Indices of the bin</param>
            <param name="idx1">Indices of the bin</param>
            <returns>the value of the specified bin of 2D histogram</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvQueryHistValue_3D(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Return the value of the specified bin of 3D histogram. In case of sparse histogram the function returns 0, if the bin is not present in the histogram, and no new bin is created. 
            </summary>
            <param name="hist">Histogram</param>
            <param name="idx0">Indices of the bin</param>
            <param name="idx1">Indices of the bin</param>
            <param name="idx2">Indices of the bin</param>
            <returns>the value of the specified bin of 3D histogram</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvUseOptimized(System.Int32)">
            <summary>
            Switches between the mode, where only pure C implementations from cxcore, OpenCV etc. are used, and the mode, where IPP and MKL functions are used if available. When cvUseOptimized(0) is called, all the optimized libraries are unloaded. The function may be useful for debugging, IPP&amp;MKL upgrade on the fly, online speed comparisons etc.  Note that by default the optimized plugins are loaded, so it is not necessary to call cvUseOptimized(1) in the beginning of the program (actually, it will only increase the startup time)
            </summary>
            <param name="optimize">1 to turn on optimization, 0 to turn off</param>
            <returns>The number of optimized functions loaded</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvUseOptimized(System.Boolean)">
            <summary>
            Switches between the mode, where only pure C implementations from cxcore, OpenCV etc. are used, and the mode, where IPP and MKL functions are used if available. When cvUseOptimized(0) is called, all the optimized libraries are unloaded. The function may be useful for debugging, IPP&amp;MKL upgrade on the fly, online speed comparisons etc.  Note that by default the optimized plugins are loaded, so it is not necessary to call cvUseOptimized(1) in the beginning of the program (actually, it will only increase the startup time)
            </summary>
            <param name="optimize">true to turn on optimization, false to turn off</param>
            <returns>The number of optimized functions loaded</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvRandArr(System.UInt64@,System.IntPtr,Emgu.CV.CvEnum.RAND_TYPE,Emgu.CV.Structure.MCvScalar,Emgu.CV.Structure.MCvScalar)">
            <summary>
            Fills the destination array with uniformly or normally distributed random numbers.
            </summary>
            <param name="rng">the seed for the random number generator</param>
            <param name="arr">The destination array</param>
            <param name="dist_type">Distribution type</param>
            <param name="param1">The first parameter of distribution. In case of uniform distribution it is the inclusive lower boundary of random numbers range. In case of normal distribution it is the mean value of random numbers</param>
            <param name="param2">The second parameter of distribution. In case of uniform distribution it is the exclusive upper boundary of random numbers range. In case of normal distribution it is the standard deviation of random numbers</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvDotProduct(System.IntPtr,System.IntPtr)">
            <summary>
            Calculates and returns the Euclidean dot product of two arrays.
            src1 dot src2 = sumI(src1(I)*src2(I))
            In case of multiple channel arrays the results for all channels are accumulated. In particular, cvDotProduct(a,a), where a is a complex vector, will return ||a||2. The function can process multi-dimensional arrays, row by row, layer by layer and so on.
            </summary>
            <param name="src1">The first source array.</param>
            <param name="src2">The second source array</param>
            <returns>the Euclidean dot product of two arrays</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvEigenVV(System.IntPtr,System.IntPtr,System.IntPtr,System.Double,System.Int32,System.Int32)">
            <summary>
            Computes eigenvalues and eigenvectors of a symmetric matrix
            </summary>
            <param name="mat">The input symmetric square matrix, modified during the processing</param>
            <param name="evects">The output matrix of eigenvectors, stored as subsequent rows</param>
            <param name="evals">The output vector of eigenvalues, stored in the descending order (order of eigenvalues and eigenvectors is syncronized, of course)</param>
            <param name="eps">Accuracy of diagonalization. Typically, DBL EPSILON (about 10^(-15)) works well. THIS PARAMETER IS CURRENTLY IGNORED.</param>
            <param name="lowindex">Optional index of largest eigenvalue/-vector to calculate. If either low- or highindex is supplied the other is required, too. Indexing is 1-based. Use 0 for default.</param>
            <param name="highindex">Optional index of smallest eigenvalue/-vector to calculate. If either low- or highindex is supplied the other is required, too. Indexing is 1-based. Use 0 for default.</param>
            <remarks>Currently the function is slower than cvSVD yet less accurate, so if A is known to be positivelydefined (for example, it is a covariance matrix)it is recommended to use cvSVD to find eigenvalues and eigenvectors of A, especially if eigenvectors are not required.</remarks>
            <example>To calculate the largest eigenvector/-value set lowindex = highindex = 1. For legacy reasons this function always returns a square matrix the same size as the source matrix with eigenvectors and a vector the length of the source matrix with eigenvalues. The selected eigenvectors/-values are always in the first highindex - lowindex + 1 rows.</example>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvNormalize(System.IntPtr,System.IntPtr,System.Double,System.Double,Emgu.CV.CvEnum.NORM_TYPE,System.IntPtr)">
            <summary>
            normalizes the input array so that it's norm or value range takes the certain value(s).
            </summary>
            <param name="src">The input array</param>
            <param name="dst">The output array; in-place operation is supported</param>
            <param name="a">The minimum/maximum value of the output array or the norm of output array</param>
            <param name="b">The maximum/minimum value of the output array</param>
            <param name="norm_type">The normalization type</param>
            <param name="mask">The operation mask. Makes the function consider and normalize only certain array elements</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCrossProduct(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Calculates the cross product of two 3D vectors
            </summary>
            <param name="src1">The first source vector</param>
            <param name="src2">The second source vector</param>
            <param name="dst">The destination vect</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGEMM(System.IntPtr,System.IntPtr,System.Double,System.IntPtr,System.Double,System.IntPtr,Emgu.CV.CvEnum.GEMM_TYPE)">
            <summary>
            Performs generalized matrix multiplication:
            dst = alpha*op(src1)*op(src2) + beta*op(src3), where op(X) is X or XT
            </summary>
            <param name="src1">The first source array. </param>
            <param name="src2">The second source array. </param>
            <param name="alpha"></param>
            <param name="src3">The third source array (shift). Can be IntPtr.Zero, if there is no shift.</param>
            <param name="beta"></param>
            <param name="dst">The destination array.</param>
            <param name="tABC"></param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvTransform(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Performs matrix transformation of every element of array src and stores the results in dst
            Both source and destination arrays should have the same depth and the same size or selected ROI size. transmat and shiftvec should be real floating-point matrices.
            </summary>
            <param name="src">The first source array</param>
            <param name="dst">The destination array</param>
            <param name="transmat">Transformation matrix</param>
            <param name="shiftvec">Optional shift vector</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvPerspectiveTransform(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Transforms every element of src (by treating it as 2D or 3D vector) in the following way:
            (x, y, z) -> (x'/w, y'/w, z'/w) or
            (x, y) -> (x'/w, y'/w),
            where
            (x', y', z', w') = mat4x4 * (x, y, z, 1) or
            (x', y', w') = mat3x3 * (x, y, 1)
            and w = w'   if w'!=0,
                   inf  otherwise
            </summary>
            <param name="src">The source three-channel floating-point array</param>
            <param name="dst">The destination three-channel floating-point array</param>
            <param name="mat">3x3 or 4x4 transformation matrix</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMulTransposed(System.IntPtr,System.IntPtr,System.Int32,System.IntPtr,System.Double)">
            <summary>
            Calculates the product of src and its transposition.
            The function evaluates dst=scale(src-delta)*(src-delta)^T if order=0, and dst=scale(src-delta)^T*(src-delta) otherwise.
            </summary>
            <param name="src">The source matrix</param>
            <param name="dst">The destination matrix</param>
            <param name="order">Order of multipliers</param>
            <param name="delta">An optional array, subtracted from <paramref name="src"/> before multiplication</param>
            <param name="scale">An optional scaling</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvTrace(System.IntPtr)">
            <summary>
            Returns sum of diagonal elements of the matrix <paramref name="src1"/>.
            </summary>
            <param name="mat">the matrix</param>
            <returns>sum of diagonal elements of the matrix src1</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvTranspose(System.IntPtr,System.IntPtr)">
            <summary>
            Transposes matrix src1:
            dst(i,j)=src(j,i)
            Note that no complex conjugation is done in case of complex matrix. Conjugation should be done separately: look at the sample code in cvXorS for example
            </summary>
            <param name="src">The source matrix</param>
            <param name="dst">The destination matrix</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvDet(System.IntPtr)">
            <summary>
            Returns determinant of the square matrix mat. The direct method is used for small matrices and Gaussian elimination is used for larger matrices. For symmetric positive-determined matrices it is also possible to run SVD with U=V=NULL and then calculate determinant as a product of the diagonal elements of W
            </summary>
            <param name="mat">The pointer to the matrix</param>
            <returns>determinant of the square matrix mat</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvInvert(System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.INVERT_METHOD)">
            <summary>
            Inverts matrix src1 and stores the result in src2
            </summary>
            <param name="src">The source matrix.</param>
            <param name="dst">The destination matrix</param>
            <param name="method">Inversion method</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSVD(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.SVD_TYPE)">
            <summary>
            Decomposes matrix A into a product of a diagonal matrix and two orthogonal matrices:
            A=U*W*VT
            Where W is diagonal matrix of singular values that can be coded as a 1D vector of singular values and U and V. All the singular values are non-negative and sorted (together with U and and V columns) in descenting order.
            </summary>
            <remarks>
            SVD algorithm is numerically robust and its typical applications include: 
            1. accurate eigenvalue problem solution when matrix A is square, symmetric and positively defined matrix, for example, when it is a covariation matrix. W in this case will be a vector of eigen values, and U=V is matrix of eigen vectors (thus, only one of U or V needs to be calculated if the eigen vectors are required) 
            2. accurate solution of poor-conditioned linear systems 
            3. least-squares solution of overdetermined linear systems. This and previous is done by cvSolve function with CV_SVD method 
            4. accurate calculation of different matrix characteristics such as rank (number of non-zero singular values), condition number (ratio of the largest singular value to the smallest one), determinant (absolute value of determinant is equal to the product of singular values). All the things listed in this item do not require calculation of U and V matrices. 
            </remarks>
            <param name="A">Source MxN matrix</param>
            <param name="W">Resulting singular value matrix (MxN or NxN) or vector (Nx1). </param>
            <param name="U">Optional left orthogonal matrix (MxM or MxN). If CV_SVD_U_T is specified, the number of rows and columns in the sentence above should be swapped</param>
            <param name="V">Optional right orthogonal matrix (NxN)</param>
            <param name="flags">Operation flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcCovarMatrix(System.IntPtr[],System.Int32,System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.COVAR_METHOD)">
            <summary>
            Calculates the covariation matrix and, optionally, mean vector of the set of input vectors. 
            </summary>
            <remarks>The function can be used for PCA, for comparing vectors using Mahalanobis distance etc. </remarks>
            <param name="vects">The input vectors. They all must have the same type and the same size. The vectors do not have to be 1D, they can be 2D (e.g. images) etc</param>
            <param name="count">The number of input vectors</param>
            <param name="covMat">The output covariation matrix that should be floating-point and square</param>
            <param name="avg">The input or output (depending on the flags) array - the mean (average) vector of the input vectors. </param>
            <param name="flags">The operation flags</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvMahalanobis(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Calculates the weighted distance between two vectors and returns it
            </summary>
            <param name="vec1">The first 1D source vector</param>
            <param name="vec2">The second 1D source vector</param>
            <param name="mat">The inverse covariation matrix</param>
            <returns>the Mahalanobis distance</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCalcPCA(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.PCA_TYPE)">
            <summary>
            Performs PCA analysis of the vector set. First, it uses cvCalcCovarMatrix to compute covariation matrix and then it finds its eigenvalues and eigenvectors. The output number of eigenvalues/eigenvectors should be less than or equal to MIN(rows(data),cols(data)). 
            </summary>
            <param name="data">The input data; each vector is either a single row (CV_PCA_DATA_AS_ROW) or a single column (CV_PCA_DATA_AS_COL). </param>
            <param name="avg">The mean (average) vector, computed inside the function or provided by user</param>
            <param name="eigenvalues">The output eigenvalues of covariation matrix. </param>
            <param name="eigenvectors">The output eigenvectors of covariation matrix (i.e. principal components); one vector per row.</param>
            <param name="flags"></param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvProjectPCA(System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Projects vectors to the specified subspace
            </summary>
            <param name="data">The input data. Each vector is eigher a single row or a single column.</param>
            <param name="avg">
            The mean (average) vector. If it is a single-row vector, it means that the input vectors are stored as rows of data;
            Otherwise, it should be a single-column vector, then the vectors are stored as columns of data.
            </param>
            <param name="eigenvectors">
            The eigenvectors (principle components). One vector per row.
            </param>
            <param name="result">
            The output matrix of decomposition coefficients.
            The number of rows must be the same as the number of vectors, the number of columns
            must be less than or equal to the number of rows in eigenvectos.
            That it is less, the input vectors are projected into subspace of the first cols(result)
            principle components.
            </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetRawData(System.IntPtr,System.IntPtr@,System.Int32@,System.Drawing.Size@)">
            <summary>
            Fills output variables with low-level information about the array data. All output parameters are optional, so some of the pointers may be set to NULL. If the array is IplImage with ROI set, parameters of ROI are returned. 
            </summary>
            <param name="arr">Array header</param>
            <param name="data">Output pointer to the whole image origin or ROI origin if ROI is set</param>
            <param name="step">Output full row length in bytes</param>
            <param name="roiSize">Output ROI size</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetMat(System.IntPtr,System.IntPtr,System.Int32@,System.Int32)">
            <summary>
            Returns matrix header for the input array that can be matrix - CvMat, image - IplImage or multi-dimensional dense array - CvMatND* (latter case is allowed only if allowND != 0) . In the case of matrix the function simply returns the input pointer. In the case of IplImage* or CvMatND* it initializes header structure with parameters of the current image ROI and returns pointer to this temporary structure. Because COI is not supported by CvMat, it is returned separately. 
            </summary>
            <param name="arr">Input array</param>
            <param name="header">Pointer to CvMat structure used as a temporary buffer</param>
            <param name="coi">Optional output parameter for storing COI</param>
            <param name="allowND">If non-zero, the function accepts multi-dimensional dense arrays (CvMatND*) and returns 2D (if CvMatND has two dimensions) or 1D matrix (when CvMatND has 1 dimension or more than 2 dimensions). The array must be continuous</param>
            <returns>Returns matrix header for the input array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetImage(System.IntPtr,System.IntPtr)">
            <summary>
            Returns image header for the input array that can be matrix - CvMat*, or image - IplImage*.
            </summary>
            <param name="arr">Input array. </param>
            <param name="imageHeader">Pointer to IplImage structure used as a temporary buffer.</param>
            <returns>Returns image header for the input array</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCheckArr(System.IntPtr,Emgu.CV.CvEnum.CHECK_TYPE,System.Double,System.Double)">
            <summary>
            Checks that every array element is neither NaN nor Infinity. If CV_CHECK_RANGE is set, it also checks that every element is greater than or equal to minVal and less than maxVal. 
            </summary>
            <param name="arr">The array to check.</param>
            <param name="flags">The operation flags, CHECK_NAN_INFINITY or combination of
            CHECK_RANGE - if set, the function checks that every value of array is within [minVal,maxVal) range, otherwise it just checks that every element is neigther NaN nor Infinity.
            CHECK_QUIET - if set, the function does not raises an error if an element is invalid or out of range 
            </param>
            <param name="minVal">The inclusive lower boundary of valid values range. It is used only if CHECK_RANGE is set.</param>
            <param name="maxVal">The exclusive upper boundary of valid values range. It is used only if CHECK_RANGE is set.</param>
            <returns>Returns nonzero if the check succeeded, i.e. all elements are valid and within the range, and zero otherwise. In the latter case if CV_CHECK_QUIET flag is not set, the function raises runtime error.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetNumThreads">
            <summary>
            Return the current number of threads that are used by parallelized (via OpenMP) OpenCV functions.
            </summary>
            <returns>the current number of threads that are used by parallelized (via OpenMP) OpenCV functions</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetNumThreads(System.Int32)">
            <summary>
            Sets the number of threads that are used by parallelized OpenCV functions. 
            </summary>
            <param name="threadsCount">The number of threads that are used by parallelized OpenCV functions. When the argument is zero or negative, and at the beginning of the program, the number of threads is set to the number of processors in the system, as returned by the function omp_get_num_procs() from OpenMP runtime. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetThreadNum">
            <summary>
            Returns the index, from 0 to cvGetNumThreads()-1, of the thread that called the function. It is a wrapper for the function omp_get_thread_num() from OpenMP runtime. The retrieved index may be used to access local-thread data inside the parallelized code fragments. 
            </summary>
            <returns>The index, from 0 to cvGetNumThreads()-1, of the thread that called the function. It is a wrapper for the function omp_get_thread_num() from OpenMP runtime. The retrieved index may be used to access local-thread data inside the parallelized code fragments. </returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCmp(System.IntPtr,System.IntPtr,System.IntPtr,Emgu.CV.CvEnum.CMP_TYPE)">
            <summary>
            Compares the corresponding elements of two arrays and fills the destination mask array:
            dst(I)=src1(I) op src2(I),
            dst(I) is set to 0xff (all '1'-bits) if the particular relation between the elements is true and 0 otherwise. 
            All the arrays must have the same type, except the destination, and the same size (or ROI size)
            </summary>
            <param name="src1">The first image to compare with</param>
            <param name="src2">The second image to comapare with</param>
            <param name="dst">dst(I) is set to 0xff (all '1'-bits) if the particular relation between the elements is true and 0 otherwise.</param>
            <param name="cmpOp">The comparison operator type</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCmpS(System.IntPtr,System.Double,System.IntPtr,Emgu.CV.CvEnum.CMP_TYPE)">
            <summary>
            Compares the corresponding elements of array and scalar and fills the destination mask array:
            dst(I)=src(I) op scalar,
            where op is '=', '&gt;', '&gt;=', '&lt;', '&lt;=' or '!='.
            dst(I) is set to 0xff (all '1'-bits) if the particular relation between the elements is true and 0 otherwise. All the arrays must have the same size (or ROI size)
            </summary>
            <param name="src">The source array, must have a single channel</param>
            <param name="value">The scalar value to compare each array element with</param>
            <param name="dst">The destination array, must have 8u or 8s type</param>
            <param name="cmpOp">The flag specifying the relation between the elements to be checked</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvErrorStr(System.Int32)">
            <summary>
            Returns the textual description for the specified error status code. In case of unknown status the function returns NULL pointer. 
            </summary>
            <param name="status">The error status</param>
            <returns>the textual description for the specified error status code.</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvOpenFileStorage(System.String,System.IntPtr,Emgu.CV.CvEnum.STORAGE_OP)">
            <summary>
            Opens file storage for reading or writing data. In the latter case a new file is created or existing file is rewritten. Type of the read of written file is determined by the filename extension: .xml for XML, and .yml or .yaml for YAML
            </summary>
            <param name="filename">Name of the file associated with the storage</param>
            <param name="memstorage">Memory storage used for temporary data and for storing dynamic structures, such as CvSeq or CvGraph. If it is NULL, a temporary memory storage is created and used</param>
            <param name="flags"></param>
            <returns>Pointer to CvFileStorage structure</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseFileStorage(System.IntPtr@)">
            <summary>
            Closes the file associated with the storage and releases all the temporary structures. It must be called after all I/O operations with the storage are finished
            </summary>
            <param name="fs">Reference to the pointer of the released file storage</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReadByName(System.IntPtr,System.IntPtr,System.String)">
            <summary>
            
            </summary>
            <param name="fs">File storage</param>
            <param name="map">The parent map. If it is IntPtr.Zero, the function searches a top-level node</param>
            <param name="name">The node name</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvRead(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Decodes user object (creates object in a native representation from the file storage subtree) and returns it
            </summary>
            <param name="fs">File storage</param>
            <param name="node">The root object node</param>
            <param name="attributes">Unused parameter</param>
            <returns>Pointer to the user object</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetFileNodeByName(System.IntPtr,System.IntPtr,System.String)">
            <summary>
            Finds a file node by name
            </summary>
            <param name="fs">File storage</param>
            <param name="map">The parent map. If it is NULL, the function searches in all the top-level nodes (streams), starting from the first one. </param>
            <param name="name">The file node name</param>
            <returns>Pointer to the specific file node</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvKMeans2(System.IntPtr,System.Int32,System.IntPtr,Emgu.CV.Structure.MCvTermCriteria,System.Int32,System.IntPtr,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            implements k-means algorithm that finds centers of cluster_count clusters and groups the input samples around the clusters. On output labels(i) contains a cluster index for sample stored in the i-th row of samples matrix
            </summary>
            <param name="samples">Floating-point matrix of input samples, one row per sample</param>
            <param name="clusterCount">Number of clusters to split the set by</param>
            <param name="labels">Output integer vector storing cluster indices for every sample</param>
            <param name="termcrit">Specifies maximum number of iterations and/or accuracy (distance the centers move by between the subsequent iterations)</param>
            <param name="attempts">The number of attemps. Use 2 if not sure</param>
            <param name="rng">Pointer to CvRNG, use IntPtr.Zero if not sure</param>
            <param name="flags">Flags, use 0 if not sure</param>
            <param name="centers">Pointer to array of centers, use IntPtr.Zero if not sure</param>
            <param name="compactness">Pointer to array of doubles, use IntPtr.Zero if not sure</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateCameraCapture(System.Int32)">
            <summary>
            Allocates and initialized the CvCapture structure for reading a video stream from the camera. Currently two camera interfaces can be used on Windows: Video for Windows (VFW) and Matrox Imaging Library (MIL); and two on Linux: V4L and FireWire (IEEE1394). 
            </summary>
            <param name="index">Index of the camera to be used. If there is only one camera or it does not matter what camera to use -1 may be passed</param>
            <returns>Pointer to the capture structure</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateFileCapture(System.String)">
             <summary>
             Allocates and initialized the CvCapture structure for reading the video stream from the specified file. 
            After the allocated structure is not used any more it should be released by cvReleaseCapture function. 
             </summary>
             <param name="filename">Name of the video file</param>
             <returns>Pointer to the capture structure</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseCapture(System.IntPtr@)">
            <summary>
            The function cvReleaseCapture releases the CvCapture structure allocated by cvCreateFileCapture or cvCreateCameraCapture
            </summary>
            <param name="capture">pointer to video capturing structure. </param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvQueryFrame(System.IntPtr)">
            <summary>
            Grabs a frame from camera or video file, decompresses and returns it. This function is just a combination of cvGrabFrame and cvRetrieveFrame in one call. The returned image should not be released or modified by user. 
            </summary>
            <param name="capture">video capturing structure</param>
            <returns>Pointer to the queryed frame</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvGetCaptureProperty(System.IntPtr,Emgu.CV.CvEnum.CAP_PROP)">
            <summary>
            Retrieves the specified property of camera or video file
            </summary>
            <param name="capture">video capturing structure</param>
            <param name="prop">property identifier</param>
            <returns> the specified property of camera or video file</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSetCaptureProperty(System.IntPtr,Emgu.CV.CvEnum.CAP_PROP,System.Double)">
            <summary>
            Sets the specified property of video capturing
            </summary>
            <param name="capture">Video capturing structure</param>
            <param name="property_id">Property identifier</param>
            <param name="value">Value of the property</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvLoadImage(System.String,Emgu.CV.CvEnum.LOAD_IMAGE_TYPE)">
            <summary>
            Loads an image from the specified file and returns the pointer to the loaded image. Currently the following file formats are supported: 
            Windows bitmaps - BMP, DIB; 
            JPEG files - JPEG, JPG, JPE; 
            Portable Network Graphics - PNG; 
            Portable image format - PBM, PGM, PPM; 
            Sun rasters - SR, RAS; 
            TIFF files - TIFF, TIF; 
            OpenEXR HDR images - EXR; 
            JPEG 2000 images - jp2. 
            </summary>
            <param name="filename">The name of the file to be loaded</param>
            <param name="loadType">The load image type</param>
            <returns>The loaded image</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvSaveImage(System.String,System.IntPtr)">
            <summary>
            Saves the image to the specified file. The image format is chosen depending on the filename extension, see cvLoadImage. Only 8-bit single-channel or 3-channel (with 'BGR' channel order) images can be saved using this function. If the format, depth or channel order is different, use cvCvtScale and cvCvtColor to convert it before saving, or use universal cvSave to save the image to XML or YAML format
            </summary>
            <param name="filename">The name of the file to be saved to</param>
            <param name="image">The image to be saved</param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvNamedWindow(System.String)">
            <summary>
            Creates a window which can be used as a placeholder for images and trackbars. Created windows are reffered by their names. 
            If the window with such a name already exists, the function does nothing.
            </summary>
            <param name="name">Name of the window which is used as window identifier and appears in the window caption</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvWaitKey(System.Int32)">
            <summary>
            Waits for key event infinitely (delay &lt;= 0) or for "delay" milliseconds. 
            </summary>
            <param name="delay">Delay in milliseconds.</param>
            <returns>The code of the pressed key or -1 if no key were pressed until the specified timeout has elapsed</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvShowImage(System.String,System.IntPtr)">
            <summary>
            Shows the image in the specified window
            </summary>
            <param name="name">Name of the window</param>
            <param name="image">Image to be shown</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvDestroyWindow(System.String)">
            <summary>
            Destroys the window with a given name
            </summary>
            <param name="name">Name of the window to be destroyed</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateVideoWriter(System.String,System.Int32,System.Double,System.Drawing.Size,System.Int32)">
            <summary>
            Creates video writer structure.
            </summary>
            <param name="filename">Name of the output video file.</param>
            <param name="fourcc">4-character code of codec used to compress the frames. For example, CV_FOURCC('P','I','M','1') is MPEG-1 codec, CV_FOURCC('M','J','P','G') is motion-jpeg codec etc.</param>
            <param name="fps">Framerate of the created video stream. </param>
            <param name="frameSize">Size of video frames.</param>
            <param name="isColor">If != 0, the encoder will expect and encode color frames, otherwise it will work with grayscale frames </param>
            <returns>The video writer</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvCreateVideoWriter(System.String,System.Int32,System.Double,System.Drawing.Size,System.Boolean)">
            <summary>
            Creates video writer structure.
            </summary>
            <param name="filename">Name of the output video file.</param>
            <param name="fourcc">4-character code of codec used to compress the frames. For example, CV_FOURCC('P','I','M','1') is MPEG-1 codec, CV_FOURCC('M','J','P','G') is motion-jpeg codec etc.</param>
            <param name="fps">Framerate of the created video stream. </param>
            <param name="frameSize">Size of video frames.</param>
            <param name="isColor">If it is true, the encoder will expect and encode color frames, otherwise it will work with grayscale frames </param>
            <returns>The video writer</returns>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvReleaseVideoWriter(System.IntPtr@)">
            <summary>
            Finishes writing to video file and releases the structure.
            </summary>
            <param name="writer">pointer to video file writer structure</param>
        </member>
        <member name="M:Emgu.CV.CvInvoke.cvWriteFrame(System.IntPtr,System.IntPtr)">
            <summary>
            Writes/appends one frame to video file.
            </summary>
            <param name="writer">video writer structure.</param>
            <param name="image">the written frame</param>
            <returns></returns>
        </member>
        <member name="T:Emgu.CV.CvInvoke.CvDistanceFunction">
            <summary>
            Wrapped Opencv's CvDistanceFunction
            </summary>
            <param name="f1">Pointer to an array of float</param>
            <param name="f2">Pointer to an array of float</param>
            <param name="userParams">User passed parameters</param>
            <returns>The distance between f1 and f2</returns>
        </member>
        <member name="T:Emgu.CV.CvInvoke.CvAllocFunc">
            <summary>
            Delegate used to allocate data by OpenCV
            </summary>
            <param name="size">Size of the memory to allocate</param>
            <param name="userData">User data that is transparetly passed to the custom functions</param>
            <returns>Pointer to the allocated memort</returns>
        </member>
        <member name="T:Emgu.CV.CvInvoke.CvFreeFunc">
            <summary>
            Delegate used to dellocate OpenCV memory
            </summary>
            <param name="ptr">The memory to dellocate</param>
            <param name="userData">User data that is transparetly passed to the custom functions</param>
            <returns></returns>
        </member>
        <member name="T:Emgu.CV.CvInvoke.CvErrorCallback">
            <summary>
            Define an error callback that can be registered using cvRedirectError function
            </summary>
            <param name="status">The numeric code for error status</param>
            <param name="funcName">The source file name where error is encountered</param>
            <param name="errMsg">A description of the error</param>
            <param name="fileName">The source file name where error is encountered</param>
            <param name="line">The line number in the souce where error is encountered</param>
            <param name="userData">Arbitrary pointer that is transparetly passed to the error handler.</param>
            <returns></returns>
        </member>
        <member name="T:Emgu.CV.Structure.Cuboid">
            <summary>
            A solid resembling a cube, with the rectangular faces not all equal; a rectangular parallelepiped.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Cuboid.Min">
            <summary>
            The coordinate of the upper corner
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.Cuboid.Max">
            <summary>
            The coordinate of the lower corner
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Cuboid.Contains(Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Check if the specific point is in the Cuboid
            </summary>
            <param name="point">The point to be checked</param>
            <returns>True if the point is in the cuboid</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Cuboid.Centroid">
            <summary>
            Get the centroid of this cuboid
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvAvgComp">
            <summary>
            Result of cvHaarDetectObjects
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvAvgComp.rect">
            <summary>
            Bounding rectangle for the object (average rectangle of a group)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvAvgComp.neighbors">
            <summary>
            Number of neighbor rectangles in the group
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvBGCodeBookModel">
            <summary>
            Wrapped CvBGCodeBookModel
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBGCodeBookModel.size">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBGCodeBookModel.t">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBGCodeBookModel.cbBounds">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBGCodeBookModel.modMin">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBGCodeBookModel.modMax">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBGCodeBookModel.cbmap">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBGCodeBookModel.storage">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBGCodeBookModel.freeList">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvBGStatModel">
            <summary>
            Wrapper to the CvBGStatModel
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBGStatModel.type">
            <summary>
            The type of BG model
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBGStatModel.CvReleaseBGStatModel">
            <summary>
            Pointer to the function that can be used to release this BGStatModel
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBGStatModel.CvUpdateBGStatModel">
            <summary>
            Pointer to the function that can be used to update this BGStatModel
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBGStatModel.background">
            <summary>
            8UC3 reference background image
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBGStatModel.foreground">
            <summary>
            8UC1 foreground image
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBGStatModel.layers">
            <summary>
            8UC3 reference background image, can be null
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBGStatModel.layer_count">
            <summary>
            Can be zero
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBGStatModel.storage">
            <summary>
            Storage for foreground_regions
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBGStatModel.foreground_regions">
            <summary>
            Foreground object contours
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvBlob">
            <summary>
            Wrapper to the CvBlob structure
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBlob.Center">
            <summary>
            The center of the blob 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBlob.Size">
            <summary>
            blob size
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBlob.ID">
            <summary>
            blob ID  
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvBlob.op_Implicit(Emgu.CV.Structure.MCvBlob)~System.Drawing.RectangleF">
            <summary>
            Convert a MCvBlob to RectangleF
            </summary>
            <param name="blob">The blob</param>
            <returns>The equivalent RectangleF</returns>
        </member>
        <member name="T:Emgu.CV.Structure.MCvBlobTrackerAutoParam1">
            <summary>
            Parameters of blobtracker auto ver1
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBlobTrackerAutoParam1.FGTrainFrames">
            <summary>
            Number of frames needed for FG (foreground) detector to train.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBlobTrackerAutoParam1.FG">
            <summary>
            FGDetector module. If this field is NULL the Process FG mask is used.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBlobTrackerAutoParam1.BD">
            <summary>
            Selected blob detector module. If this field is NULL default blobdetector module will be created.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBlobTrackerAutoParam1.BT">
            <summary>
            Selected blob tracking module. If this field is NULL default blobtracker module will be created.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBlobTrackerAutoParam1.BTGen">
            <summary>
            Selected blob trajectory generator. If this field is NULL no generator is used.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBlobTrackerAutoParam1.BTPP">
            <summary>
            Selected blob trajectory postprocessing module. If this field is NULL no postprocessing is done. 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBlobTrackerAutoParam1.usePPData">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBlobTrackerAutoParam1.BTA">
            <summary>
            Selected blob trajectory analysis module. If this field is NULL no track analysis is done.   
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvBlobTrackerParamLH">
            <summary>
            Some declarations for specific likelihood tracker
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBlobTrackerParamLH.HistType">
            <summary>
            see Prob.h 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBlobTrackerParamLH.ScaleAfter">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvBlobTrackerParamMS">
            <summary>
            Mean Shift Blob tracker parameters
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBlobTrackerParamMS.noOfSigBits">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBlobTrackerParamMS.appearance_profile">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBlobTrackerParamMS.meanshift_profile">
            <summary>
            MS profile
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBlobTrackerParamMS.sigma">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvBox2D">
            <summary>
            Managed structure equivalent to CvBox2D
            </summary>
        </member>
        <member name="T:Emgu.CV.IConvexPolygonF">
            <summary>
            An interface for the convex polygon
            </summary>
        </member>
        <member name="M:Emgu.CV.IConvexPolygonF.GetVertices">
            <summary>
            Get the vertices of this convex polygon
            </summary>
            <returns>The vertices of this convex polygon</returns>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBox2D.center">
            <summary>
            The center of the box
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBox2D.size">
            <summary>
            The size of the box
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvBox2D.angle">
            <summary>
            The angle between the horizontal axis and the first side (i.e. width) in degrees
            </summary>
            <remarks>Possitive value means counter-clock wise rotation</remarks>
        </member>
        <member name="M:Emgu.CV.Structure.MCvBox2D.#ctor(System.Drawing.PointF,System.Drawing.SizeF,System.Single)">
            <summary>
            Create a MCvBox2D structure with the specific parameters
            </summary>
            <param name="center">The center of the box</param>
            <param name="size">The size of the box</param>
            <param name="angle">The angle of the box in degrees. Possitive value means counter-clock wise rotation</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvBox2D.Offset(System.Int32,System.Int32)">
            <summary>
            Shift the box by the specific amount
            </summary>
            <param name="x">The x value to be offseted</param>
            <param name="y">The y value to be offseted</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvBox2D.GetVertices">
            <summary>
            Get the 4 verticies of this Box.
            </summary>
            <returns>The vertives of this MCvBox2D</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvBox2D.MinAreaRect">
            <summary>
            Get the minimum enclosing rectangle for this Box
            </summary>
            <returns>The minimum enclosing rectangle for this Box</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvBox2D.Equals(Emgu.CV.Structure.MCvBox2D)">
            <summary>
            Returns true if the two box are equal
            </summary>
            <param name="other">The other box to compare with</param>
            <returns>True if two boxes are equal</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvBox2D.op_Implicit(System.Drawing.RectangleF)~Emgu.CV.Structure.MCvBox2D">
            <summary>
            Convert a RectangleF to MCvBox2D
            </summary>
            <param name="rectangle">The rectangle</param>
            <returns>The equivalent MCvBox2D</returns>
        </member>
        <member name="P:Emgu.CV.Structure.MCvBox2D.Empty">
            <summary>
            Represent an uninitialized MCvBox2D
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvChain">
            <summary>
            Managed structure equivalent to CvChain
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.flags">
            <summary>
             micsellaneous flags 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.header_size">
            <summary>
             size of sequence header 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.h_prev">
            <summary>
             previous sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.h_next">
            <summary>
             next sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.v_prev">
            <summary>
             2nd previous sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.v_next">
            <summary>
             2nd next sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.total">
            <summary>
             total number of elements 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.elem_size">
            <summary>
             size of sequence element in bytes 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.block_max">
            <summary>
             maximal bound of the last block 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.ptr">
            <summary>
             current write pointer 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.delta_elems">
            <summary>
             how many elements allocated when the seq grows 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.storage">
            <summary>
             where the seq is stored 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.free_blocks">
            <summary>
             free blocks list 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.first">
            <summary>
             pointer to the first sequence block 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvChain.origin">
            <summary>
            The origin of the chain
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvConDensation">
            <summary>
            Managed structure equivalent to CvConDensation
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConDensation.MP">
            <summary>
            Dimension of measurement vector
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConDensation.DP">
            <summary>
            Dimension of state vector
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConDensation.DynamMatr">
            <summary>
            Matrix of the linear Dynamics system
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConDensation.State">
            <summary>
            Vector of State
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConDensation.SamplesNum">
            <summary>
            Number of the Samples
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConDensation.flSamples">
            <summary>
            Array of the Sample Vectors
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConDensation.flNewSamples">
            <summary>
            Temporary array of the Sample Vectors
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConDensation.flConfidence">
            <summary>
            Confidence for each Sample
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConDensation.flCumulative">
            <summary>
            Cumulative confidence
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConDensation.Temp">
            <summary>
            Temporary vector
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConDensation.RandomSample">
            <summary>
            RandomVector to update sample set
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConDensation.RandS">
            <summary>
            Array of structures to generate random vectors
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvConnectedComp">
            <summary>
            Managed structure equivalent to CvConnectedComp
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConnectedComp.area">
            <summary>
            area of the segmented component
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConnectedComp.value">
            <summary>
            scalar value
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConnectedComp.rect">
            <summary>
            ROI of the segmented component
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConnectedComp.contour">
            <summary>
            Pointer to the CvSeq
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvContour">
            <summary>
            Managed structure equivalent to CvContour
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.flags">
            <summary>
             Micsellaneous flags 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.header_size">
            <summary>
             Size of sequence header 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.h_prev">
            <summary>
             Pointer to the previous sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.h_next">
            <summary>
             Pointer to the next sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.v_prev">
            <summary>
             Pointer to the 2nd previous sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.v_next">
            <summary>
             Pointer to the 2nd next sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.total">
            <summary>
             Total number of elements 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.elem_size">
            <summary>
             Size of sequence element in bytes 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.block_max">
            <summary>
             Maximal bound of the last block 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.ptr">
            <summary>
             Current write pointer 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.delta_elems">
            <summary>
             How many elements allocated when the seq grows 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.storage">
            <summary>
             Where the seq is stored 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.free_blocks">
            <summary>
             Free blocks list 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.first">
            <summary>
             Pointer to the first sequence block 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.rect">
            <summary>
            If computed, stores the minimum enclosing rectangle
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.color">
            <summary>
            Color
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvContour.reserved">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvConvexityDefect">
            <summary>
            Managed structure equivalent to CvConvexityDefect
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConvexityDefect.StartPointPointer">
            <summary>
            Pointer to the point of the contour where the defect begins
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConvexityDefect.EndPointPointer">
            <summary>
            Pointer to the point of the contour where the defect ends
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConvexityDefect.DepthPointPointer">
            <summary>
            Pointer to the farthest point from the convex hull within the defect
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvConvexityDefect.Depth">
            <summary>
            Distance between the farthest point and the convex hull
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvConvexityDefect.StartPoint">
            <summary>
            Point of the contour where the defect begins
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvConvexityDefect.EndPoint">
            <summary>
            Point of the contour where the defect ends
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvConvexityDefect.DepthPoint">
            <summary>
            The farthest from the convex hull point within the defect
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvFGDStatModelParams">
            <summary>
            Wrapper to the CvBGStatModel
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvFGDStatModelParams.Lc">
            <summary>
            Quantized levels per 'color' component. Power of two, typically 32, 64 or 128.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvFGDStatModelParams.N1c">
            <summary>
            Number of color vectors used to model normal background color variation at a given pixel.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvFGDStatModelParams.N2c">
            <summary>
            Number of color vectors retained at given pixel.  Must be > N1c, typically ~ 5/3 of N1c.
            </summary>
            <remarks>Used to allow the first N1c vectors to adapt over time to changing background.	</remarks>
        </member>
        <member name="F:Emgu.CV.Structure.MCvFGDStatModelParams.Lcc">
            <summary>
            Quantized levels per 'color co-occurrence' component.  Power of two, typically 16, 32 or 64.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvFGDStatModelParams.N1cc">
            <summary>
            Number of color co-occurrence vectors used to model normal background color variation at a given pixel.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvFGDStatModelParams.N2cc">
            <summary>
            Number of color co-occurrence vectors retained at given pixel.  Must be > N1cc, typically ~ 5/3 of N1cc.	
            </summary>
            <remarks>Used to allow the first N1cc vectors to adapt over time to changing background.</remarks>
        </member>
        <member name="F:Emgu.CV.Structure.MCvFGDStatModelParams.is_obj_without_holes">
            <summary>
            If TRUE we ignore holes within foreground blobs. Defaults to TRUE.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvFGDStatModelParams.perform_morphing">
            <summary>
            Number of erode-dilate-erode foreground-blob cleanup iterations.
            </summary>
            <remarks>These erase one-pixel junk blobs and merge almost-touching blobs. Default value is 1.</remarks>
        </member>
        <member name="F:Emgu.CV.Structure.MCvFGDStatModelParams.alpha1">
            <summary>
            How quickly we forget old background pixel values seen.  Typically set to 0.1
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvFGDStatModelParams.alpha2">
            <summary>
            "Controls speed of feature learning". Depends on T. Typical value circa 0.005.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvFGDStatModelParams.alpha3">
            <summary>
            Alternate to alpha2, used (e.g.) for quicker initial convergence. Typical value 0.1.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvFGDStatModelParams.delta">
            <summary>
            Affects color and color co-occurrence quantization, typically set to 2.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvFGDStatModelParams.T">
            <summary>
            "A percentage value which determines when new features can be recognized as new background." (Typically 0.9).
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvFGDStatModelParams.minArea">
            <summary>
            Discard foreground blobs whose bounding box is smaller than this threshold.
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvFont">
            <summary>
            Managed structure equivalent to CvFont
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvFont.font_face">
            <summary>
             Font type
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvFont.ascii">
            <summary>
             font data and metrics 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvFont.greek">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvFont.cyrillic">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvFont.hscale">
            <summary>
            hscale
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvFont.vscale">
            <summary>
            vscale
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvFont.shear">
            <summary>
             slope coefficient: 0 - normal, >0 - italic 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvFont.thickness">
            <summary>
             letters thickness 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvFont.dx">
            <summary>
             horizontal interval between letters 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvFont.line_type">
            <summary>
            type of line
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvFont.#ctor(Emgu.CV.CvEnum.FONT,System.Double,System.Double)">
            <summary>
            Create a Font of the specific type, horizontal scale and vertical scale
            </summary>
            <param name="type">The type of the font</param>
            <param name="hscale">The horizontal scale of the font</param>
            <param name="vscale">the vertical scale of the fonr</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvFont.GetTextSize(System.String,System.Int32)">
            <summary>
            Calculates the binding rectangle for the given text string when the font is used
            </summary>
            <param name="text">Input string</param>
            <param name="baseline">y-coordinate of the baseline relatively to the bottom-most text point</param>
            <returns>size of the text string. Height of the text does not include the height of character parts that are below the baseline</returns>
        </member>
        <member name="T:Emgu.CV.Structure.MCvHistogram">
            <summary>
            Managed structure equivalent to CvMat
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvHistogram.type">
            <summary>
            The type of histogram
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvHistogram.bins">
            <summary>
            Pointer to CvArr
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvHistogram.thresh">
            <summary>
            For uniform histograms 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvHistogram.thresh2">
            <summary>
            For non-uniform histograms
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvHistogram.mat">
            <summary>
            Embedded matrix header for array histograms
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvHuMoments">
            <summary>
            Hu invariants
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvHuMoments.hu1">
            <summary>
            Hu invariants
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvHuMoments.hu2">
            <summary>
            Hu invariants
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvHuMoments.hu3">
            <summary>
            Hu invariants
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvHuMoments.hu4">
            <summary>
            Hu invariants
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvHuMoments.hu5">
            <summary>
            Hu invariants
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvHuMoments.hu6">
            <summary>
            Hu invariants
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvHuMoments.hu7">
            <summary>
            Hu invariants
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvKalman">
            <summary>
            Managed CvKalman structure
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.MP">
            <summary>
              number of measurement vector dimensions 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.DP">
            <summary>
              number of state vector dimensions 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.CP">
            <summary>
              number of control vector dimensions 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.PosterState">
            <summary>
              =state_pre->data.fl 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.PriorState">
            <summary>
              =state_post->data.fl 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.DynamMatr">
            <summary>
              =transition_matrix->data.fl 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.MeasurementMatr">
            <summary>
              =measurement_matrix->data.fl 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.MNCovariance">
            <summary>
              =measurement_noise_cov->data.fl 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.PNCovariance">
            <summary>
              =process_noise_cov->data.fl 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.KalmGainMatr">
            <summary>
              =gain->data.fl 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.PriorErrorCovariance">
            <summary>
              =error_cov_pre->data.fl 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.PosterErrorCovariance">
            <summary>
              =error_cov_post->data.fl 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.Temp1">
            <summary>
              temp1->data.fl 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.Temp2">
            <summary>
              temp2->data.fl 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.state_pre">
            <summary>
              predicted state (x'(k)):
                                                x(k)=A*x(k-1)+B*u(k) 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.state_post">
            <summary>
              corrected state (x(k)):
                                                x(k)=x'(k)+K(k)*(z(k)-H*x'(k)) 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.transition_matrix">
            <summary>
              state transition matrix (A) 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.control_matrix">
            <summary>
              control matrix (B)
                                               (it is not used if there is no control)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.measurement_matrix">
            <summary>
              measurement matrix (H) 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.process_noise_cov">
            <summary>
              process noise covariance matrix (Q) 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.measurement_noise_cov">
            <summary>
              measurement noise covariance matrix (R) 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.error_cov_pre">
            <summary>
              priori error estimate covariance matrix P'(k)=A*P(k-1)*At + Q)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.gain">
            <summary>
              Kalman gain matrix (K(k)):
                                                K(k)=P'(k)*Ht*inv(H*P'(k)*Ht+R)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.error_cov_post">
            <summary>
              posteriori error estimate covariance matrix P(k)=(I-K(k)*H)*P'(k) 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.temp1">
            <summary>
              temporary matrices 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.temp2">
            <summary>
              temporary matrices 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.temp3">
            <summary>
              temporary matrices 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.temp4">
            <summary>
              temporary matrices 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvKalman.temp5">
            <summary>
              temporary matrices 
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvMat">
            <summary>
            Managed structure equivalent to CvMat
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.type">
            <summary>
            CvMat signature (CV_MAT_MAGIC_VAL), element type and flags
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.step">
            <summary>
            full row length in bytes
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.refcount">
            <summary>
            underlying data reference counter
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.hdr_refcount">
            <summary>
            Header reference count
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.data">
            <summary>
            data pointers
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.rows">
            <summary>
            number of rows
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMat.cols">
            <summary>
            number of columns
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMat.width">
            <summary>
            Width
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMat.height">
            <summary>
            Height
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMat.NumberOfChannels">
            <summary>
            Get the number of channels
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvMatND">
            <summary>
            Managed structure equivalent to CvMatND
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.type">
            <summary>
            CvMatND signature (CV_MATND_MAGIC_VAL), element type and flags
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dims">
            <summary>
            number of array dimensions
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.refcount">
            <summary>
            underlying data reference counter
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.hdr_refcount">
            <summary>
            Header reference count
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.data">
            <summary>
            data pointers
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMatND.dim">
            <summary>
            pairs (number of elements, distance between elements in bytes) for every dimension
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvMatND.Dimension">
            <summary>
            The MatND Dimension
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMatND.Dimension.Size">
            <summary>
            Number of elements in this dimension
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMatND.Dimension.Step">
            <summary>
            distance between elements in bytes for this dimension
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvMoments">
            <summary>
            spatial and central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.m00">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.m10">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.m01">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.m20">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.m11">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.m02">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.m30">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.m21">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.m12">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.m03">
            <summary>
            spatial moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.mu20">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.mu11">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.mu02">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.mu30">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.mu21">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.mu12">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.mu03">
            <summary>
            central moments
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMoments.inv_sqrt_m00">
            <summary>
            m00 != 0 ? 1/sqrt(m00) : 0
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvMoments.GetSpatialMoment(System.Int32,System.Int32)">
            <summary>
            Retrieves the spatial moment, which in case of image moments is defined as:
            M_{x_order,y_order}=sum_{x,y}(I(x,y) * x^{x_order} * y^{y_order})
            where I(x,y) is the intensity of the pixel (x, y). 
            </summary>
            <param name="xOrder">x order of the retrieved moment, x_order &gt;= 0</param>
            <param name="yOrder">y order of the retrieved moment, y_order &gt;= 0 and x_order + y_order &lt;= 3</param>
            <returns>The spatial moment of the specific order</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvMoments.GetCentralMoment(System.Int32,System.Int32)">
            <summary>
            Retrieves the central moment, which in case of image moments is defined as:
            mu_{x_order,y_order}=sum_{x,y}(I(x,y)*(x-x_c)^{x_order} * (y-y_c)^{y_order}),
            where x_c=M10/M00, y_c=M01/M00 - coordinates of the gravity center
            </summary>
            <param name="x_order">x order of the retrieved moment, x_order &gt;= 0.</param>
            <param name="y_order">y order of the retrieved moment, y_order &gt;= 0 and x_order + y_order &lt;= 3</param>
            <returns>The center moment</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvMoments.GetNormalizedCentralMoment(System.Int32,System.Int32)">
            <summary>
            Retrieves normalized central moment, which in case of image moments is defined as:
            eta_{x_order,y_order}=mu_{x_order,y_order} / M00^{(y_order+x_order)/2+1},
            where mu_{x_order,y_order} is the central moment
            </summary>
            <param name="x_order">x order of the retrieved moment, x_order &gt;= 0.</param>
            <param name="y_order">y order of the retrieved moment, y_order &gt;= 0 and x_order + y_order &lt;= 3</param>
            <returns>The normalized center moment</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvMoments.GetHuMoment">
            <summary>
            Get the HuMoments 
            </summary>
            <returns>The Hu moment computed from this moment</returns>
        </member>
        <member name="P:Emgu.CV.Structure.MCvMoments.GravityCenter">
            <summary>
            The Gravity Center of this Moment
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvMSERParams">
            <summary>
            Wrapped CvMSERParams structure
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvMSERParams.GetDefaultParameter">
            <summary>
            Get the default MSER parameters
            </summary>
            <returns>The default MSER parameter</returns>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMSERParams.delta">
            <summary>
            Delta, in the code, it compares (size_{i}-size_{i-delta})/size_{i-delta}
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMSERParams.maxArea">
            <summary>
            Prune the area which bigger than max_area
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMSERParams.minArea">
            <summary>
            Prune the area which smaller than min_area
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMSERParams.maxVariation">
            <summary>
            Prune the area have simliar size to its children
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMSERParams.minDiversity">
            <summary>
            Trace back to cut off mser with diversity &lt; min_diversity
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMSERParams.maxEvolution">
            <summary>
            For color image, the evolution steps
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMSERParams.areaThreshold">
            <summary>
            The area threshold to cause re-initialize
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMSERParams.minMargin">
            <summary>
            ignore too small margin
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvMSERParams.edgeBlurSize">
            <summary>
            the aperture size for edge blur
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvPoint2D64f">
            <summary>
            Managed Structure equivalent to CvPoint2D64f
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint2D64f.x">
            <summary>
            x-coordinate
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint2D64f.y">
            <summary>
            y-coordinate
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.#ctor(System.Double,System.Double)">
            <summary>
            Create a MCvPoint2D64f structure with the specific x and y coordinates
            </summary>
            <param name="x">x-coordinate</param>
            <param name="y">y-coordinate</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.op_Addition(Emgu.CV.Structure.MCvPoint2D64f,Emgu.CV.Structure.MCvPoint2D64f)">
            <summary>
            Compute the sum of two 3D points
            </summary>
            <param name="p1">The first point to be added</param>
            <param name="p2">The second point to be added</param>
            <returns>The sum of two points</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.op_Subtraction(Emgu.CV.Structure.MCvPoint2D64f,Emgu.CV.Structure.MCvPoint2D64f)">
            <summary>
            Subtract <paramref name="p2"/> from <paramref name="p1"/>
            </summary>
            <param name="p1">The first point</param>
            <param name="p2">The point to be added</param>
            <returns>The sum of two points</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.op_Multiply(Emgu.CV.Structure.MCvPoint2D64f,System.Double)">
            <summary>
            Multiply the point with a scale
            </summary>
            <param name="p">The point to be multiplied</param>
            <param name="scale">The scale</param>
            <returns>The point multiplied by the scale</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.op_Multiply(System.Double,Emgu.CV.Structure.MCvPoint2D64f)">
            <summary>
            Multiply the point with a scale
            </summary>
            <param name="p">The point to be multiplied</param>
            <param name="scale">The scale</param>
            <returns>The point multiplied by the scale</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint2D64f.Equals(Emgu.CV.Structure.MCvPoint2D64f)">
            <summary>
            Returns true if the two points equals.
            </summary>
            <param name="other">The other point to compare with</param>
            <returns>True if the two points equals</returns>
        </member>
        <member name="T:Emgu.CV.Structure.MCvPoint3D32f">
            <summary>
            Managed Structure equivalent to CvPoint3D32f
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint3D32f.x">
            <summary>
            x-coordinate
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint3D32f.y">
            <summary>
            y-coordinate
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint3D32f.z">
            <summary>
            z-coordinate
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Create a MCvPoint3D32f structure with the specific x and y coordinates
            </summary>
            <param name="x">x-coordinate</param>
            <param name="y">y-coordinate</param>
            <param name="z">z-coordinate</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.CrossProduct(Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Return the cross product of two 3D point
            </summary>
            <param name="point">the other 3D point</param>
            <returns>The cross product of the two 3D point</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.DotProduct(Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Return the dot product of two 3D point
            </summary>
            <param name="point">the other 3D point</param>
            <returns>The dot product of the two 3D point</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.GetNormalizedPoint">
            <summary>
            Get the normalized point
            </summary>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.op_Subtraction(Emgu.CV.Structure.MCvPoint3D32f,Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Substract one point from the other
            </summary>
            <param name="p1">The point to substract from</param>
            <param name="p2">The value to be substracted</param>
            <returns>The substraction of one point from the other</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.op_Addition(Emgu.CV.Structure.MCvPoint3D32f,Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Compute the sum of two 3D points
            </summary>
            <param name="p1">The first point to be added</param>
            <param name="p2">The second point to be added</param>
            <returns>The sum of two points</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.op_Multiply(Emgu.CV.Structure.MCvPoint3D32f,System.Single)">
            <summary>
            Multiply the point with a scale
            </summary>
            <param name="p">The point to be multiplied</param>
            <param name="scale">The scale</param>
            <returns>The point multiplied by the scale</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.op_Multiply(System.Single,Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Multiply the point with a scale
            </summary>
            <param name="p">The point to be multiplied</param>
            <param name="scale">The scale</param>
            <returns>The point multiplied by the scale</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D32f.Equals(Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Return true if the location of the two points are equal
            </summary>
            <param name="other">The other point to compare with</param>
            <returns>True if the location of the two points are equal</returns>
        </member>
        <member name="P:Emgu.CV.Structure.MCvPoint3D32f.Norm">
            <summary>
            return the norm of this 3D point
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvPoint3D64f">
            <summary>
            Managed Structure equivalent to CvPoint3D64f
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint3D64f.x">
            <summary>
            x-coordinate
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint3D64f.y">
            <summary>
            y-coordinate
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvPoint3D64f.z">
            <summary>
            z-coordinate
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Create a MCvPoint3D64f structure with the specific x and y coordinates
            </summary>
            <param name="x">x-coordinate</param>
            <param name="y">y-coordinate</param>
            <param name="z">z-coordinate</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.CrossProduct(Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Return the cross product of two 3D point
            </summary>
            <param name="point">the other 3D point</param>
            <returns>The cross product of the two 3D point</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.DotProduct(Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Return the dot product of two 3D point
            </summary>
            <param name="point">the other 3D point</param>
            <returns>The dot product of the two 3D point</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.op_Addition(Emgu.CV.Structure.MCvPoint3D64f,Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Compute the sum of two 3D points
            </summary>
            <param name="p1">The first point to be added</param>
            <param name="p2">The second point to be added</param>
            <returns>The sum of two points</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.op_Subtraction(Emgu.CV.Structure.MCvPoint3D64f,Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Subtract <paramref name="p2"/> from <paramref name="p1"/>
            </summary>
            <param name="p1">The first point</param>
            <param name="p2">The point to be added</param>
            <returns>The sum of two points</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.op_Multiply(Emgu.CV.Structure.MCvPoint3D64f,System.Double)">
            <summary>
            Multiply the point with a scale
            </summary>
            <param name="p">The point to be multiplied</param>
            <param name="scale">The scale</param>
            <returns>The point multiplied by the scale</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.op_Multiply(System.Double,Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Multiply the point with a scale
            </summary>
            <param name="p">The point to be multiplied</param>
            <param name="scale">The scale</param>
            <returns>The point multiplied by the scale</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvPoint3D64f.Equals(Emgu.CV.Structure.MCvPoint3D64f)">
            <summary>
            Check if the other point equals to this point
            </summary>
            <param name="other">The point to be compared</param>
            <returns>True if the two points are equal</returns>
        </member>
        <member name="T:Emgu.CV.Structure.MCvQuadEdge2D">
            <summary>
            Quad-edge of planar subdivision
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvQuadEdge2D.flags">
            <summary>
            flags
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvQuadEdge2D.pt">
            <summary>
            Pointers to struct CvSubdiv2DPoint
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvQuadEdge2D.next">
            <summary>
            Quad-edges, for each of the edges, lower 2 bits is index (0..3) and upper bits are quad-edge pointer
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvQuadEdge2D.GetCvSubdiv2DPoint(System.Int32)">
            <summary>
            Get the ith subdivision point
            </summary>
            <param name="index">the index to the point, &gt;=0 and &lt;4 </param>
            <returns>the ith CvSubdiv2DPoint</returns>
        </member>
        <member name="T:Emgu.CV.Structure.MCvScalar">
            <summary>
            Managed structure equivalent to CvScalar 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvScalar.v0">
            <summary>
            The scalar value
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvScalar.v1">
            <summary>
            The scalar value
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvScalar.v2">
            <summary>
            The scalar value
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvScalar.v3">
            <summary>
            The scalar value
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.ToArray">
            <summary>
            The scalar values as a vector (of size 4)
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.#ctor(System.Double)">
            <summary>
            Create a new MCvScalar structure using the specific values
            </summary>
            <param name="v0">v0</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.#ctor(System.Double,System.Double)">
            <summary>
            Create a new MCvScalar structure using the specific values
            </summary>
            <param name="v0">v0</param>
            <param name="v1">v1</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Create a new MCvScalar structure using the specific values
            </summary>
            <param name="v0">v0</param>
            <param name="v1">v1</param>
            <param name="v2">v2</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Create a new MCvScalar structure using the specific values
            </summary>
            <param name="v0">v0</param>
            <param name="v1">v1</param>
            <param name="v2">v2</param>
            <param name="v3">v3</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.ToCode(Emgu.Util.TypeEnum.ProgrammingLanguage)">
            <summary>
            Return the code to generate this MCvScalar from specific language
            </summary>
            <param name="language">The programming language to generate code from</param>
            <returns>The code to generate this MCvScalar from specific language</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvScalar.Equals(Emgu.CV.Structure.MCvScalar)">
            <summary>
            Return true if the two MCvScalar equals
            </summary>
            <param name="other">The other MCvScalar to compare with</param>
            <returns>true if the two MCvScalar equals</returns>
        </member>
        <member name="T:Emgu.CV.Structure.MCvSeq">
            <summary>
            Managed structure equivalent to CvSeq
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.flags">
            <summary>
             Micsellaneous flags 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.header_size">
            <summary>
             Size of sequence header 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.h_prev">
            <summary>
             Previous sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.h_next">
            <summary>
             Next sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.v_prev">
            <summary>
             2nd previous sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.v_next">
            <summary>
             2nd next sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.total">
            <summary>
             Total number of elements 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.elem_size">
            <summary>
             Size of sequence element in bytes 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.block_max">
            <summary>
             Maximal bound of the last block 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.ptr">
            <summary>
             Current write pointer 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.delta_elems">
            <summary>
             How many elements allocated when the sequence grows (sequence granularity 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.storage">
            <summary>
             Where the seq is stored 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.free_blocks">
            <summary>
             Free blocks list 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeq.first">
            <summary>
             Pointer to the first sequence block 
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvSeqBlock">
            <summary>
            Managed structure equivalent to CvSeqBlock
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqBlock.prev">
            <summary>
            Previous sequence block.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqBlock.next">
            <summary>
            Next sequence block.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqBlock.start_index">
            <summary>
            Index of the first element in the block + sequence-&gt;first-&gt;start_index.   
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqBlock.count">
            <summary>
            Number of elements in the block.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqBlock.data">
            <summary>
            Pointer to the first element of the block.
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvSeqReader">
            <summary>
            Wrapped CvSeqReader structure
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqReader.header_size">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqReader.seq">
            <summary>
            sequence, beign read
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqReader.block">
            <summary>
            current block
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqReader.ptr">
            <summary>
            pointer to element be read next 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqReader.block_min">
            <summary>
             pointer to the beginning of block 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqReader.block_max">
            <summary>
            pointer to the end of block
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqReader.delta_index">
            <summary>
            = seq->first->start_index 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSeqReader.prev_elem">
            <summary>
            pointer to previous element
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvSet">
            <summary>
            Wrapper CvSet structure
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.flags">
            <summary>
             micsellaneous flags 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.header_size">
            <summary>
             size of sequence header 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.h_prev">
            <summary>
             previous sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.h_next">
            <summary>
             next sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.v_prev">
            <summary>
             2nd previous sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.v_next">
            <summary>
             2nd next sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.total">
            <summary>
             total number of elements 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.elem_size">
            <summary>
            size of sequence element in bytes 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.block_max">
            <summary>
            maximal bound of the last block 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.ptr">
            <summary>
             current write pointer 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.delta_elems">
            <summary>
             how many elements allocated when the sequence grows (sequence granularity 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.storage">
            <summary>
             where the seq is stored 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.free_blocks">
            <summary>
             free blocks list 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.first">
            <summary>
             pointer to the first sequence block 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.free_elems">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSet.active_count">
            <summary>
            
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvSetElem">
            <summary>
            Wrapper CvSetElem structure
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSetElem.flags">
            <summary>
            flags
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSetElem.next_free">
            <summary>
            next_free
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvSlice">
            <summary>
            Managed structure equivalent to CvSlice
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSlice.start_index">
            <summary>
            Start index
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSlice.end_index">
            <summary>
            End index
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvSlice.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a new MCvSlice using the specific start and end index
            </summary>
            <param name="start">start index</param>
            <param name="end">end index</param>
        </member>
        <member name="P:Emgu.CV.Structure.MCvSlice.WholeSeq">
            <summary>
            Get the equivalent of CV_WHOLE_SEQ
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvStarKeypoint">
            <summary>
            CvStarKeypoiny
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStarKeypoint.pt">
            <summary>
            The location of the keypoint
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStarKeypoint.size">
            <summary>
            The size of the key point
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStarKeypoint.response">
            <summary>
            The response of the key point
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvStereoBMState">
            <summary>
            Wrapped CvStereoBMState structure
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.preFilterType">
            <summary>
            0 for now
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.preFilterSize">
            <summary>
            ~5x5..21x21
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.preFilterCap">
            <summary>
            up to ~31
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.SADWindowSize">
            <summary>
            Could be 5x5..21x21. Correspondence using Sum of Absolute Difference (SAD):
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.minDisparity">
            <summary>
            minimum disparity (=0)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.numberOfDisparities">
            <summary>
            maximum disparity - minimum disparity
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.textureThreshold">
            <summary>
            areas with no texture are ignored
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.uniquenessRatio">
            <summary>
            Filter out pixels if there are other close matches
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.speckleWindowSize">
            <summary>
            Disparity variation window (not used)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.speckleRange">
            <summary>
            Acceptable range of variation in window (not used)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.trySmallerWindows">
            <summary>
            If 1, the results may be more accurate at the expense of slower processing.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.roi1">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.roi2">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.disp12MaxDiff">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.preFilteredImg0">
            <summary>
            internal buffers, do not modify (!)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.preFilteredImg1">
            <summary>
            internal buffers, do not modify (!)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.slidingSumBuf">
            <summary>
            internal buffers, do not modify (!)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.cost">
            <summary>
            internal buffers, do not modify (!)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoBMState.disp">
            <summary>
            internal buffers, do not modify (!)
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvStereoGCState">
            <summary>
            Wrapped CvStereoGCState structure
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.Ithreshold">
            <summary>
            Threshold for piece-wise linear data cost function (5 by default)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.interactionRadius">
            <summary>
            Radius for smoothness cost function (1 by default; means Potts model)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.K">
            <summary>
            Parameters for the cost function
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.lambda">
            <summary>
            Parameters for the cost function
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.lambda1">
            <summary>
            Parameters for the cost function
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.lambda2">
            <summary>
            Parameters for the cost function
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.occlusionCost">
            <summary>
            10000 by default, (usually computed adaptively from the input data)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.minDisparity">
            <summary>
            0 by default; see CvStereoBMState
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.numberOfDisparities">
            <summary>
            Defined by user; see CvStereoBMState
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.maxIters">
            <summary>
            Number of iterations; defined by user.
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.left">
            <summary>
            Internal buffers
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.right">
            <summary>
            Internal buffers
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.dispLeft">
            <summary>
            Internal buffers
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.dispRight">
            <summary>
            Internal buffers
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.ptrLeft">
            <summary>
            Internal buffers
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.ptrRight">
            <summary>
            Internal buffers
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.vtxBuf">
            <summary>
            Internal buffers
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvStereoGCState.edgeBuf">
            <summary>
            Internal buffers
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvSubdiv2D">
            <summary>
            Managed CvSubdiv2D structure
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2D.flags">
            <summary>
              micsellaneous flags 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2D.header_size">
            <summary>
              size of sequence header 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2D.h_prev">
            <summary>
              previous sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2D.h_next">
            <summary>
              next sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2D.v_prev">
            <summary>
              2nd previous sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2D.v_next">
            <summary>
              2nd next sequence 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2D.total">
            <summary>
              total number of elements 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2D.elem_size">
            <summary>
              size of sequence element in bytes 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2D.block_max">
            <summary>
              maximal bound of the last block 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2D.ptr">
            <summary>
              current write pointer 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2D.delta_elems">
            <summary>
              how many elements allocated when the seq grows 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2D.storage">
            <summary>
              where the seq is stored 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2D.free_blocks">
            <summary>
              free blocks list 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2D.first">
            <summary>
              pointer to the first sequence block 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2D.free_elems">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2D.active_count">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2D.edges">
            <summary>
            Pointer to CvSet
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2D.quad_edges">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2D.is_geometry_valid">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2D.recent_edge">
            <summary>
            
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2D.topleft">
            <summary>
            The virtual topleft corner of this subdivision
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2D.bottomright">
            <summary>
            The virtual bottom right corner of this subdivision
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvSubdiv2DEdge">
            <summary>
            Wrapped CvSubdiv2DEdge structure
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2DEdge.edge">
            <summary>
            one of edges within quad-edge, lower 2 bits is index (0..3) and upper bits are quad-edge pointer 
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvSubdiv2DEdge.#ctor(System.IntPtr)">
            <summary>
            Create a MCvSubdiv2DEdge from the specific edge
            </summary>
            <param name="e">the edge</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvSubdiv2DEdge.cvSubdiv2DEdgeOrg">
            <summary>
            similar to cvSubdiv2DEdgeOrg
            </summary>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvSubdiv2DEdge.cvSubdiv2DEdgeDst">
            <summary>
            similar to cvSubdiv2DEdgeDst
            </summary>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvSubdiv2DEdge.cvSubdiv2DRotateEdge(System.Int32)">
             <summary>
             Similar to cvSubdiv2DRotateEdge
             </summary>
             <param name="rotate">
             Specifies, which of edges of the same quad-edge as the input one to return, one of:
             0 - the input edge (e if e is the input edge) 
             1 - the rotated edge (eRot) 
             2 - the reversed edge (reversed e (in green)) 
             3 - the reversed rotated edge (reversed eRot (in green)) 
            </param>
             <returns>The rotated edge</returns>
        </member>
        <member name="M:Emgu.CV.Structure.MCvSubdiv2DEdge.cvSubdiv2DGetEdge(Emgu.CV.CvEnum.CV_NEXT_EDGE_TYPE)">
            <summary>
            Similar to cvSubdiv2DGetEdge
            </summary>
            <param name="type">The next edge type</param>
            <returns>The next edge</returns>
        </member>
        <member name="T:Emgu.CV.Structure.MCvSubdiv2DPoint">
            <summary>
            Managed CvSubdiv2DPoint structure
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2DPoint.flags">
            <summary>
            If -1, this point is invalid;
            If 1&gt;&gt;30, this point is a virtual point;
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2DPoint.first">
            <summary>
            The first edge associate with this point
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2DPoint.pt">
            <summary>
            The PointF
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSubdiv2DPoint.id">
            <summary>
            The ID
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.MCvSubdiv2DPoint.IsValid">
            <summary>
            Return true if this is a valid point
            </summary>
        </member>
        <member name="T:Emgu.CV.MCvSURFParams">
            <summary>
            Wrapped CvSURFParams structure
            </summary>
        </member>
        <member name="M:Emgu.CV.MCvSURFParams.#ctor(System.Double,System.Boolean)">
            <summary>
            Create a MCvSURFParams using the specific values
            </summary>
            <param name="hessianThresh">      
            Only features with keypoint.hessian larger than that are extracted.
            good default value is ~300-500 (can depend on the average local contrast and sharpness of the image).
            user can further filter out some features based on their hessian values and other characteristics
            </param>
            <param name="extendedFlag">      
            false means basic descriptors (64 elements each),
            true means extended descriptors (128 elements each)
            </param>
        </member>
        <member name="F:Emgu.CV.MCvSURFParams.extended">
            <summary>
            0 means basic descriptors (64 elements each),
            1 means extended descriptors (128 elements each)
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvSURFParams.hessianThreshold">
            <summary>
            Only features with keypoint.hessian larger than that are extracted.
            good default value is ~300-500 (can depend on the average local contrast and sharpness of the image).
            user can further filter out some features based on their hessian values and other characteristics
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvSURFParams.nOctaves">
            <summary>
            The number of octaves to be used for extraction.
            With each next octave the feature size is doubled (3 by default)
            </summary>
        </member>
        <member name="F:Emgu.CV.MCvSURFParams.nOctaveLayers">
            <summary>
            The number of layers within each octave (4 by default)
            </summary>
        </member>
        <member name="M:Emgu.CV.MCvSURFParams.DetectKeyPoints(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Detect the SURF keypoints from the image
            </summary>
            <param name="image">The image to extract SURF features from</param>
            <param name="mask">The optional mask, can be null if not needed</param>
            <returns>An array of SURF key points</returns>
        </member>
        <member name="M:Emgu.CV.MCvSURFParams.DetectFeatures(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Detect image features from the given image
            </summary>
            <param name="image">The image to detect features from</param>
            <param name="mask">The optional mask, can be null if not needed</param>
            <returns>The Image features detected from the given image</returns>
        </member>
        <member name="M:Emgu.CV.MCvSURFParams.ComputeDescriptors(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Structure.MKeyPoint[])">
            <summary>
            Compute the descriptor given the image and the point location
            </summary>
            <param name="image">The image where the descriptor will be computed from</param>
            <param name="mask">The optional mask, can be null if not needed</param>
            <param name="keyPoints">The keypoint where the descriptor will be computed from</param>
            <returns>The image features founded on the keypoint location</returns>
        </member>
        <member name="T:Emgu.CV.Structure.MCvSURFPoint">
            <summary>
            Wrapped CvSURFPoint structure
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSURFPoint.pt">
            <summary>
            Position of the feature within the image
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSURFPoint.laplacian">
            <summary>
            -1, 0 or +1. sign of the laplacian at the point.
            can be used to speedup feature comparison
            (normally features with laplacians of different signs can not match)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSURFPoint.size">
            <summary>
            Size of the feature
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSURFPoint.dir">
            <summary>
            Orientation of the feature: 0..360 degrees
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvSURFPoint.hessian">
            <summary>
            Value of the hessian (can be used to approximately estimate the feature strengths;
            see also params.hessianThreshold.
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MCvTermCriteria">
            <summary>
            Managed structure equivalent to CvTermCriteria
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvTermCriteria.type">
            <summary>
            CV_TERMCRIT value
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvTermCriteria.max_iter">
            <summary>
            Maximum iteration
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MCvTermCriteria.epsilon">
            <summary>
            Epsilon
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.MCvTermCriteria.#ctor(System.Int32)">
            <summary>
            Create the termination criteria using the constrain of maximum iteration
            </summary>
            <param name="maxIteration">The maximum number of iteration allowed</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvTermCriteria.#ctor(System.Double)">
            <summary>
            Create the termination Criteria using only the constrain of epsilon
            </summary>
            <param name="eps"> The epsilon value</param>
        </member>
        <member name="M:Emgu.CV.Structure.MCvTermCriteria.#ctor(System.Int32,System.Double)">
            <summary>
            Create the termination criteria using the constrain of maximum iteration as well as epsilon
            </summary>
            <param name="maxIteration">The maximum number of iteration allowed</param>
            <param name="eps">The epsilon value</param>
        </member>
        <member name="T:Emgu.CV.Structure.MIplImage">
            <summary>
            Managed structure equivalent to IplImage
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.nSize">
            <summary>
            sizeof(IplImage) 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.ID">
            <summary>
            version (=0)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.nChannels">
            <summary>
            Most of OpenCV functions support 1,2,3 or 4 channels 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.alphaChannel">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.depth">
            <summary>
            pixel depth in bits: IPL_DEPTH_8U, IPL_DEPTH_8S, IPL_DEPTH_16U, IPL_DEPTH_16S, IPL_DEPTH_32S, IPL_DEPTH_32F and IPL_DEPTH_64F are supported 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.colorModel">
            <summary>
            ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.channelSeq">
            <summary>
            ditto
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.dataOrder">
            <summary>
            0 - interleaved color channels, 1 - separate color channels.
            cvCreateImage can only create interleaved images 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.origin">
            <summary>
            0 - top-left origin,
            1 - bottom-left origin (Windows bitmaps style)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.align">
            <summary>
            Alignment of image rows (4 or 8).
            OpenCV ignores it and uses widthStep instead 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.width">
            <summary>
            image width in pixels 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.height">
            <summary>
            image height in pixels 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.roi">
            <summary>
            image ROI. when it is not NULL, this specifies image region to process 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.maskROI">
            <summary>
            must be NULL in OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.imageId">
            <summary>
            ditto
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.tileInfo">
            <summary>
            ditto 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.imageSize">
            <summary>
            image data size in bytes
            (=image->height*image->widthStep in case of interleaved data)
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.imageData">
            <summary>
            pointer to aligned image data 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.widthStep">
            <summary>
            size of aligned image row in bytes 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderMode">
            <summary>
            border completion mode, ignored by OpenCV 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.BorderConst">
            <summary>
            ditto
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MIplImage.imageDataOrigin">
            <summary>
             pointer to a very origin of image data (not necessarily aligned) - it is needed for correct image deallocation 
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.MKeyPoint">
            <summary>
            OpenCV's KeyPoint class
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MKeyPoint.Point">
            <summary>
            The location of the keypoint
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MKeyPoint.Size">
            <summary>
            Size of the keypoint
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MKeyPoint.Angle">
            <summary>
            Orientation of the keypoint
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MKeyPoint.Response">
            <summary>
            Response of the keypoint
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MKeyPoint.Octave">
            <summary>
            octave
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.MKeyPoint.ClassId">
            <summary>
            class id
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.RangeF">
            <summary>
            The range use to setup the histogram
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.RangeF.#ctor(System.Single,System.Single)">
            <summary>
            Create a range of the specific min/max value
            </summary>
            <param name="min">The min value of this range</param>
            <param name="max">The max value of this range</param>
        </member>
        <member name="M:Emgu.CV.Structure.RangeF.Equals(Emgu.CV.Structure.RangeF)">
            <summary>
            Return true if the two RangeF equals
            </summary>
            <param name="other">The other RangeF to compare with</param>
            <returns>True if the two RangeF equals</returns>
        </member>
        <member name="P:Emgu.CV.Structure.RangeF.Min">
            <summary>
            The minimum value of this range
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.RangeF.Max">
            <summary>
            The Maximum value of this range
            </summary>
        </member>
        <member name="T:Emgu.CV.PlanarObjectDetector">
            <summary>
            A Planar object detector
            </summary>
        </member>
        <member name="M:Emgu.CV.PlanarObjectDetector.#ctor">
            <summary>
            Create a planar Object detector
            </summary>
        </member>
        <member name="M:Emgu.CV.PlanarObjectDetector.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this detector
            </summary>
        </member>
        <member name="M:Emgu.CV.PlanarObjectDetector.Train(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Emgu.CV.LDetector@,Emgu.CV.PatchGenerator@)">
            <summary>
            Train the planar object detector using the specific image
            </summary>
            <param name="image">The training image</param>
            <param name="npoints">Use 300 for default</param>
            <param name="patchSize">Use 31 for default</param>
            <param name="nstructs">Use 50 for default</param>
            <param name="structSize">Use 9 for default</param>
            <param name="nviews">Use 5000 for default</param>
            <param name="keyPointDetector">The keypoint detector to be used</param>
            <param name="patchGenerator">The patch generator to be used</param>
        </member>
        <member name="M:Emgu.CV.PlanarObjectDetector.Detect(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.HomographyMatrix)">
            <summary>
            Detect planar object from the specific image
            </summary>
            <param name="image">The image where the planar object will be detected</param>
            <param name="h">The homography matrix which will be updated</param>
            <returns>The four corners of the detected region</returns>
        </member>
        <member name="M:Emgu.CV.PlanarObjectDetector.GetModelPoints">
            <summary>
            Get the model points stored in this detector
            </summary>
            <returns>The model points stored in this detector</returns>
        </member>
        <member name="T:Emgu.CV.PlanarSubdivision">
            <summary>
            Plannar Subdivision, can be use to compute Delaunnay's triangulation or Voroni diagram.
            </summary>
        </member>
        <member name="M:Emgu.CV.PlanarSubdivision.#ctor(System.Drawing.Rectangle@)">
            <summary>
            Start the Delaunay's triangulation in the specific region of interest.
            </summary>
            <param name="roi">The region of interest of the triangulation</param>
        </member>
        <member name="M:Emgu.CV.PlanarSubdivision.#ctor(System.Drawing.PointF[])">
            <summary>
            Create a planar subdivision from the given points. The ROI is computed as the minimun bounding Rectangle for the input points
            </summary>
            <param name="points">The points for this planar subdivision</param>
        </member>
        <member name="M:Emgu.CV.PlanarSubdivision.#ctor(System.Drawing.PointF[],System.Boolean)">
            <summary>
            Create a planar subdivision from the given points. The ROI is computed as the minimun bounding Rectangle for the input points
            </summary>
            <param name="silent">If true, any exception during insert will be ignored</param>
            <param name="points">The points to be inserted to this planar subdivision</param>
        </member>
        <member name="M:Emgu.CV.PlanarSubdivision.Insert(System.Drawing.PointF[],System.Boolean)">
            <summary>
            Insert a collection of points to this planar subdivision
            </summary>
            <param name="points">The points to be inserted to this planar subdivision</param>
            <param name="silent">If true, any exception during insert will be ignored</param>
        </member>
        <member name="M:Emgu.CV.PlanarSubdivision.Insert(System.Drawing.PointF)">
            <summary>
            Insert a point to the triangulation. If the point is already inserted, no changes will be made.
            </summary>
            <param name="point">The point to be inserted</param>
        </member>
        <member name="M:Emgu.CV.PlanarSubdivision.Locate(System.Drawing.PointF@,System.Nullable{Emgu.CV.Structure.MCvSubdiv2DEdge}@,System.Nullable{Emgu.CV.Structure.MCvSubdiv2DPoint}@)">
            <summary>
            Locates input point within subdivision
            </summary>
            <param name="pt">The point to locate</param>
            <param name="subdiv2DEdge">The output edge the point falls onto or right to</param>
            <param name="subdiv2DPoint">Optional output vertex double pointer the input point coincides with</param>
            <returns>The type of location for the point</returns>
        </member>
        <member name="M:Emgu.CV.PlanarSubdivision.FindNearestPoint2D(System.Drawing.PointF@)">
            <summary>
            Finds subdivision vertex that is the closest to the input point. It is not necessarily one of vertices of the facet containing the input point, though the facet (located using cvSubdiv2DLocate) is used as a starting point.
            </summary>
            <param name="point">Input point</param>
            <returns>The nearest subdivision vertex</returns>
        </member>
        <member name="M:Emgu.CV.PlanarSubdivision.GetDelaunayTriangles">
            <summary>
            Returns the triangles of the Delaunay's triangulation
            </summary>
            <remarks>The vertices of the triangles all belongs to the inserted points</remarks>
            <returns>The result of the current triangulation</returns>
        </member>
        <member name="M:Emgu.CV.PlanarSubdivision.GetVoronoiFacets">
            <summary>
            Obtains the list of Voronoi Facets 
            </summary>
            <returns>The list of Voronoi Facets</returns>
        </member>
        <member name="M:Emgu.CV.PlanarSubdivision.GetDelaunayTriangles(System.Boolean)">
            <summary>
            Retruns the triangles subdivision of the current planar subdivision. 
            </summary>
            <param name="includeVirtualPoints">Indicates if virtual points should be included or not</param>
            <remarks>The triangles might contains virtual points that do not belongs to the inserted points, if you do not want those points, set <paramref name="includeVirtualPoints"> to false</paramref></remarks>
            <returns>The triangles subdivision in the current plannar subdivision</returns>
        </member>
        <member name="M:Emgu.CV.PlanarSubdivision.DisposeObject">
            <summary>
            Release unmanaged resources
            </summary>
        </member>
        <member name="M:Emgu.CV.PlanarSubdivision.ReleaseManagedResources">
            <summary>
            Release the storage related to this triangulation
            </summary>
        </member>
        <member name="M:Emgu.CV.PlanarSubdivision.GetEnumerator">
            <summary>
            Get an enumerator of the QuadEdges in this plannar subdivision
            </summary>
            <returns>An enumerator of all MCvQuadEdge2D</returns>
        </member>
        <member name="P:Emgu.CV.PlanarSubdivision.MCvSubdiv2D">
            <summary>
            Get the MCvSubdiv2D structure of this Delaunay's triangulation
            </summary>
        </member>
        <member name="T:Emgu.CV.VoronoiFacet">
            <summary>
            A Voronoi Facet
            </summary>
        </member>
        <member name="M:Emgu.CV.VoronoiFacet.#ctor(System.Drawing.PointF,System.Drawing.PointF[])">
            <summary>
            Create a Voronoi facet using the specific <paramref name="point"/> and <paramref name="polyline"/>
            </summary>
            <param name="point">The point this facet associate with </param>
            <param name="polyline">The points that defines the contour of this facet</param>
        </member>
        <member name="P:Emgu.CV.VoronoiFacet.Point">
            <summary>
            The point this facet associates to
            </summary>
        </member>
        <member name="P:Emgu.CV.VoronoiFacet.Vertices">
            <summary>
            Get or set the vertices of this facet
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.LineSegment2D">
            <summary> 
            A line segment 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.LineSegment2D._p1">
            <summary> A point on the line </summary>
        </member>
        <member name="F:Emgu.CV.Structure.LineSegment2D._p2">
            <value> An other point on the line </value>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2D.#ctor(System.Drawing.Point,System.Drawing.Point)">
            <summary> 
            Create a line segment with the specific starting point and end point 
            </summary>
            <param name="p1">The first point on the line segment</param>
            <param name="p2">The second point on the line segment</param>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2D.Side(System.Drawing.Point)">
            <summary>
            Determine which side of the line the 2D point is at
            </summary>
            <param name="point">the point</param>
            <returns>
            1 if on the right hand side;
            0 if on the line;
            -1 if on the left hand side;
            </returns>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2D.GetExteriorAngleDegree(Emgu.CV.Structure.LineSegment2D)">
            <summary>
            Get the exterior angle between this line and <paramref name="otherLine"/>
            </summary>
            <param name="otherLine">The other line</param>
            <returns>The exterior angle between this line and <paramref name="otherLine"/></returns>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2D.P1">
            <summary> A point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2D.P2">
            <summary> An other point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2D.Direction">
            <summary> The direction of the line, the norm of which is 1 </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2D.Length">
            <summary> 
            Get the length of the line segment 
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.LineSegment2DF">
            <summary> 
            A line segment 
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.LineSegment2DF._p1">
            <summary> A point on the line </summary>
        </member>
        <member name="F:Emgu.CV.Structure.LineSegment2DF._p2">
            <value> An other point on the line </value>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2DF.#ctor(System.Drawing.PointF,System.Drawing.PointF)">
            <summary> 
            Create a line segment with the specific start point and end point 
            </summary>
            <param name="p1">The first point on the line segment</param>
            <param name="p2">The second point on the line segment</param>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2DF.YByX(System.Single)">
            <summary> Obtain the Y value from the X value using first degree interpolation</summary>
            <param name="x">The X value</param>
            <returns>The Y value</returns>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2DF.Side(System.Drawing.PointF)">
            <summary>
            Determin which side of the line the 2D point is at
            </summary>
            <param name="point">the point</param>
            <returns>
            1 if on the right hand side;
            0 if on the line;
            -1 if on the left hand side;
            </returns>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment2DF.GetExteriorAngleDegree(Emgu.CV.Structure.LineSegment2DF)">
            <summary>
            Get the exterior angle between this line and <paramref name="otherLine"/>
            </summary>
            <param name="otherLine">The other line</param>
            <returns>The exterior angle between this line and <paramref name="otherLine"/></returns>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2DF.P1">
            <summary> A point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2DF.P2">
            <summary> An other point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2DF.Length">
            <summary> 
            Get the length of the line segment 
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment2DF.Direction">
            <summary> 
            The direction of the line, the norm of which is 1 
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.LineSegment3DF">
            <summary>
            A 3D line segment
            </summary>
        </member>
        <member name="F:Emgu.CV.Structure.LineSegment3DF._p1">
            <summary> A point on the line </summary>
        </member>
        <member name="F:Emgu.CV.Structure.LineSegment3DF._p2">
            <value> An other point on the line </value>
        </member>
        <member name="M:Emgu.CV.Structure.LineSegment3DF.#ctor(Emgu.CV.Structure.MCvPoint3D32f,Emgu.CV.Structure.MCvPoint3D32f)">
            <summary> 
            Create a line segment with the specific start point and end point 
            </summary>
            <param name="p1">The first point on the line segment</param>
            <param name="p2">The second point on the line segment</param>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment3DF.P1">
            <summary> A point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment3DF.P2">
            <summary> An other point on the line </summary>
        </member>
        <member name="P:Emgu.CV.Structure.LineSegment3DF.Length">
            <summary> 
            Get the length of the line segment 
            </summary>
        </member>
        <member name="T:Emgu.CV.PointCollection">
            <summary>
            A collection of points
            </summary>
        </member>
        <member name="M:Emgu.CV.PointCollection.Line2DFitting(System.Drawing.PointF[],Emgu.CV.CvEnum.DIST_TYPE,System.Drawing.PointF@,System.Drawing.PointF@)">
            <summary>
            Fit a line to the points collection
            </summary>
            <param name="points">The points to be fitted</param>
            <param name="type">The type of the fitting</param>
            <param name="normalizedDirection">The normalized direction of the fitted line</param>
            <param name="aPointOnLine">A point on the fitted line</param>
        </member>
        <member name="M:Emgu.CV.PointCollection.EllipseLeastSquareFitting(System.Drawing.PointF[])">
            <summary>
            Fit an ellipse to the points collection
            </summary>
            <param name="points">The points to be fitted</param>
            <returns>An ellipse</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection.PolyLine(System.Drawing.PointF[],System.Boolean)">
            <summary>
            convert a series of points to LineSegment2D
            </summary>
            <param name="points">the array of points</param>
            <param name="closed">if true, the last line segment is defined by the last point of the array and the first point of the array</param>
            <returns>array of LineSegment2D</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection.PolyLine(System.Drawing.Point[],System.Boolean)">
            <summary>
            convert a series of System.Drawing.Point to LineSegment2D
            </summary>
            <param name="points">the array of points</param>
            <param name="closed">if true, the last line segment is defined by the last point of the array and the first point of the array</param>
            <returns>array of LineSegment2D</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection.ConvexHull(System.Drawing.PointF[],Emgu.CV.MemStorage,Emgu.CV.CvEnum.ORIENTATION)">
            <summary>
            Finds convex hull of 2D point set using Sklansky's algorithm
            </summary>
            <param name="points">The points to find convex hull from</param>
            <param name="storage">the storage used by the resulting sequence</param>
            <param name="orientation">The orientation of the convex hull</param>
            <returns>The convex hull of the points</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection.BoundingRectangle(System.Drawing.PointF[])">
            <summary>
            Find the bounding rectangle for the specific array of points
            </summary>
            <param name="points">The collection of points</param>
            <returns>The bounding rectangle for the array of points</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection.MinAreaRect(System.Drawing.PointF[])">
            <summary>
            Find the bounding rectangle for the specific array of points
            </summary>
            <param name="points">The collection of points</param>
            <returns>The bounding rectangle for the array of points</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection.MinEnclosingCircle(System.Drawing.PointF[])">
            <summary>
            Find the minimum enclosing circle for the specific array of points
            </summary>
            <param name="points">The collection of points</param>
            <returns>The minimum enclosing circle for the array of points</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection.ReprojectImageTo3D(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Int16},Emgu.CV.Matrix{System.Double})">
            <summary>
            Reproject pixels on a 1-channel disparity map to array of 3D points.
            </summary>
            <param name="disparity">Disparity map</param>
            <param name="Q">The reprojection 4x4 matrix, can be arbitrary, e.g. the one, computed by cvStereoRectify</param>
            <returns>The reprojected 3D points</returns>
        </member>
        <member name="M:Emgu.CV.PointCollection.GeneratePointCloud(Emgu.CV.Structure.Ellipse,System.Int32)">
            <summary>
            Generate a random point cloud around the ellipse. 
            </summary>
            <param name="e">The region where the point cloud will be generated. The axes of e corresponds to std of the random point cloud.</param>
            <param name="numberOfPoints">The number of points to be generated</param>
            <returns>A random point cloud around the ellipse</returns>
        </member>
        <member name="T:Emgu.CV.Properties.StringTable">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Emgu.CV.Properties.StringTable.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Emgu.CV.Properties.StringTable.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Emgu.CV.Properties.StringTable.BoundingRectangleNotCalculated">
            <summary>
              Looks up a localized string similar to The bounding rectangle is not calculated, consider calling CvInvoke.cvBoundingRect(thisContour, 1) first..
            </summary>
        </member>
        <member name="P:Emgu.CV.Properties.StringTable.FailToCreateHaarCascade">
            <summary>
              Looks up a localized string similar to Fail to create HaarCascade object: {0}.
            </summary>
        </member>
        <member name="P:Emgu.CV.Properties.StringTable.FileNotFound">
            <summary>
              Looks up a localized string similar to File Not Found.
            </summary>
        </member>
        <member name="P:Emgu.CV.Properties.StringTable.IncompatibleDimension">
            <summary>
              Looks up a localized string similar to Incompatible Dimension.
            </summary>
        </member>
        <member name="P:Emgu.CV.Properties.StringTable.NotImplemented">
            <summary>
              Looks up a localized string similar to Not implmented.
            </summary>
        </member>
        <member name="P:Emgu.CV.Properties.StringTable.ThicknessShouldBeGreaterThanZero">
            <summary>
              Looks up a localized string similar to Thickness should be &gt; 0.
            </summary>
        </member>
        <member name="P:Emgu.CV.Properties.StringTable.UnsupportedImageDepth">
            <summary>
              Looks up a localized string similar to Unsupported image depth.
            </summary>
        </member>
        <member name="T:Emgu.CV.Reflection.ExposableMethodAttribute">
            <summary>
            Attribute used by ImageBox to generate Operation Menu
            </summary>
        </member>
        <member name="M:Emgu.CV.Reflection.ExposableMethodAttribute.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="P:Emgu.CV.Reflection.ExposableMethodAttribute.Exposable">
            <summary>
            Get or Set the exposable value, if true, this function will be displayed in Operation Menu of ImageBox
            </summary>
        </member>
        <member name="P:Emgu.CV.Reflection.ExposableMethodAttribute.Category">
            <summary>
            The catefory of this function
            </summary>
        </member>
        <member name="P:Emgu.CV.Reflection.ExposableMethodAttribute.GenericParametersOptionSizes">
            <summary>
            The size for each generic parameter Options
            </summary>
        </member>
        <member name="P:Emgu.CV.Reflection.ExposableMethodAttribute.GenericParametersOptions">
            <summary>
            The options for generic parameters
            </summary>
        </member>
        <member name="T:Emgu.CV.Reflection.GenericParameter">
            <summary>
            A generic parameter for the Operation class
            </summary>
        </member>
        <member name="M:Emgu.CV.Reflection.GenericParameter.#ctor(System.Type,System.Type[])">
            <summary>
            Create a generic parameter for the Operation class
            </summary>
            <param name="selectedType">The selected generic parameter typ</param>
            <param name="availableType">The types that can be used</param>
        </member>
        <member name="P:Emgu.CV.Reflection.GenericParameter.SelectedType">
            <summary>
            The selected generic parameter type
            </summary>
        </member>
        <member name="P:Emgu.CV.Reflection.GenericParameter.AvailableTypes">
            <summary>
            The types that can be used
            </summary>
        </member>
        <member name="T:Emgu.CV.Reflection.ReflectColorType">
            <summary>
            A collection of reflection function that can be applied to ColorType object
            </summary>
        </member>
        <member name="M:Emgu.CV.Reflection.ReflectColorType.GetDisplayColorOfChannels(Emgu.CV.IColor)">
            <summary>
            Get the display color for each channel
            </summary>
            <param name="color">The color</param>
            <returns>The display color for each channel</returns>
        </member>
        <member name="M:Emgu.CV.Reflection.ReflectColorType.GetNamesOfChannels(Emgu.CV.IColor)">
            <summary>
            Get the names of the channels
            </summary>
            <param name="color">The color</param>
            <returns>The names of the channels</returns>
        </member>
        <member name="T:Emgu.CV.Reflection.ReflectIImage">
            <summary>
            A collection of reflection function that can be applied to IImage object
            </summary>
        </member>
        <member name="M:Emgu.CV.Reflection.ReflectIImage.GetImageMethods(Emgu.CV.IImage)">
            <summary>
            Get all the methods that belongs to the IImage and Image class with ExposableMethodAttribute set true.
            </summary>
            <param name="image">The IImage object to be refelected for methods marked with ExposableMethodAttribute</param>
            <returns>All the methods that belongs to the IImage and Image class with ExposableMethodAttribute set true</returns>
        </member>
        <member name="M:Emgu.CV.Reflection.ReflectIImage.GetTypeOfColor(Emgu.CV.IImage)">
            <summary>
            Get the color type of the image
            </summary>
            <param name="image">The image to apply reflection on</param>
            <returns>The color type of the image</returns>
        </member>
        <member name="M:Emgu.CV.Reflection.ReflectIImage.GetTypeOfDepth(Emgu.CV.IImage)">
            <summary>
            Get the depth type of the image
            </summary>
            <param name="image">The image to apply reflection on</param>
            <returns>The depth type of the image</returns>
        </member>
        <member name="M:Emgu.CV.Reflection.ReflectIImage.GetPixelColor(Emgu.CV.IImage,System.Drawing.Point)">
            <summary>
            Get the color at the specific location of the image
            </summary>
            <param name="image">The image to obtain pixel value from</param>
            <param name="location">The location to sample a pixel</param>
            <returns>The color at the specific location</returns>
        </member>
        <member name="T:Emgu.CV.RTreeClassifier`1">
            <summary>
            The Calonder classifier
            </summary>
        </member>
        <member name="M:Emgu.CV.RTreeClassifier`1.#ctor">
            <summary>
            Create an Calonder classifier
            </summary>
        </member>
        <member name="M:Emgu.CV.RTreeClassifier`1.Train(Emgu.CV.Image{`0,System.Byte},System.Drawing.Point[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Train the calonder classifier with the specific images
            </summary>
            <param name="trainImage">The traning image</param>
            <param name="keypoints">The keypoints on this image</param>
            <param name="numTrees">Use 48 for default</param>
            <param name="depth">Use 9 for default</param>
            <param name="views">Use 5000 for default</param>
            <param name="reducedNumDim">use 176 for default</param>
            <param name="numQuantBits">Use 4 for default</param>
        </member>
        <member name="M:Emgu.CV.RTreeClassifier`1.DisposeObject">
            <summary>
            Release the unmanaged resource associated with this classifier
            </summary>
        </member>
        <member name="M:Emgu.CV.RTreeClassifier`1.GetSigniture(Emgu.CV.Image{`0,System.Byte},System.Drawing.Point,System.Int32)">
            <summary>
            Compute the signiture from the given location on the image
            </summary>
            <param name="image">The image to compute signiture from</param>
            <param name="keypoint">The location of the key point</param>
            <param name="patchSize">The size of the patch</param>
            <returns>null if the signiture cannot be computed, otherwise the signiture itself is returned.</returns>
        </member>
        <member name="P:Emgu.CV.RTreeClassifier`1.NumberOfClasses">
            <summary>
            Get the number of class used in this classifier
            </summary>
        </member>
        <member name="T:Emgu.CV.SelfSimDescriptor">
            <summary>
            SelfSimDescriptor
            </summary>
        </member>
        <member name="M:Emgu.CV.SelfSimDescriptor.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="smallSize">Use 5 for default</param>
            <param name="largeSize">Use 41 for default</param>
            <param name="startDistanceBucket">Use 3 for default</param>
            <param name="numberOfDistanceBuckets">Use 7 for default</param>
            <param name="numberOfAngles">Use 20 for default</param>
        </member>
        <member name="M:Emgu.CV.SelfSimDescriptor.Compute(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},System.Drawing.Size,System.Drawing.Point[])">
            <summary>
            
            </summary>
            <param name="image"></param>
            <param name="winStride"></param>
            <param name="locations"></param>
            <returns></returns>
        </member>
        <member name="M:Emgu.CV.SelfSimDescriptor.DisposeObject">
            <summary>
            Release all unmanaged memory associated with this descriptor
            </summary>
        </member>
        <member name="P:Emgu.CV.SelfSimDescriptor.DescriptorSize">
            <summary>
            Get the size of the descriptor
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.CircleF">
            <summary> A circle </summary>
        </member>
        <member name="M:Emgu.CV.Structure.CircleF.#ctor(System.Drawing.PointF,System.Single)">
            <summary> Create a circle with the specific center and radius </summary>
            <param name="center"> The center of this circle </param>
            <param name="radius"> The radius of this circle </param>
        </member>
        <member name="M:Emgu.CV.Structure.CircleF.Equals(Emgu.CV.Structure.CircleF)">
            <summary>
            Compare this circle with <paramref name="circle2"/>
            </summary>
            <param name="circle2">The other box to be compared</param>
            <returns>true if the two boxes equals</returns>
        </member>
        <member name="P:Emgu.CV.Structure.CircleF.Center">
            <summary> Get or Set the center of the circle </summary>
        </member>
        <member name="P:Emgu.CV.Structure.CircleF.Radius">
            <summary> The radius of the circle </summary>
        </member>
        <member name="P:Emgu.CV.Structure.CircleF.Area">
            <summary> The area of the circle </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Cross2DF">
            <summary>
            A 2D cross
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Cross2DF.#ctor(System.Drawing.PointF,System.Single,System.Single)">
            <summary>
            Construct a cross
            </summary>
            <param name="center">The center of the cross</param>
            <param name="width">the width of the cross</param>
            <param name="height">the height of the cross</param>
        </member>
        <member name="P:Emgu.CV.Structure.Cross2DF.Center">
            <summary>
            The center of this cross
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Cross2DF.Size">
            <summary>
            The size of this cross
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Cross2DF.Horizontal">
            <summary>
            Get the horizonal linesegment of this cross
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Cross2DF.Vertical">
            <summary>
            Get the vertical linesegment of this cross
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Ellipse">
            <summary>
            An ellipse
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Ellipse.#ctor(System.Drawing.PointF,System.Drawing.SizeF,System.Single)">
            <summary>
            Create an ellipse with specific parameters
            </summary>
            <param name="center"> The center of the ellipse</param>
            <param name="size"> The width and height of the ellipse</param>
            <param name="angle"> The rotation angle in radian for the ellipse</param>
        </member>
        <member name="M:Emgu.CV.Structure.Ellipse.#ctor(Emgu.CV.Structure.MCvBox2D)">
            <summary>
            Create an ellipse from the specific MCvBox2D
            </summary>
            <param name="box2d">The MCvBox2D representation of this ellipse</param>
        </member>
        <member name="P:Emgu.CV.Structure.Ellipse.MCvBox2D">
            <summary>
            The MCvBox2D representation of this ellipse
            </summary>
        </member>
        <member name="T:Emgu.CV.IConvexPolygon">
            <summary>
            An interface for the convex polygon
            </summary>
        </member>
        <member name="M:Emgu.CV.IConvexPolygon.GetVertices">
            <summary>
            Get the vertices of this convex polygon
            </summary>
            <returns>The vertices of this convex polygon</returns>
        </member>
        <member name="T:Emgu.CV.Structure.Triangle2DF">
            <summary>
            A 2D triangle
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Triangle2DF.#ctor(System.Drawing.PointF,System.Drawing.PointF,System.Drawing.PointF)">
            <summary>
            Create a triangle using the specific vertices
            </summary>
            <param name="v0">The first vertex</param>
            <param name="v1">The second vertex</param>
            <param name="v2">The third vertex</param>
        </member>
        <member name="M:Emgu.CV.Structure.Triangle2DF.Equals(Emgu.CV.Structure.Triangle2DF)">
            <summary>
            Compare two triangles and return true if equal
            </summary>
            <param name="tri">the other triangles to compare with</param>
            <returns>true if the two triangles equals, false otherwise</returns>
        </member>
        <member name="M:Emgu.CV.Structure.Triangle2DF.GetVertices">
            <summary>
            Get the vertices of this triangle
            </summary>
            <returns>The vertices of this triangle</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle2DF.V0">
            <summary>
            One of the vertex of the triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle2DF.V1">
            <summary>
            One of the vertex of the triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle2DF.V2">
            <summary>
            One of the vertex of the triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle2DF.Area">
            <summary>
            Get the area of this triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle2DF.Centeroid">
            <summary>
            Returns the centroid of this triangle
            </summary>
        </member>
        <member name="T:Emgu.CV.Structure.Triangle3DF">
            <summary>
            A 3D triangle
            </summary>
        </member>
        <member name="M:Emgu.CV.Structure.Triangle3DF.#ctor(Emgu.CV.Structure.MCvPoint3D32f,Emgu.CV.Structure.MCvPoint3D32f,Emgu.CV.Structure.MCvPoint3D32f)">
            <summary>
            Create a triangle using the specific vertices
            </summary>
            <param name="v0">The first vertex</param>
            <param name="v1">The second vertex</param>
            <param name="v2">The third vertex</param>
        </member>
        <member name="M:Emgu.CV.Structure.Triangle3DF.Equals(Emgu.CV.Structure.Triangle3DF)">
            <summary>
            Compare two triangles and return true if equal
            </summary>
            <param name="tri">the other triangles to compare with</param>
            <returns>true if the two triangles equals, false otherwise</returns>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle3DF.V0">
            <summary>
            One of the vertex of the triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle3DF.V1">
            <summary>
            One of the vertex of the triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle3DF.V2">
            <summary>
            One of the vertex of the triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle3DF.Area">
            <summary>
            Get the area of this triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle3DF.Normal">
            <summary>
            Get the normal of this triangle
            </summary>
        </member>
        <member name="P:Emgu.CV.Structure.Triangle3DF.Centeroid">
            <summary>
            Returns the centroid of this triangle
            </summary>
        </member>
        <member name="T:Emgu.CV.SparseMatrix`1">
            <summary>
            Create a sparse matrix
            </summary>
            <typeparam name="TDepth">The type of elements in this matrix</typeparam>
        </member>
        <member name="M:Emgu.CV.SparseMatrix`1.#ctor(System.Int32[])">
            <summary>
            Create a sparse matrix of the specific dimension
            </summary>
            <param name="dimension">The dimension of the sparse matrix</param>
        </member>
        <member name="M:Emgu.CV.SparseMatrix`1.DisposeObject">
            <summary>
            Release the unmanaged memory associated with this sparase matrix
            </summary>
        </member>
        <member name="P:Emgu.CV.SparseMatrix`1.Item(System.Int32,System.Int32)">
            <summary>
            Get or Set the value in the specific <paramref name="row"/> and <paramref name="col"/>
            </summary>
            <param name="row">the row of the element</param>
            <param name="col">the col of the element</param>
            <returns>The element on the specific <paramref name="row"/> and <paramref name="col"/></returns>
        </member>
        <member name="T:Emgu.CV.StarDetector">
            <summary>
            CvStarDetectorParams
            </summary>
        </member>
        <member name="F:Emgu.CV.StarDetector.MaxSize">
            <summary>
            Maximum size of the features. The following
            values of the parameter are supported:
            4, 6, 8, 11, 12, 16, 22, 23, 32, 45, 46, 64, 90, 128
            </summary>
        </member>
        <member name="F:Emgu.CV.StarDetector.ResponseThreshold">
            <summary>
            Threshold for the approximated laplacian,
            used to eliminate weak features. The larger it is,
            the less features will be retrieved
            </summary>
        </member>
        <member name="F:Emgu.CV.StarDetector.LineThresholdProjected">
            <summary>
            Another threshold for the laplacian to
            eliminate edges.
            The larger the threshold, the more points you get.
            </summary>
        </member>
        <member name="F:Emgu.CV.StarDetector.LineThresholdBinarized">
            <summary>
            Another threshold for the feature
            size to eliminate edges. 
            The larger the threshold, the more points you get.
            </summary>
        </member>
        <member name="F:Emgu.CV.StarDetector.SuppressNonmaxSize">
            <summary>
            
            </summary>
        </member>
        <member name="M:Emgu.CV.StarDetector.SetDefaultParameters">
            <summary>
            Get the default star detector parameters
            </summary>
            <returns>The default star detector parameters</returns>
        </member>
        <member name="M:Emgu.CV.StarDetector.DetectKeyPoints(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Detect STAR key points from the image
            </summary>
            <param name="image">The image to extract key points from</param>
            <returns>The STAR key points of the image</returns>
        </member>
        <member name="T:Emgu.CV.StereoBM">
            <summary>
            Use Block Matching algorithm to find stereo correspondence
            </summary>
        </member>
        <member name="F:Emgu.CV.StereoBM.State">
            <summary>
            The state structure
            </summary>
        </member>
        <member name="M:Emgu.CV.StereoBM.#ctor(Emgu.CV.CvEnum.STEREO_BM_TYPE,System.Int32)">
            <summary>
            Create a stereoBMState
            </summary>
            <param name="type">ID of one of the pre-defined parameter sets. Any of the parameters can be overridden after creating the structure.</param>
            <param name="numberOfDisparities">The number of disparities. If the parameter is 0, it is taken from the preset, otherwise the supplied value overrides the one from preset. </param>
        </member>
        <member name="M:Emgu.CV.StereoBM.FindStereoCorrespondence(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Int16})">
            <summary>
            Computes disparity map for the input rectified stereo pair.
            </summary>
            <param name="left">The left single-channel, 8-bit image</param>
            <param name="right">The right image of the same size and the same type</param>
            <param name="disparity">The output single-channel 16-bit signed disparity map of the same size as input images. Its elements will be the computed disparities, multiplied by 16 and rounded to integer's</param>
            <remarks>Invalid pixels (for which disparity can not be computed) are set to (state-&gt;minDisparity-1)*16</remarks>
        </member>
        <member name="M:Emgu.CV.StereoBM.FindStereoCorrespondence(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Single})">
            <summary>
            Computes disparity map for the input rectified stereo pair.
            </summary>
            <param name="left">The left single-channel, 8-bit image</param>
            <param name="right">The right image of the same size and the same type</param>
            <param name="disparity">The output single-channel 16-bit signed disparity map of the same size as input images. Its elements will be the computed disparities, multiplied by 16 and rounded to integer's</param>
            <remarks>Invalid pixels (for which disparity can not be computed) are set to state-&gt;minDisparity - 1 </remarks>
        </member>
        <member name="M:Emgu.CV.StereoBM.DisposeObject">
            <summary>
            Release the stereo state and all the memory associate with it
            </summary>
        </member>
        <member name="T:Emgu.CV.StereoGC">
            <summary>
            Use Graph Cut algorithm to find stereo correspondence
            </summary>
        </member>
        <member name="F:Emgu.CV.StereoGC.State">
            <summary>
            The state structure
            </summary>
        </member>
        <member name="M:Emgu.CV.StereoGC.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates the stereo correspondence state and initializes it. 
            </summary>
            <param name="numberOfDisparities">The number of disparities. The disparity search range will be state.minDisparity &lt;= disparity &lt; state.minDisparity + state.numberOfDisparities</param>
            <param name="maxIters">Maximum number of iterations. On each iteration all possible (or reasonable) alpha-expansions are tried. The algorithm may terminate earlier if it could not find an alpha-expansion that decreases the overall cost function value</param>
        </member>
        <member name="M:Emgu.CV.StereoGC.FindStereoCorrespondence(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Int16},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Int16})">
            <summary>
            Computes disparity map for the input rectified stereo pair.
            </summary>
            <param name="left">The left single-channel, 8-bit image</param>
            <param name="right">The right image of the same size and the same type</param>
            <param name="leftDisparity">The optional output single-channel 16-bit signed left disparity map of the same size as input images.</param>
            <param name="rightDisparity">The optional output single-channel 16-bit signed right disparity map of the same size as input images</param>
        </member>
        <member name="M:Emgu.CV.StereoGC.DisposeObject">
            <summary>
            Release the stereo state and all the memory associate with it
            </summary>
        </member>
        <member name="T:Emgu.CV.StereoSGBM">
            <summary>
            This is a variation of
            "Stereo Processing by Semiglobal Matching and Mutual Information"
            by Heiko Hirschmuller.
            We match blocks rather than individual pixels, thus the algorithm is called
            SGBM (Semi-global block matching)
            </summary>
        </member>
        <member name="M:Emgu.CV.StereoSGBM.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create a stereo disparity solver using StereoSGBM algorithm (combination of H. Hirschmuller + K. Konolige approaches) 
            </summary>
            <param name="minDisparity"></param>
            <param name="numDisparities"></param>
            <param name="SADWindowSize">Set this to 0 for default</param>
            <param name="P1">Use 0 for default</param>
            <param name="P2">Use 0 for default</param>
            <param name="disp12MaxDiff">Use 0 for default</param>
            <param name="preFilterCap">Use 0 for default</param>
            <param name="uniquenessRatio">Use 0 for default</param>
            <param name="speckleWindowSize">Use 0 for default</param>
            <param name="speckleRange">Use 0 for default</param>
            <param name="fullDP">Use false for default</param>
        </member>
        <member name="M:Emgu.CV.StereoSGBM.FindStereoCorrespondence(Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Int16})">
            <summary>
            Computes disparity map for the input rectified stereo pair.
            </summary>
            <param name="left">The left single-channel, 8-bit image</param>
            <param name="right">The right image of the same size and the same type</param>
            <param name="disparity">The output single-channel 16-bit signed disparity map of the same size as input images. Its elements will be the computed disparities, multiplied by 16 and rounded to integer's</param>
            <remarks>Invalid pixels (for which disparity can not be computed) are set to (state-&gt;minDisparity-1)*16</remarks>
        </member>
        <member name="M:Emgu.CV.StereoSGBM.DisposeObject">
            <summary>
            Release the unmanged memory associated with this stereo solver
            </summary>
        </member>
        <member name="T:Emgu.CV.StructSize">
            <summary>
            Cache the size of various header in bytes
            </summary>
        </member>
        <member name="P:Emgu.CV.StructSize.PointF">
            <summary>
            The size of PointF
            </summary>
        </member>
        <member name="P:Emgu.CV.StructSize.RangF">
            <summary>
            The size of RangF
            </summary>
        </member>
        <member name="P:Emgu.CV.StructSize.MCvPoint2D64f">
            <summary>
            The size of PointF
            </summary>
        </member>
        <member name="P:Emgu.CV.StructSize.MCvMat">
            <summary>
            The size of MCvMat
            </summary>
        </member>
        <member name="P:Emgu.CV.StructSize.MCvSeq">
            <summary>
            The size of MCvSeq
            </summary>
        </member>
        <member name="P:Emgu.CV.StructSize.MCvContour">
            <summary>
            The size of MCvContour
            </summary>
        </member>
        <member name="P:Emgu.CV.StructSize.MIplImage">
            <summary>
            The size of IplImage
            </summary>
        </member>
        <member name="P:Emgu.CV.StructSize.MCvSeqBlock">
            <summary>
            The size of IplImage
            </summary>
        </member>
        <member name="P:Emgu.CV.StructSize.MCvPoint3D32f">
            <summary>
            The size of MCvPoint3D32f
            </summary>
        </member>
        <member name="P:Emgu.CV.StructSize.MCvMatND">
            <summary>
            The size of MCvMatND
            </summary>
        </member>
        <member name="P:Emgu.CV.StructSize.MCvHistogram">
            <summary>
            The size of MCvHistogram
            </summary>
        </member>
        <member name="P:Emgu.CV.StructSize.MCvBlob">
            <summary>
            The size of MCvBlob
            </summary>
        </member>
        <member name="T:Emgu.CV.StructuringElementEx">
            <summary>
            A wrapper for the CvStructuringElementEx structure in opencv
            </summary>
        </member>
        <member name="M:Emgu.CV.StructuringElementEx.#ctor(System.Int32[0:,0:],System.Int32,System.Int32)">
            <summary>
            Create a custome shape Structuring Element
            </summary>
            <param name="values">The structuring element data, a plane array, representing row-by-row scanning of the element matrix. Non-zero values indicate points that belong to the element.</param>
            <param name="anchorX">Relative horizontal offset of the anchor point</param>
            <param name="anchorY">Relative vertical offset of the anchor point</param>
        </member>
        <member name="M:Emgu.CV.StructuringElementEx.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,Emgu.CV.CvEnum.CV_ELEMENT_SHAPE)">
            <summary>
            Create a structuring element of the specific type
            </summary>
            <param name="cols">Number of columns in the structuring element</param>
            <param name="rows">Number of rows in the structuring element</param>
            <param name="anchorX">Relative horizontal offset of the anchor point</param>
            <param name="anchorY">Relative vertical offset of the anchor point</param>
            <param name="shape">Shape of the structuring element</param>
        </member>
        <member name="M:Emgu.CV.StructuringElementEx.DisposeObject">
            <summary>
            Release the unmanaged memory associated to this object
            </summary>
        </member>
        <member name="T:Emgu.CV.SURFFeature">
            <summary>
            A SURF feature
            </summary>
        </member>
        <member name="M:Emgu.CV.SURFFeature.#ctor(Emgu.CV.Structure.MCvSURFPoint@,System.Single[])">
            <summary>
            Create a SURF feature from the specific point and descriptor
            </summary>
            <param name="point">The MCvSURFPoint structure</param>
            <param name="descriptor">The feature descriptor</param>
        </member>
        <member name="P:Emgu.CV.SURFFeature.Point">
            <summary>
            The SURF point
            </summary>
        </member>
        <member name="P:Emgu.CV.SURFFeature.Descriptor">
            <summary>
            The feature descriptor as an array
            </summary>
        </member>
        <member name="T:Emgu.CV.SURFTracker">
            <summary>
            This class use SURF and CamShift to track object
            </summary>
        </member>
        <member name="M:Emgu.CV.SURFTracker.#ctor(Emgu.CV.SURFFeature[])">
            <summary>
            Create a SURF tracker, where SURF is matched with flann
            </summary>
            <param name="modelFeatures">The SURF feature from the model image</param>
        </member>
        <member name="M:Emgu.CV.SURFTracker.CamShiftTrack(Emgu.CV.SURFFeature[],Emgu.CV.Structure.MCvBox2D,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Single})">
            <summary>
            Use camshift to track the feature
            </summary>
            <param name="observedFeatures">The feature found from the observed image</param>
            <param name="initRegion">The predicted location of the model in the observed image. If not known, use MCvBox2D.Empty as default</param>
            <param name="priorMask">The mask that should be the same size as the observed image. Contains a priori value of the probability a match can be found. If you are not sure, pass an image fills with 1.0s</param>
            <returns>If a match is found, the homography projection matrix is returned. Otherwise null is returned</returns>
        </member>
        <member name="M:Emgu.CV.SURFTracker.Detect(Emgu.CV.SURFFeature[],System.Double)">
            <summary>
            Detect the if the model features exist in the observed features. If true, an homography matrix is returned, otherwise, null is returned.
            </summary>
            <param name="observedFeatures">The observed features</param>
            <param name="uniquenessThreshold">The distance different ratio which a match is consider unique, a good number will be 0.8</param>
            <returns>If the model features exist in the observed features, an homography matrix is returned, otherwise, null is returned.</returns>
        </member>
        <member name="M:Emgu.CV.SURFTracker.GetHomographyMatrixFromMatchedFeatures(Emgu.CV.SURFTracker.MatchedSURFFeature[])">
            <summary>
            Recover the homography matrix using RANDSAC. If the matrix cannot be recovered, null is returned.
            </summary>
            <param name="matchedFeatures">The Matched Features, only the first ModelFeature will be considered</param>
            <returns>The homography matrix, if it cannot be found, null is returned</returns>
        </member>
        <member name="M:Emgu.CV.SURFTracker.VoteForUniqueness(Emgu.CV.SURFTracker.MatchedSURFFeature[],System.Double)">
            <summary>
            Filter the matched Features, such that if a match is not unique, it is rejected.
            </summary>
            <param name="matchedFeatures">The Matched SURF features, each of them has the model feature sorted by distance. (e.g. SortMatchedFeaturesByDistance )</param>
            <param name="uniquenessThreshold">The distance different ratio which a match is consider unique, a good number will be 0.8</param>
            <returns>The filtered matched SURF Features</returns>
        </member>
        <member name="M:Emgu.CV.SURFTracker.VoteForSizeAndOrientation(Emgu.CV.SURFTracker.MatchedSURFFeature[],System.Double,System.Int32)">
            <summary>
            Eliminate the matched features whose scale and rotation do not aggree with the majority's scale and rotation.
            </summary>
            <param name="rotationBins">The numbers of bins for rotation, a good value might be 20 (which means each bin covers 18 degree)</param>
            <param name="scaleIncrement">This determins the different in scale for neighbour hood bins, a good value might be 1.5 (which means matched features in bin i+1 is scaled 1.5 times larger than matched features in bin i</param>
            <param name="matchedFeatures">The matched feature that will be participated in the voting. For each matchedFeatures, only the zero indexed ModelFeature will be considered.</param>
        </member>
        <member name="M:Emgu.CV.SURFTracker.DisposeObject">
            <summary>
            Release unmanaged memory
            </summary>
        </member>
        <member name="M:Emgu.CV.SURFTracker.ReleaseManagedResources">
            <summary>
            Release the memory assocaited with this SURF Tracker
            </summary>
        </member>
        <member name="M:Emgu.CV.SURFTracker.MatchFeature(Emgu.CV.SURFFeature[],System.Int32,System.Int32)">
            <summary>
            Match the SURF feature from the observed image to the features from the model image
            </summary>
            <param name="observedFeatures">The SURF feature from the observed image</param>
            <param name="k">The number of neighbors to find</param>
            <param name="emax">For k-d tree only: the maximum number of leaves to visit.</param>
            <returns>The matched features</returns>
        </member>
        <member name="T:Emgu.CV.SURFTracker.SimilarFeature">
            <summary>
            A similar feature is a structure that contains a SURF feature and its corresponding distance to the comparing SURF feature
            </summary>
        </member>
        <member name="M:Emgu.CV.SURFTracker.SimilarFeature.#ctor(System.Double,Emgu.CV.SURFFeature)">
            <summary>
            Create a similar SURF feature
            </summary>
            <param name="distance">The distance to the comparing SURF feature</param>
            <param name="feature">A similar SURF feature</param>
        </member>
        <member name="P:Emgu.CV.SURFTracker.SimilarFeature.Distance">
            <summary>
            The distance to the comparing SURF feature
            </summary>
        </member>
        <member name="P:Emgu.CV.SURFTracker.SimilarFeature.Feature">
            <summary>
            A similar SURF feature
            </summary>
        </member>
        <member name="T:Emgu.CV.SURFTracker.MatchedSURFFeature">
            <summary>
            The matched SURF feature
            </summary>
        </member>
        <member name="F:Emgu.CV.SURFTracker.MatchedSURFFeature.ObservedFeature">
            <summary>
            The observed feature
            </summary>
        </member>
        <member name="M:Emgu.CV.SURFTracker.MatchedSURFFeature.#ctor(Emgu.CV.SURFFeature,Emgu.CV.SURFFeature[],System.Double[])">
            <summary>
            Create a matched feature structure.
            </summary>
            <param name="observedFeature">The feature from the observed image</param>
            <param name="modelFeatures">The matched feature from the model</param>
            <param name="dist">The distances between the feature from the observerd image and the matched feature from the model image</param>
        </member>
        <member name="P:Emgu.CV.SURFTracker.MatchedSURFFeature.SimilarFeatures">
            <summary>
            An array of similar features from the model image
            </summary>
        </member>
        <member name="T:Emgu.CV.SURFTracker.SURFMatcher">
            <summary>
            A simple class that use flann to match SURF features. 
            </summary>
        </member>
        <member name="M:Emgu.CV.SURFTracker.SURFMatcher.#ctor(Emgu.CV.SURFFeature[])">
            <summary>
            Create k-d feature trees using the SURF feature extracted from the model image.
            </summary>
            <param name="modelFeatures">The SURF feature extracted from the model image</param>
        </member>
        <member name="M:Emgu.CV.SURFTracker.SURFMatcher.MatchFeature(Emgu.CV.SURFFeature[],System.Int32,System.Int32)">
            <summary>
            Match the SURF feature from the observed image to the features from the model image
            </summary>
            <param name="observedFeatures">The SURF feature from the observed image</param>
            <param name="k">The number of neighbors to find</param>
            <param name="emax">For k-d tree only: the maximum number of leaves to visit.</param>
            <returns>The matched features</returns>
        </member>
        <member name="M:Emgu.CV.SURFTracker.SURFMatcher.DisposeObject">
            <summary>
            Release the unmanaged memory associate with this matcher
            </summary>
        </member>
        <member name="T:Emgu.CV.TimedImage`2">
            <summary> 
            The Image which contains time stamp which specified what time this image is created 
            </summary>
        </member>
        <member name="M:Emgu.CV.TimedImage`2.#ctor">
            <summary>
            Create a empty Image 
            </summary>
        </member>
        <member name="M:Emgu.CV.TimedImage`2.#ctor(System.Int32,System.Int32,`0)">
            <summary>
            Create a blank Image of the specified width, height, depth and color.
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
            <param name="value">The initial color of the image</param>
        </member>
        <member name="M:Emgu.CV.TimedImage`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Create an empty Image of the specified width and height
            </summary>
            <param name="width">The width of the image</param>
            <param name="height">The height of the image</param>
        </member>
        <member name="P:Emgu.CV.TimedImage`2.Timestamp">
            <summary> 
            The time this image is captured
            </summary>
        </member>
        <member name="T:Emgu.CV.Util">
            <summary>
            Utilities class
            </summary>
        </member>
        <member name="F:Emgu.CV.Util.GrayscalePalette">
            <summary>
            The ColorPalette of Grayscale for Bitmap Format8bppIndexed
            </summary>
        </member>
        <member name="M:Emgu.CV.Util.ColorPaletteToLookupTable(System.Drawing.Imaging.ColorPalette,Emgu.CV.Matrix{System.Byte}@,Emgu.CV.Matrix{System.Byte}@,Emgu.CV.Matrix{System.Byte}@,Emgu.CV.Matrix{System.Byte}@)">
            <summary>
            Convert the color pallette to four lookup tables
            </summary>
            <param name="pallette">The color pallette to transform</param>
            <param name="bTable">Lookup table for the B channel</param>
            <param name="gTable">Lookup table for the G channel</param>
            <param name="rTable">Lookup table for the R channel</param>
            <param name="aTable">Lookup table for the A channel</param>
        </member>
        <member name="M:Emgu.CV.Util.GetModuleInfo(System.String@,System.String@)">
            <summary>
            Returns information about one of or all of the registered modules
            </summary>
            <param name="pluginName">The list of names and versions of the optimized plugins that CXCORE was able to find and load</param>
            <param name="versionName">Information about the module(s), including version</param>
        </member>
        <member name="M:Emgu.CV.Util.OptimizeCV(System.Boolean)">
            <summary>
            Enable or diable IPL optimization for opencv
            </summary>
            <param name="enable">true to enable optimization, false to disable</param>
        </member>
        <member name="M:Emgu.CV.Util.GetMatrixDepth(System.Type)">
            <summary>
            Get the OpenCV matrix depth enumeration from depth type
            </summary>
            <param name="typeOfDepth">The depth of type</param>
            <returns>OpenCV Matrix depth</returns>
        </member>
        <member name="M:Emgu.CV.Util.GetMatrixFromDescriptors(System.Single[][])">
            <summary>
            Convert an array of descriptors to row by row matrix
            </summary>
            <param name="descriptors">An array of descriptors</param>
            <returns>A matrix where each row is a descriptor</returns>
        </member>
        <member name="T:Emgu.CV.VideoSurveillance.BGCodeBookModel`1">
            <summary>
            Background code book model
            </summary>
            <typeparam name="TColor"> The type of color for the image</typeparam>
        </member>
        <member name="T:Emgu.CV.VideoSurveillance.IBGFGDetector`1">
            <summary>
            The interface for a Background / Forground Detector
            </summary>
            <typeparam name="TColor">The type of color image to be analyzed</typeparam>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.IBGFGDetector`1.Update(Emgu.CV.Image{`0,System.Byte})">
            <summary>
            Update the FGBG 
            </summary>
            <param name="image">The image which will be used to update the BGFG detector</param>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.IBGFGDetector`1.ForgroundMask">
            <summary>
            Get the mask of the forground
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.IBGFGDetector`1.BackgroundMask">
            <summary>
            Get the mask of the background
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BGCodeBookModel`1.#ctor">
            <summary>
            Create a background code book model
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BGCodeBookModel`1.Update(Emgu.CV.Image{`0,System.Byte},System.Drawing.Rectangle,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Update the BG code book model
            </summary>
            <param name="image">The image for update</param>
            <param name="roi">The update roi, use Rectangle.Empty for the whole image</param>
            <param name="mask">Can be null if not needed. The update mask</param>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BGCodeBookModel`1.Update(Emgu.CV.Image{`0,System.Byte})">
            <summary>
            Update the BG code book model
            </summary>
            <param name="image">The image for update</param>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BGCodeBookModel`1.ClearStale(System.Int32,System.Drawing.Rectangle,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            
            </summary>
            <param name="staleThresh"></param>
            <param name="roi">The region of interest. Use Rectangle.Empty for the whole image</param>
            <param name="mask">Mask for Clear Stale. Can be null if not needed.</param>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BGCodeBookModel`1.DisposeObject">
            <summary>
            Release the unmanaged resource that is associated to this object
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BGCodeBookModel`1.ReleaseManagedResources">
            <summary>
            Release the managed resource
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.BGCodeBookModel`1.ForgroundMask">
            <summary>
            Get the forground mask. Do not dispose this image.
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.BGCodeBookModel`1.BackgroundMask">
            <summary>
            Get the background mask. Do not dispose this image.
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.BGCodeBookModel`1.MCvBGCodeBookModel">
            <summary>
            Get or Set the equivalent CVBGCodeBookModel structure
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoSurveillance.BGStatModel`1">
            <summary>
            Background statistics model
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BGStatModel`1.#ctor(Emgu.CV.Image{`0,System.Byte},Emgu.CV.CvEnum.BG_STAT_TYPE)">
            <summary>
            Create a BGStatModel
            </summary>
            <param name="image">The image used for initiating the statistic model</param>
            <param name="type">The type of the statistics model</param>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BGStatModel`1.#ctor(Emgu.CV.Image{`0,System.Byte},Emgu.CV.Structure.MCvFGDStatModelParams@)">
            <summary>
            Create a forground statistic model using the given parameters
            </summary>
            <param name="image">The image used for initiating the statistic model</param>
            <param name="parameters">FGDStatModel</param>
        </member>
        <member name="F:Emgu.CV.VideoSurveillance.BGStatModel`1.updateFunction">
            <summary>
            A cache of the update function
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BGStatModel`1.Update(Emgu.CV.Image{`0,System.Byte},System.Double)">
            <summary>
            Update the statistic model
            </summary>
            <param name="image"></param>
            <param name="learningRate">Use -1 for default</param>
            <returns>The number of found forground regions</returns>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BGStatModel`1.Update(Emgu.CV.Image{`0,System.Byte})">
            <summary>
            Update the statistic model
            </summary>
            <param name="image"></param>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BGStatModel`1.DisposeObject">
            <summary>
            Release the BGStatModel and all the unmanaged memory associate with it
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.BGStatModel`1.MCvBGStatModel">
            <summary>
            Get the MCvBGStatModel structure
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.BGStatModel`1.BackgroundMask">
            <summary>
            Get a copy of the current background
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.BGStatModel`1.ForgroundMask">
            <summary>
            Get a copy of the mask for the current forground
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoSurveillance.BGStatModelDelegates.UpdateFunctionDelagate">
            <summary>
            Defines an image update function
            </summary>
            <param name="img">The image to be used for update</param>
            <param name="statModel">The stat model to update</param>
            <param name="learningRate">Use -1 for default</param>
            <returns></returns>
        </member>
        <member name="T:Emgu.CV.VideoSurveillance.BGStatModelDelegates.ReleaseFunction">
            <summary>
            Define the Release function
            </summary>
            <param name="ptr">The background mode to be released</param>
        </member>
        <member name="T:Emgu.CV.VideoSurveillance.BlobDetector">
            <summary>
            A blob detector
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BlobDetector.#ctor(Emgu.CV.CvEnum.BLOB_DETECTOR_TYPE)">
            <summary>
            Create a blob detector of specific type
            </summary>
            <param name="type">The type of the detector</param>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BlobDetector.DetectNewBlob(Emgu.CV.IImage,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte},Emgu.CV.VideoSurveillance.BlobSeq,Emgu.CV.VideoSurveillance.BlobSeq)">
            <summary>
            Detect new blobs
            </summary>
            <param name="image">The image</param>
            <param name="imageForground">The forground mask</param>
            <param name="newBlob">The new blob list</param>
            <param name="oldBlob">The old blob list</param>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BlobDetector.DisposeObject">
            <summary>
            Release the detector
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoSurveillance.BlobSeq">
            <summary>
            a Blob Seq
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoSurveillance.BlobSeqBase">
            <summary>
            An abstract class that server as a base class for Blob sequence
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BlobSeqBase.GetBlobByID(System.Int32)">
            <summary>
            Get the blob with the specific id
            </summary>
            <param name="blobID">The id of the blob</param>
            <returns>The blob of the specific id, if do not exist, null is returned</returns>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BlobSeqBase.GetEnumerator">
            <summary>
            Get an enumerator of all the blobs in this blob sequence.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.BlobSeqBase.Count">
            <summary>
            The number of blobs in this sequence
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.BlobSeqBase.Item(System.Int32)">
            <summary>
            Return the blob given the specific index
            </summary>
            <param name="i">The index of the blob</param>
            <returns>The blob in the specific index</returns>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BlobSeq.#ctor(System.IntPtr)">
            <summary>
            Create a BlobSeq from the given pointer
            </summary>
            <param name="ptr">The pointer to the unmanaged BlobSeq</param>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BlobSeq.#ctor">
            <summary>
            Create a empty BlobSeq
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BlobSeq.GetBlobByID(System.Int32)">
            <summary>
            Get the blob with the specific id
            </summary>
            <param name="blobID">The id of the blob</param>
            <returns>The blob of the specific id, if it doesn't exist, null is returned</returns>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BlobSeq.DisposeObject">
            <summary>
            Release the BlobSeq
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.BlobSeq.Count">
            <summary>
            Get the total number of blob in the sequence
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.BlobSeq.Item(System.Int32)">
            <summary>
            Return the specific blob 
            </summary>
            <param name="i">the index of the blob</param>
            <returns>The specific blob</returns>
        </member>
        <member name="T:Emgu.CV.VideoSurveillance.BlobTracker">
            <summary>
            A Blob Tracker
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BlobTracker.#ctor(Emgu.CV.CvEnum.BLOBTRACKER_TYPE)">
            <summary>
            Create a blob trakcer of the specific type
            </summary>
            <param name="type">The type of the blob tracker</param>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BlobTracker.Add(Emgu.CV.Structure.MCvBlob,Emgu.CV.IImage,Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Add new blob to track it and assign to this blob personal ID
            </summary>
            <param name="blob">Structure with blob parameters (ID is ignored)</param>
            <param name="currentImage">current image</param>
            <param name="currentForgroundMask">Current foreground mask</param>
            <returns>Newly added blob</returns>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BlobTracker.RemoveAt(System.Int32)">
            <summary>
            Delete blob by its index
            </summary>
            <param name="blobIndex">The index of the blob</param>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BlobTracker.GetBlobByID(System.Int32)">
            <summary>
            Get the blob with the specific id
            </summary>
            <param name="blobID">The id of the blob</param>
            <returns>The blob of the specific id, if it doesn't exist, null is returned</returns>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BlobTracker.DisposeObject">
            <summary>
            Release the blob trakcer
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.BlobTracker.Item(System.Int32)">
            <summary>
            Return the blob given the specific index
            </summary>
            <param name="i">The index of the blob</param>
            <returns>The blob in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.BlobTracker.Count">
            <summary>
            Get the number of blobs in this tracker
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoSurveillance.BlobTrackerAuto`1">
            <summary>
            A blob tracker auto
            </summary>
            <typeparam name="TColor">The type of color for the image to be tracked.</typeparam>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BlobTrackerAuto`1.#ctor(Emgu.CV.VideoSurveillance.BlobTrackerAutoParam{`0})">
            <summary>
            Create a auto blob tracker using the specific parameters
            </summary>
            <param name="param">The parameters for this blob tracker auto</param>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BlobTrackerAuto`1.#ctor">
            <summary>
            Create a default auto blob tracker 
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BlobTrackerAuto`1.Process(Emgu.CV.Image{`0,System.Byte})">
            <summary>
            Process a frame
            </summary>
            <param name="currentFrame">The frame to be processed</param>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BlobTrackerAuto`1.Process(Emgu.CV.Image{`0,System.Byte},Emgu.CV.Image{Emgu.CV.Structure.Gray,System.Byte})">
            <summary>
            Process a frame
            </summary>
            <param name="currentFrame">The frame to be processed</param>
            <param name="forgroundMask">the forground mask to be used</param>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BlobTrackerAuto`1.GetBlobByID(System.Int32)">
            <summary>
            Get the blob with the specific id
            </summary>
            <param name="blobID">The id of the blob</param>
            <returns>The blob of the specific id, if it doesn't exist, null is returned</returns>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BlobTrackerAuto`1.DisposeObject">
            <summary>
            Release the blob tracker auto
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.BlobTrackerAuto`1.ForgroundMask">
            <summary>
            Get the forground mask
            </summary>
            <returns>The forground mask</returns>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.BlobTrackerAuto`1.Param">
            <summary>
            The parameters for this blob tracker auto
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.BlobTrackerAuto`1.Item(System.Int32)">
            <summary>
            Return the blob given the specific index
            </summary>
            <param name="i">The index of the blob</param>
            <returns>The blob in the specific index</returns>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.BlobTrackerAuto`1.Count">
            <summary>
            Get the number of blobs in this tracker
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoSurveillance.BlobTrackerAutoParam`1">
            <summary>
            Parameters of blobtracker auto ver1
            </summary>
            <typeparam name="TColor">The type of color for the image to be tracked. Due to a bug in OpenCV, only Gray is supported at the moment</typeparam>
        </member>
        <member name="F:Emgu.CV.VideoSurveillance.BlobTrackerAutoParam`1._FGTrainFrames">
            <summary>
            Number of frames needed for FG (foreground) detector to train.
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoSurveillance.BlobTrackerAutoParam`1._forgroundDetector">
            <summary>
            FGDetector module. If this field is NULL the Process FG mask is used.
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoSurveillance.BlobTrackerAutoParam`1._blobDetector">
            <summary>
            Selected blob detector module. If this field is NULL default blobdetector module will be created.
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoSurveillance.BlobTrackerAutoParam`1._blobTracker">
            <summary>
            Selected blob tracking module. If this field is NULL default blobtracker module will be created.
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoSurveillance.BlobTrackerAutoParam`1.BTGen">
            <summary>
            Selected blob trajectory generator. If this field is IntPtr.Zero no generator is used.
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoSurveillance.BlobTrackerAutoParam`1._postProcessModule">
            <summary>
            Selected blob trajectory postprocessing module. If this field is NULL no postprocessing is done. 
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoSurveillance.BlobTrackerAutoParam`1._usePPData">
            <summary>
            Indicates if postprocess data should be used
            </summary>
        </member>
        <member name="F:Emgu.CV.VideoSurveillance.BlobTrackerAutoParam`1.BTA">
            <summary>
            Selected blob trajectory analysis module. If this field is NULL no track analysis is done.   
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.BlobTrackerAutoParam`1.BTPP">
            <summary>
            Selected blob trajectory postprocessing module. If this field is NULL no postprocessing is done. 
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.BlobTrackerAutoParam`1.BlobDetector">
            <summary>
            Selected blob detector module. If this field is NULL default blobdetector module will be created.
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.BlobTrackerAutoParam`1.BlobTracker">
            <summary>
            Selected blob tracking module. If this field is NULL default blobtracker module will be created.
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.BlobTrackerAutoParam`1.FGTrainFrames">
            <summary>
            Number of frames needed for FG (foreground) detector to train.
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.BlobTrackerAutoParam`1.FGDetector">
            <summary>
            FGDetector module. If this field is NULL the Process FG mask is used.
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.BlobTrackerAutoParam`1.UsePPData">
            <summary>
            Indicates if postprocess data should be used
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.BlobTrackerAutoParam`1.MCvBlobTrackerAutoParam1">
            <summary>
            Get the equivalent MCvBlobTrackerAutoParam1
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoSurveillance.BlobTrackPostProc">
            <summary>
            A blob tracking post process module
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BlobTrackPostProc.#ctor(Emgu.CV.CvEnum.BLOB_POST_PROCESS_TYPE)">
            <summary>
            Create a blob tracking post process module of the specific type
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.BlobTrackPostProc.DisposeObject">
            <summary>
            Release the post process module
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoSurveillance.FGDetector`1">
            <summary>
            A forground detector
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.FGDetector`1.#ctor(Emgu.CV.CvEnum.FORGROUND_DETECTOR_TYPE)">
            <summary>
            Create a forground detector of the specific type
            </summary>
            <param name="type">The type of the detector to be created</param>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.FGDetector`1.Update(Emgu.CV.Image{`0,System.Byte})">
            <summary>
            Update the forground detector using the specific image
            </summary>
            <param name="image">The image which will be used to update the FGDetector</param>
        </member>
        <member name="M:Emgu.CV.VideoSurveillance.FGDetector`1.DisposeObject">
            <summary>
            Release the forground detector
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.FGDetector`1.ForgroundMask">
            <summary>
            Get the forground mask from the detector
            </summary>
        </member>
        <member name="P:Emgu.CV.VideoSurveillance.FGDetector`1.BackgroundMask">
            <summary>
            Get the background mask
            </summary>
        </member>
        <member name="T:Emgu.CV.VideoWriter">
            <summary>
            Create a video writer that write images to video format
            </summary>
        </member>
        <member name="M:Emgu.CV.VideoWriter.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create a video writer using the specific information
            </summary>
            <param name="fileName">The name of the video file to be written to </param>
            <param name="fps">frame rate per second</param>
            <param name="width">the width of the frame</param>
            <param name="height">the height of the frame</param>
            <param name="isColor">true if this is a color video, false otherwise</param>
        </member>
        <member name="M:Emgu.CV.VideoWriter.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Create a video writer using the specific information
            </summary>
            <param name="fileName">The name of the video file to be written to </param>
            <param name="compressionCode">compression code</param>
            <param name="fps">frame rate per second</param>
            <param name="width">the width of the frame</param>
            <param name="height">the height of the frame</param>
            <param name="isColor">true if this is a color video, false otherwise</param>
        </member>
        <member name="M:Emgu.CV.VideoWriter.WriteFrame``2(Emgu.CV.Image{``0,``1})">
            <summary>
            Write a single frame to the video writer
            </summary>
            <typeparam name="TColor">The color type of the frame</typeparam>
            <typeparam name="TDepth">The depth of the frame</typeparam>
            <param name="frame">The frame to be written to the video writer</param>
        </member>
        <member name="M:Emgu.CV.VideoWriter.DisposeObject">
            <summary>
            Release the video writer and all the memory associate with it
            </summary>
        </member>
    </members>
</doc>
